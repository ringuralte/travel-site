
chdir(/etc)
fchdir() to previous dir
sourcing "/etc/vimrc"
line 1: " All system-wide defaults are set in $VIMRUNTIME/archlinux.vim (usually just
line 2: " /usr/share/vim/vimfiles/archlinux.vim) and sourced by the call to :runtime
line 3: " you can find below.  If you wish to change any of those settings, you should
line 4: " do it in this file (/etc/vimrc), since archlinux.vim will be overwritten
line 5: " everytime an upgrade of the vim packages is performed.  It is recommended to
line 6: " make changes after sourcing archlinux.vim since it alters the value of the
line 7: " 'compatible' option.
line 8: 
line 9: " This line should not be removed as it ensures that various options are
line 10: " properly set to work with the Vim-related packages.
line 11: runtime! archlinux.vim
Searching for "archlinux.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/archlinux.vim"
chdir(/usr/share/vim/vimfiles)
fchdir() to previous dir
line 11: sourcing "/usr/share/vim/vimfiles/archlinux.vim"
line 1: " The Arch Linux global vimrc - setting only a few sane defaults
line 2: "
line 3: " DO NOT EDIT THIS FILE. IT'S OVERWRITTEN UPON UPGRADES.
line 4: "
line 5: " Use /etc/vimrc for system-wide and $HOME/.vimrc for personal configuration
line 6: " (for details see ':help initialization').
line 7: "
line 8: " Use :help '<option>' to see the documentation for the given option.
line 9: 
line 10: " Use Vim defaults instead of 100% vi compatibility
line 11: " Avoid side-effects when nocompatible has already been set.
line 12: if &compatible
line 13:   set nocompatible
line 14: endif
line 15: 
line 16: set backspace=indent,eol,start
line 17: set ruler
line 18: set suffixes+=.aux,.bbl,.blg,.brf,.cb,.dvi,.idx,.ilg,.ind,.inx,.jpg,.log,.out,.png,.toc
line 19: set suffixes-=.h
line 20: set suffixes-=.obj
line 21: 
line 22: " Move temporary files to a secure location to protect against CVE-2017-1000382
line 23: if exists('$XDG_CACHE_HOME')
line 24:   let &g:directory=$XDG_CACHE_HOME
line 25: else
line 26:   let &g:directory=$HOME . '/.cache'
line 27: endif
line 28: let &g:undodir=&g:directory . '/vim/undo//'
line 29: let &g:backupdir=&g:directory . '/vim/backup//'
line 30: let &g:directory.='/vim/swap//'
line 31: " Create directories if they doesn't exist
line 32: if ! isdirectory(expand(&g:directory))
line 33:   silent! call mkdir(expand(&g:directory), 'p', 0700)
line 34: endif
line 35: if ! isdirectory(expand(&g:backupdir))
line 36:   silent! call mkdir(expand(&g:backupdir), 'p', 0700)
line 37: endif
line 38: if ! isdirectory(expand(&g:undodir))
line 39:   silent! call mkdir(expand(&g:undodir), 'p', 0700)
line 40: endif
line 41: 
line 42: " Make shift-insert work like in Xterm
line 43: if has('gui_running')
line 44:   map <S-Insert> <MiddleMouse>
line 45:   map! <S-Insert> <MiddleMouse>
line 46: endif
finished sourcing /usr/share/vim/vimfiles/archlinux.vim
continuing in /etc/vimrc
Searching for "/usr/share/vim/vim81/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/after/archlinux.vim"
Searching for "/home/ringu/.vim/after/archlinux.vim"
line 12: 
line 13: " If you prefer the old-style vim functionalty, add 'runtime! vimrc_example.vim'
line 14: " Or better yet, read /usr/share/vim/vim80/vimrc_example.vim or the vim manual
line 15: " and configure vim to your own liking!
line 16: 
line 17: " do not load defaults if ~/.vimrc is missing
line 18: "let skip_defaults_vim=1
finished sourcing /etc/vimrc
chdir(/home/ringu)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: call plug#begin()
Searching for "autoload/plug.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/plug.vim"
chdir(/home/ringu/.vim/autoload)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/autoload/plug.vim"
line 1: " vim-plug: Vim plugin manager
line 2: " ============================
line 3: "
line 4: " Download plug.vim and put it in ~/.vim/autoload
line 5: "
line 6: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
line 7: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
line 8: "
line 9: " Edit your .vimrc
line 10: "
line 11: "   call plug#begin('~/.vim/plugged')
line 12: "
line 13: "   " Make sure you use single quotes
line 14: "
line 15: "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
line 16: "   Plug 'junegunn/vim-easy-align'
line 17: "
line 18: "   " Any valid git URL is allowed
line 19: "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'
line 20: "
line 21: "   " Group dependencies, vim-snippets depends on ultisnips
line 22: "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
line 23: "
line 24: "   " On-demand loading
line 25: "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
line 26: "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
line 27: "
line 28: "   " Using a non-master branch
line 29: "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
line 30: "
line 31: "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
line 32: "   Plug 'fatih/vim-go', { 'tag': '*' }
line 33: "
line 34: "   " Plugin options
line 35: "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
line 36: "
line 37: "   " Plugin outside ~/.vim/plugged with post-update hook
line 38: "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
line 39: "
line 40: "   " Unmanaged plugin (manually installed and updated)
line 41: "   Plug '~/my-prototype-plugin'
line 42: "
line 43: "   " Add plugins to &runtimepath
line 44: "   call plug#end()
line 45: "
line 46: " Then reload .vimrc and :PlugInstall to install plugins.
line 47: "
line 48: " Plug options:
line 49: "
line 50: "| Option                  | Description                                      |
line 51: "| ----------------------- | ------------------------------------------------ |
line 52: "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
line 53: "| `rtp`                   | Subdirectory that contains Vim plugin            |
line 54: "| `dir`                   | Custom directory for the plugin                  |
line 55: "| `as`                    | Use different name for the plugin                |
line 56: "| `do`                    | Post-update hook (string or funcref)             |
line 57: "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
line 58: "| `for`                   | On-demand loading: File types                    |
line 59: "| `frozen`                | Do not update unless explicitly specified        |
line 60: "
line 61: " More information: https://github.com/junegunn/vim-plug
line 62: "
line 63: "
line 64: " Copyright (c) 2016 Junegunn Choi
line 65: "
line 66: " MIT License
line 67: "
line 68: " Permission is hereby granted, free of charge, to any person obtaining
line 69: " a copy of this software and associated documentation files (the
line 70: " "Software"), to deal in the Software without restriction, including
line 71: " without limitation the rights to use, copy, modify, merge, publish,
line 72: " distribute, sublicense, and/or sell copies of the Software, and to
line 73: " permit persons to whom the Software is furnished to do so, subject to
line 74: " the following conditions:
line 75: "
line 76: " The above copyright notice and this permission notice shall be
line 77: " included in all copies or substantial portions of the Software.
line 78: "
line 79: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 80: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 81: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 82: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 83: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 84: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 85: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 86: 
line 87: if exists('g:loaded_plug')
line 88:   finish
line 89: endif
line 90: let g:loaded_plug = 1
line 91: 
line 92: let s:cpo_save = &cpo
line 93: set cpo&vim
line 94: 
line 95: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
line 96: let s:plug_tab = get(s:, 'plug_tab', -1)
line 97: let s:plug_buf = get(s:, 'plug_buf', -1)
line 98: let s:mac_gui = has('gui_macvim') && has('gui_running')
line 99: let s:is_win = has('win32') || has('win64')
line 100: let s:nvim = has('nvim') && exists('*jobwait') && !s:is_win
line 101: let s:me = resolve(expand('<sfile>:p'))
line 102: let s:base_spec = { 'branch': 'master', 'frozen': 0 }
line 108: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }
line 109: let s:loaded = get(s:, 'loaded', {})
line 110: let s:triggers = get(s:, 'triggers', {})
line 111: 
line 112: function! plug#begin(...)
line 132: 
line 133: function! s:define_commands()
line 146: 
line 147: function! s:to_a(v)
line 150: 
line 151: function! s:to_s(v)
line 154: 
line 155: function! s:glob(from, pattern)
line 158: 
line 159: function! s:source(from, ...)
line 169: 
line 170: function! s:assoc(dict, key, val)
line 173: 
line 174: function! s:ask(message, ...)
line 183: 
line 184: function! s:ask_no_interrupt(...)
line 191: 
line 192: function! plug#end()
line 281: 
line 282: function! s:loaded_names()
line 285: 
line 286: function! s:load_plugin(spec)
line 289: 
line 290: function! s:reload_plugins()
line 295: 
line 296: function! s:trim(str)
line 299: 
line 300: function! s:version_requirement(val, min)
line 309: 
line 310: function! s:git_version_requirement(...)
line 316: 
line 317: function! s:progress_opt(base)
line 321: 
line 322: if s:is_win
line 323:   function! s:rtp(spec)
line 326: 
line 327:   function! s:path(path)
line 330: 
line 331:   function! s:dirpath(path)
line 334: 
line 335:   function! s:is_local_plug(repo)
line 338: else
line 339:   function! s:rtp(spec)
line 342: 
line 343:   function! s:path(path)
line 346: 
line 347:   function! s:dirpath(path)
line 350: 
line 351:   function! s:is_local_plug(repo)
line 354: endif
line 355: 
line 356: function! s:err(msg)
line 361: 
line 362: function! s:warn(cmd, msg)
line 367: 
line 368: function! s:esc(path)
line 371: 
line 372: function! s:escrtp(path)
line 375: 
line 376: function! s:remove_rtp()
line 386: 
line 387: function! s:reorg_rtp()
line 413: 
line 414: function! s:doautocmd(...)
line 419: 
line 420: function! s:dobufread(names)
line 430: 
line 431: function! plug#load(...)
line 449: 
line 450: function! s:remove_triggers(name)
line 463: 
line 464: function! s:lod(names, types, ...)
line 485: 
line 486: function! s:lod_ft(pat, names)
line 493: 
line 494: function! s:lod_cmd(cmd, bang, l1, l2, args, names)
line 499: 
line 500: function! s:lod_map(map, names, prefix)
line 520: 
line 521: function! plug#(repo, ...)
line 540: 
line 541: function! s:parse_options(arg)
line 556: 
line 557: function! s:infer_properties(name, repo)
line 575: 
line 576: function! s:install(force, names)
line 579: 
line 580: function! s:update(force, names)
line 583: 
line 584: function! plug#helptags()
line 596: 
line 597: function! s:syntax()
line 648: 
line 649: function! s:lpad(str, len)
line 652: 
line 653: function! s:lines(msg)
line 656: 
line 657: function! s:lastline(msg)
line 660: 
line 661: function! s:new_window()
line 664: 
line 665: function! s:plug_window_exists()
line 669: 
line 670: function! s:switch_in()
line 688: 
line 689: function! s:switch_out(...)
line 702: 
line 703: function! s:finish_bindings()
line 712: 
line 713: function! s:prepare(...)
line 748: 
line 749: function! s:assign_name()
line 760: 
line 761: function! s:chsh(swap)
line 768: 
line 769: function! s:bang(cmd, ...)
line 783: 
line 784: function! s:regress_bar()
line 788: 
line 789: function! s:is_updated(dir)
line 792: 
line 793: function! s:do(pull, force, todo)
line 834: 
line 835: function! s:hash_match(a, b)
line 838: 
line 839: function! s:checkout(spec)
line 848: 
line 849: function! s:finish(pull)
line 872: 
line 873: function! s:retry()
line 881: 
line 882: function! s:is_managed(name)
line 885: 
line 886: function! s:names(...)
line 889: 
line 890: function! s:check_ruby()
line 900: 
line 901: function! s:update_impl(pull, force, args) abort
line 1004: 
line 1005: function! s:log4(name, msg)
line 1009: 
line 1010: function! s:update_finish()
line 1065: 
line 1066: function! s:job_abort()
line 1079: 
line 1080: " When a:event == 'stdout', data = list of strings
line 1081: " When a:event == 'exit', data = returncode
line 1082: function! s:job_handler(job_id, data, event) abort
line 1109: 
line 1110: function! s:spawn(name, cmd, opts)
line 1137: 
line 1138: function! s:reap(name)
line 1152: 
line 1153: function! s:bar()
line 1162: 
line 1163: function! s:logpos(name)
line 1170: 
line 1171: function! s:log(bullet, name, lines)
line 1186: 
line 1187: function! s:update_vim()
line 1193: 
line 1194: function! s:tick()
line 1243: 
line 1244: function! s:update_python()
line 1630: 
line 1631: function! s:update_ruby()
line 1845: 
line 1846: function! s:shellesc(arg)
line 1849: 
line 1850: function! s:glob_dir(path)
line 1853: 
line 1854: function! s:progress_bar(line, bar, total)
line 1857: 
line 1858: function! s:compare_git_uri(a, b)
line 1863: 
line 1864: function! s:format_message(bullet, name, message)
line 1872: 
line 1873: function! s:with_cd(cmd, dir)
line 1876: 
line 1877: function! s:system(cmd, ...)
line 1886: 
line 1887: function! s:system_chomp(...)
line 1891: 
line 1892: function! s:git_validate(spec, check_branch)
line 1940: 
line 1941: function! s:rm_rf(dir)
line 1946: 
line 1947: function! s:clean(force)
line 2017: 
line 2018: function! s:delete_op(type, ...)
line 2021: 
line 2022: function! s:delete(range, force)
line 2044: 
line 2045: function! s:upgrade()
line 2071: 
line 2072: function! s:upgrade_specs()
line 2077: 
line 2078: function! s:status()
line 2122: 
line 2123: function! s:extract_name(str, prefix, suffix)
line 2126: 
line 2127: function! s:status_load(lnum)
line 2137: 
line 2138: function! s:status_update() range
line 2146: 
line 2147: function! s:is_preview_window_open()
line 2154: 
line 2155: function! s:find_name(lnum)
line 2168: 
line 2169: function! s:preview_commit()
line 2197: 
line 2198: function! s:section(flags)
line 2201: 
line 2202: function! s:format_git_log(line)
line 2213: 
line 2214: function! s:append_ul(lnum, text)
line 2217: 
line 2218: function! s:diff()
line 2262: 
line 2263: function! s:revert()
line 2280: 
line 2281: function! s:snapshot(force, ...) abort
line 2312: 
line 2313: function! s:split_rtp()
line 2316: 
line 2317: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
calling function <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
function <SNR>4_split_rtp returning ['/home/ringu/.vim', '/usr/share/vim/v...files/after', '/home/ringu/.vim/after']

continuing in /home/ringu/.vim/autoload/plug.vim

calling function <SNR>4_escrtp('/home/ringu/.vim')

line 1:   return escape(a:path, ' ,')
function <SNR>4_escrtp returning '/home/ringu/.vim'

continuing in /home/ringu/.vim/autoload/plug.vim

line 2318: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
calling function <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
function <SNR>4_split_rtp returning ['/home/ringu/.vim', '/usr/share/vim/v...files/after', '/home/ringu/.vim/after']

continuing in /home/ringu/.vim/autoload/plug.vim

calling function <SNR>4_escrtp('/home/ringu/.vim/after')

line 1:   return escape(a:path, ' ,')
function <SNR>4_escrtp returning '/home/ringu/.vim/after'

continuing in /home/ringu/.vim/autoload/plug.vim

line 2319: 
line 2320: if exists('g:plugs')
line 2321:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
line 2322:   call s:upgrade_specs()
line 2323:   call s:define_commands()
line 2324: endif
line 2325: 
line 2326: let &cpo = s:cpo_save
line 2327: unlet s:cpo_save
finished sourcing /home/ringu/.vim/autoload/plug.vim
continuing in /home/ringu/.vimrc
calling function plug#begin()

line 1:   if a:0 > 0
line 2:     let s:plug_home_org = a:1
line 3:     let home = s:path(fnamemodify(expand(a:1), ':p'))
line 4:   elseif exists('g:plug_home')
line 5:     let home = s:path(g:plug_home)
line 6:   elseif !empty(&rtp)
line 7:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'
calling function plug#begin[7]..<SNR>4_path('/home/ringu/.vim')

line 1:     return s:trim(a:path)
calling function plug#begin[7]..<SNR>4_path[1]..<SNR>4_trim('/home/ringu/.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#begin[7]..<SNR>4_path[1]..<SNR>4_trim returning '/home/ringu/.vim'

continuing in function plug#begin[7]..<SNR>4_path

function plug#begin[7]..<SNR>4_path returning '/home/ringu/.vim'

continuing in function plug#begin

line 8:   else
line 9:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
line 10:   endif
line 11: 
line 12:   let g:plug_home = home
line 13:   let g:plugs = {}
line 14:   let g:plugs_order = []
line 15:   let s:triggers = {}
line 16: 
line 17:   call s:define_commands()
calling function plug#begin[17]..<SNR>4_define_commands()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)
line 2:   if !executable('git')
line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
line 4:   endif
line 5:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
line 6:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
line 7:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
line 8:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
line 9:   command! -nargs=0 -bar PlugStatus  call s:status()
line 10:   command! -nargs=0 -bar PlugDiff    call s:diff()
line 11:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
function plug#begin[17]..<SNR>4_define_commands returning #0

continuing in function plug#begin

line 18:   return 1
function plug#begin returning #1

continuing in /home/ringu/.vimrc

line 2: 
line 3: Plug 'itchyny/lightline.vim'
line 3: call plug#('itchyny/lightline.vim')
calling function plug#('itchyny/lightline.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('itchyny/lightline.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'itchyny/lightline.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('lightline.vim', 'itchyny/lightline.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('itchyny/lightline.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/lightline.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/itch...ome/ringu/.vim/plugged/lightline.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 4: Plug 'tpope/vim-surround'
line 4: call plug#('tpope/vim-surround')
calling function plug#('tpope/vim-surround')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('tpope/vim-surround')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'tpope/vim-surround'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-surround', 'tpope/vim-surround')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('tpope/vim-surround')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-surround/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/tpop...home/ringu/.vim/plugged/vim-surround/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 5: Plug 'jiangmiao/auto-pairs'
line 5: call plug#('jiangmiao/auto-pairs')
calling function plug#('jiangmiao/auto-pairs')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('jiangmiao/auto-pairs')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'jiangmiao/auto-pairs'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('auto-pairs', 'jiangmiao/auto-pairs')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('jiangmiao/auto-pairs')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/auto-pairs/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/jian...'/home/ringu/.vim/plugged/auto-pairs/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 6: Plug 'w0rp/ale'
line 6: call plug#('w0rp/ale')
calling function plug#('w0rp/ale')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('w0rp/ale')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'w0rp/ale'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('ale', 'w0rp/ale')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('w0rp/ale')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/ale/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/w0rp...'dir': '/home/ringu/.vim/plugged/ale/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 7: Plug 'scrooloose/nerdtree'
line 7: call plug#('scrooloose/nerdtree')
calling function plug#('scrooloose/nerdtree')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('scrooloose/nerdtree')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'scrooloose/nerdtree'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('nerdtree', 'scrooloose/nerdtree')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('scrooloose/nerdtree')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/nerdtree/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/scro...: '/home/ringu/.vim/plugged/nerdtree/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 8: Plug 'mattn/emmet-vim'
line 8: call plug#('mattn/emmet-vim')
calling function plug#('mattn/emmet-vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('mattn/emmet-vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'mattn/emmet-vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('emmet-vim', 'mattn/emmet-vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('mattn/emmet-vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/emmet-vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/matt... '/home/ringu/.vim/plugged/emmet-vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 9: Plug 'ryanoasis/vim-devicons'
line 9: call plug#('ryanoasis/vim-devicons')
calling function plug#('ryanoasis/vim-devicons')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('ryanoasis/vim-devicons')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'ryanoasis/vim-devicons'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-devicons', 'ryanoasis/vim-devicons')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('ryanoasis/vim-devicons')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-devicons/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/ryan...home/ringu/.vim/plugged/vim-devicons/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 10: Plug 'junegunn/fzf.vim'
line 10: call plug#('junegunn/fzf.vim')
calling function plug#('junegunn/fzf.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('junegunn/fzf.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'junegunn/fzf.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('fzf.vim', 'junegunn/fzf.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('junegunn/fzf.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fzf.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/june...': '/home/ringu/.vim/plugged/fzf.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 11: Plug 'fugitive.vim'
line 11: call plug#('fugitive.vim')
calling function plug#('fugitive.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('fugitive.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'fugitive.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('fugitive.vim', 'fugitive.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('fugitive.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fugitive.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/vim-...home/ringu/.vim/plugged/fugitive.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 12: Plug 'airblade/vim-gitgutter'
line 12: call plug#('airblade/vim-gitgutter')
calling function plug#('airblade/vim-gitgutter')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('airblade/vim-gitgutter')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'airblade/vim-gitgutter'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-gitgutter', 'airblade/vim-gitgutter')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('airblade/vim-gitgutter')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-gitgutter/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/airb...ome/ringu/.vim/plugged/vim-gitgutter/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 13: Plug 'Yggdroot/indentLine'
line 13: call plug#('Yggdroot/indentLine')
calling function plug#('Yggdroot/indentLine')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('Yggdroot/indentLine')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'Yggdroot/indentLine'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('indentLine', 'Yggdroot/indentLine')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('Yggdroot/indentLine')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/indentLine/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/Yggd...'/home/ringu/.vim/plugged/indentLine/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 14: Plug 'prabirshrestha/asyncomplete.vim'
line 14: call plug#('prabirshrestha/asyncomplete.vim')
calling function plug#('prabirshrestha/asyncomplete.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/asyncomplete.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/asyncomplete.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('asyncomplete.vim', 'prabirshrestha/asyncomplete.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/asyncomplete.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab.../ringu/.vim/plugged/asyncomplete.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 15: Plug 'prabirshrestha/async.vim'
line 15: call plug#('prabirshrestha/async.vim')
calling function plug#('prabirshrestha/async.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/async.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/async.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('async.vim', 'prabirshrestha/async.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/async.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/async.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab... '/home/ringu/.vim/plugged/async.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 16: Plug 'prabirshrestha/vim-lsp'
line 16: call plug#('prabirshrestha/vim-lsp')
calling function plug#('prabirshrestha/vim-lsp')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/vim-lsp')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/vim-lsp'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-lsp', 'prabirshrestha/vim-lsp')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/vim-lsp')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-lsp/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab...': '/home/ringu/.vim/plugged/vim-lsp/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 17: Plug 'prabirshrestha/asyncomplete-lsp.vim'
line 17: call plug#('prabirshrestha/asyncomplete-lsp.vim')
calling function plug#('prabirshrestha/asyncomplete-lsp.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/asyncomplete-lsp.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/asyncomplete-lsp.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('asyncomplete-lsp.vim', 'prabirshrestha/asyncomplete-lsp.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/asyncomplete-lsp.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete-lsp.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab...gu/.vim/plugged/asyncomplete-lsp.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 18: 
line 19: call plug#end()
calling function plug#end()

line 1:   if !exists('g:plugs')
line 2:     return s:err('Call plug#begin() first')
line 3:   endif
line 4: 
line 5:   if exists('#PlugLOD')
line 6:     augroup PlugLOD
line 7:       autocmd!
line 8:     augroup END
line 9:     augroup! PlugLOD
line 10:   endif
line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
line 12: 
line 13:   filetype off
Searching for "ftoff.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim81/ftoff.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
Error detected while processing /usr/share/vim/vim81/ftoff.vim:
line   11:
E216: No such group or event: filetypedetect *
finished sourcing /usr/share/vim/vim81/ftoff.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/home/ringu/.vim/after/ftoff.vim"
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 22:     endif
line 23: 
line 24:     if has_key(plug, 'on')
line 25:       let s:triggers[name] = { 'map': [], 'cmd': [] }
line 26:       for cmd in s:to_a(plug.on)
line 27:         if cmd =~? '^<Plug>.\+'
line 28:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
line 29:             call s:assoc(lod.map, cmd, name)
line 30:           endif
line 31:           call add(s:triggers[name].map, cmd)
line 32:         elseif cmd =~# '^[A-Z]'
line 33:           if exists(':'.cmd) != 2
line 34:             call s:assoc(lod.cmd, cmd, name)
line 35:           endif
line 36:           call add(s:triggers[name].cmd, cmd)
line 37:         else
line 38:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
line 40:         endif
line 41:       endfor
line 42:     endif
line 43: 
line 44:     if has_key(plug, 'for')
line 45:       let types = s:to_a(plug.for)
line 46:       if !empty(types)
line 47:         augroup filetypedetect
line 48:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
line 49:         augroup END
line 50:       endif
line 51:       for type in types
line 52:         call s:assoc(lod.ft, type, name)
line 53:       endfor
line 54:     endif
line 55:   endfor
line 56: 
line 57:   for [cmd, names] in items(lod.cmd)
line 58:     execute printf( 'command! -nargs=* -range -bang %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
line 61:   endfor
line 62: 
line 63:   for [map, names] in items(lod.map)
line 64:     for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
line 66:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), key_prefix)
line 69:     endfor
line 70:   endfor
line 71: 
line 72:   for [ft, names] in items(lod.ft)
line 73:     augroup PlugLOD
line 74:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
line 76:     augroup END
line 77:   endfor
line 78: 
line 79:   call s:reorg_rtp()
calling function plug#end[79]..<SNR>4_reorg_rtp()

line 1:   if !empty(s:first_rtp)
line 2:     execute 'set rtp-='.s:first_rtp
line 2: set rtp-=/home/ringu/.vim
line 3:     execute 'set rtp-='.s:last_rtp
line 3: set rtp-=/home/ringu/.vim/after
line 4:   endif
line 5: 
line 6:   " &rtp is modified from outside
line 7:   if exists('s:prtp') && s:prtp !=# &rtp
line 8:     call s:remove_rtp()
line 9:     unlet! s:middle
line 10:   endif
line 11: 
line 12:   let s:middle = get(s:, 'middle', &rtp)
line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_loaded_names()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_loaded_names returning ['lightline.vim', 'vim-surround', 'aut...im', 'vim-lsp', 'asyncomplete-lsp.vim']

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/itch...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/lightline.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/tpop...und/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-surround/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/jian...irs/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/auto-pairs/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/w0rp...ale/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/ale/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/scro...ree/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/nerdtree/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/matt...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/emmet-vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/ryan...ons/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-devicons/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/june...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fzf.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/vim-...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fugitive.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/airb...ter/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-gitgutter/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/Yggd...ine/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/indentLine/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/async.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...lsp/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-lsp/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete-lsp.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), 'isdirectory(v:val)')
line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
line 19:   let s:prtp   = &rtp
line 20: 
line 21:   if !empty(s:first_rtp)
line 22:     execute 'set rtp^='.s:first_rtp
line 22: set rtp^=/home/ringu/.vim
line 23:     execute 'set rtp+='.s:last_rtp
line 23: set rtp+=/home/ringu/.vim/after
line 24:   endif
function plug#end[79]..<SNR>4_reorg_rtp returning #0

continuing in function plug#end

line 80:   filetype plugin indent on
Searching for "filetype.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/filetype.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/filetype.vim"
Searching for "/home/ringu/.vim/plugged/ale/filetype.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/filetype.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2018 May 04
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.pacsave,?\+.pacnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Vim help file
line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 53: 
line 54: " Abaqus or Trasys
line 55: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 56: 
line 57: " A-A-P recipe
line 58: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 59: 
line 60: " A2ps printing utility
line 61: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 62: 
line 63: " ABAB/4
line 64: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 65: 
line 66: " ABC music notation
line 67: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 68: 
line 69: " ABEL
line 70: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 71: 
line 72: " AceDB
line 73: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 74: 
line 75: " Ada (83, 9X, 95)
line 76: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 77: if has("vms")
line 78:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 79: else
line 80:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 81: endif
line 82: 
line 83: " AHDL
line 84: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 85: 
line 86: " AMPL
line 87: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 88: 
line 89: " Ant
line 90: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 91: 
line 92: " Arduino
line 93: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 94: 
line 95: " Apache style config file
line 96: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 97: 
line 98: " Apache config file
line 99: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 100: 
line 101: " XA65 MOS6510 cross assembler
line 102: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 103: 
line 104: " Applescript
line 105: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 106: 
line 107: " Applix ELF
line 109: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 110: 
line 111: " ALSA configuration
line 112: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 113: 
line 114: " Arc Macro Language
line 115: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 116: 
line 117: " APT config file
line 118: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 119: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 120: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 121: 
line 122: " Arch Inventory file
line 123: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 124: 
line 125: " ART*Enterprise (formerly ART-IM)
line 126: au BufNewFile,BufRead *.art^I^I^Isetf art
line 127: 
line 128: " AsciiDoc
line 129: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 130: 
line 131: " ASN.1
line 132: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 133: 
line 134: " Active Server Pages (with Visual Basic Script)
line 140: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 141: 
line 142: " Active Server Pages (with Perl or Visual Basic Script)
line 150: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 151: 
line 152: " Grub (must be before catch *.lst)
line 153: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 154: 
line 155: " Assembly (all kinds)
line 156: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 157: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 158: 
line 159: " Macro (VAX)
line 160: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 161: 
line 162: " Atlas
line 163: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 164: 
line 165: " Autoit v3
line 166: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 167: 
line 168: " Autohotkey
line 169: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 170: 
line 171: " Automake
line 172: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 173: 
line 174: " Autotest .at files are actually m4
line 175: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 176: 
line 177: " Avenue
line 178: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 179: 
line 180: " Awk
line 181: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 182: 
line 183: " B
line 184: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 185: 
line 186: " BASIC or Visual Basic
line 187: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
line 188: 
line 189: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 190: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 191: 
line 192: " IBasic file (similar to QBasic)
line 193: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 194: 
line 195: " FreeBasic file (similar to QBasic)
line 196: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 197: 
line 198: " Batch file for MSDOS.
line 199: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 200: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 202: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 203: 
line 204: " Batch file for 4DOS
line 205: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 206: 
line 207: " BC calculator
line 208: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 209: 
line 210: " BDF font
line 211: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 212: 
line 213: " BibTeX bibliography database file
line 214: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 215: 
line 216: " BibTeX Bibliography Style
line 217: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 218: 
line 219: " BIND configuration
line 220: " sudoedit uses namedXXXX.conf
line 221: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 222: 
line 223: " BIND zone
line 224: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 225: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 226: 
line 227: " Blank
line 228: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 229: 
line 230: " Blkid cache file
line 231: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 232: 
line 233: " Bazel (http://bazel.io)
line 234: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
line 235: if has("fname_case")
line 236:   " There is another check for BUILD further below.
line 237:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
line 238: endif
line 239: 
line 240: " C or lpc
line 241: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 242: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 243: 
line 244: " Calendar
line 245: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 246: 
line 247: " C#
line 248: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 249: 
line 250: " CSDL
line 251: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 252: 
line 253: " Cabal
line 254: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 255: 
line 256: " Cdrdao TOC
line 257: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 258: 
line 259: " Cdrdao config
line 260: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 261: 
line 262: " Cfengine
line 263: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 264: 
line 265: " ChaiScript
line 266: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 267: 
line 268: " Comshare Dimension Definition Language
line 269: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 270: 
line 271: " Conary Recipe
line 272: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 273: 
line 274: " Controllable Regex Mutilator
line 275: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 276: 
line 277: " Cyn++
line 278: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 279: 
line 280: " Cynlib
line 281: " .cc and .cpp files can be C++ or Cynlib.
line 283: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 285: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 286: 
line 287: " C++
line 288: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 289: if has("fname_case")
line 290:   au BufNewFile,BufRead *.C,*.H setf cpp
line 291: endif
line 292: 
line 293: " .h files can be C, Ch C++, ObjC or ObjC++.
line 294: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 295: " detected automatically.
line 296: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 297: 
line 298: " Ch (CHscript)
line 299: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 300: 
line 301: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 302: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 303: 
line 304: " Cascading Style Sheets
line 305: au BufNewFile,BufRead *.css^I^I^Isetf css
line 306: 
line 307: " Century Term Command Scripts (*.cmd too)
line 308: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 309: 
line 310: " Changelog
line 312: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 313: 
line 319: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 320: 
line 324: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 325: 
line 326: " CHILL
line 327: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 328: 
line 329: " Changes for WEB and CWEB or CHILL
line 330: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 331: 
line 332: " ChordPro
line 333: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 334: 
line 335: " Clean
line 336: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 337: 
line 338: " Clever
line 339: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 340: 
line 341: " Clever or dtd
line 342: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 343: 
line 344: " Clipper (or FoxPro; could also be eviews)
line 350: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 351: 
line 352: " Clojure
line 353: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 354: 
line 355: " Cmake
line 356: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 357: 
line 358: " Cmusrc
line 359: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 360: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 361: 
line 362: " Cobol
line 363: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 364: "   cobol or zope form controller python script? (heuristic)
line 370: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 371: 
line 372: " Coco/R
line 373: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 374: 
line 375: " Cold Fusion
line 376: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 377: 
line 378: " Configure scripts
line 379: au BufNewFile,BufRead configure.in,configure.ac setf config
line 380: 
line 381: " CUDA  Cumpute Unified Device Architecture
line 382: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 383: 
line 384: " Dockerfile
line 385: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 386: 
line 387: " WildPackets EtherPeek Decoder
line 388: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 389: 
line 390: " Enlightenment configuration files
line 391: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 392: 
line 393: " Eterm
line 394: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 395: 
line 396: " Euphoria 3 or 4
line 397: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 398: if has("fname_case")
line 399:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 400: endif
line 401: 
line 402: " Lynx config files
line 403: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 404: 
line 405: " Quake
line 406: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 407: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 408: 
line 409: " Quake C
line 410: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 411: 
line 412: " Configure files
line 413: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 414: 
line 415: " Cucumber
line 416: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 417: 
line 418: " Communicating Sequential Processes
line 419: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 420: 
line 421: " CUPL logic description and simulation
line 422: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 423: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 424: 
line 425: " Debian Control
line 426: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 430: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 431: 
line 432: " Debian Copyright
line 433: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 437: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 438: 
line 439: " Debian Sources.list
line 440: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 441: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 442: 
line 443: " Deny hosts
line 444: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 445: 
line 446: " dnsmasq(8) configuration files
line 447: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 448: 
line 449: " ROCKLinux package description
line 450: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 451: 
line 452: " the D language or dtrace
line 453: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 454: 
line 455: " Desktop files
line 456: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 457: 
line 458: " Dict config
line 459: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 460: 
line 461: " Dictd config
line 462: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 463: 
line 464: " Diff files
line 465: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 471: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 472: 
line 473: " Dircolors
line 474: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 475: 
line 476: " Diva (with Skill) or InstallShield
line 482: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 483: 
line 484: " DCL (Digital Command Language - vms) or DNS zone file
line 485: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 486: 
line 487: " DOT
line 488: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 489: 
line 490: " Dylan - lid files
line 491: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 492: 
line 493: " Dylan - intr files (melange)
line 494: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 495: 
line 496: " Dylan
line 497: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 498: 
line 499: " Microsoft Module Definition
line 500: au BufNewFile,BufRead *.def^I^I^Isetf def
line 501: 
line 502: " Dracula
line 503: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 504: 
line 505: " Datascript
line 506: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 507: 
line 508: " dsl
line 509: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 510: 
line 511: " DTD (Document Type Definition for XML)
line 512: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 513: 
line 514: " DTS/DSTI (device tree files)
line 515: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 516: 
line 517: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 518: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 524: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 525: 
line 526: " EditorConfig (close enough to dosini)
line 527: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 528: 
line 529: " Embedix Component Description
line 530: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 531: 
line 532: " Eiffel or Specman or Euphoria
line 533: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 534: 
line 535: " Elinks configuration
line 536: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 537: 
line 538: " ERicsson LANGuage; Yaws is erlang too
line 539: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 540: 
line 541: " Elm Filter Rules file
line 542: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 543: 
line 544: " ESMTP rc file
line 545: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 546: 
line 547: " ESQL-C
line 548: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 549: 
line 550: " Esterel
line 551: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 552: 
line 553: " Essbase script
line 554: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 555: 
line 556: " Exim
line 557: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 558: 
line 559: " Expect
line 560: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 561: 
line 562: " Exports
line 563: au BufNewFile,BufRead exports^I^I^Isetf exports
line 564: 
line 565: " Falcon
line 566: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 567: 
line 568: " Fantom
line 569: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 570: 
line 571: " Factor
line 572: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 573: 
line 574: " Fetchmail RC file
line 575: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 576: 
line 577: " FlexWiki - disabled, because it has side effects when a .wiki file
line 578: " is not actually FlexWiki
line 579: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 580: 
line 581: " Focus Executable
line 582: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 583: 
line 584: " Focus Master file (but not for auto.master)
line 585: au BufNewFile,BufRead auto.master^I^Isetf conf
line 586: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 587: 
line 588: " Forth
line 589: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
line 590: 
line 591: " Reva Forth
line 592: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 593: 
line 594: " Fortran
line 595: if has("fname_case")
line 596:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 597: endif
line 598: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 599: 
line 600: " Framescript
line 601: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 602: 
line 603: " FStab
line 604: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 605: 
line 606: " GDB command files
line 607: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 608: 
line 609: " GDMO
line 610: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 611: 
line 612: " Gedcom
line 613: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 614: 
line 615: " Git
line 616: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
line 617: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
line 618: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 619: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 620: if !empty($XDG_CONFIG_HOME)
line 621:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 622: endif
line 623: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 624: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 628: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 632: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 633: 
line 634: " Gkrellmrc
line 635: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 636: 
line 637: " GP scripts (2.0 and onward)
line 638: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 639: 
line 640: " GPG
line 641: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 642: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 643: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 644: if !empty($GNUPGHOME)
line 645:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 646:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 647: endif
line 648: 
line 649: " gnash(1) configuration files
line 650: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 651: 
line 652: " Gitolite
line 653: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 654: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 655: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 656: 
line 657: " Gnuplot scripts
line 658: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 659: 
line 660: " Go (Google)
line 661: au BufNewFile,BufRead *.go^I^I^Isetf go
line 662: 
line 663: " GrADS scripts
line 664: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 665: 
line 666: " Gretl
line 667: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 668: 
line 669: " Groovy
line 670: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 671: 
line 672: " GNU Server Pages
line 673: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 674: 
line 675: " Group file
line 676: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 677: 
line 678: " GTK RC
line 679: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 680: 
line 681: " Haml
line 682: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 683: 
line 684: " Hamster Classic | Playground files
line 685: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 686: 
line 687: " Haskell
line 688: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 689: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 690: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 691: 
line 692: " Haste
line 693: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 694: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 695: 
line 696: " Hercules
line 697: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 698: 
line 699: " HEX (Intel)
line 700: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 701: 
line 702: " Tilde (must be before HTML)
line 703: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 704: 
line 705: " HTML (.shtml and .stm for server side)
line 706: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 707: 
line 708: " HTML with Ruby - eRuby
line 709: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 710: 
line 711: " HTML with M4
line 712: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 713: 
line 714: " HTML Cheetah template
line 715: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 716: 
line 717: " Host config
line 718: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 719: 
line 720: " Hosts access
line 721: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 722: 
line 723: " Hyper Builder
line 724: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 725: 
line 726: " Httest
line 727: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 728: 
line 729: " Icon
line 730: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 731: 
line 732: " IDL (Interface Description Language)
line 733: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 734: 
line 735: " Microsoft IDL (Interface Description Language)  Also *.idl
line 736: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 737: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 738: 
line 739: " Icewm menu
line 740: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 741: 
line 742: " Indent profile (must come before IDL *.pro!)
line 743: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 744: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 745: 
line 746: " IDL (Interactive Data Language)
line 747: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 748: 
line 749: " Indent RC
line 750: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 751: 
line 752: " Inform
line 753: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 754: 
line 755: " Initng
line 756: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 757: 
line 758: " Innovation Data Processing
line 759: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 760: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 761: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 762: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 763: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 764: 
line 765: " Ipfilter
line 766: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 767: 
line 768: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 769: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 770: 
line 771: " .INI file for MSDOS
line 772: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 773: 
line 774: " SysV Inittab
line 775: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 776: 
line 777: " Inno Setup
line 778: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 779: 
line 780: " J
line 781: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 782: 
line 783: " JAL
line 784: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 785: 
line 786: " Jam
line 787: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 788: 
line 789: " Java
line 790: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 791: 
line 792: " JavaCC
line 793: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 794: 
line 795: " JavaScript, ECMAScript
line 796: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 797: 
line 798: " Java Server Pages
line 799: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 800: 
line 801: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 802: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 803: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 804: 
line 805: " Jess
line 806: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 807: 
line 808: " Jgraph
line 809: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 810: 
line 811: " Jovial
line 812: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 813: 
line 814: " JSON
line 815: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 816: 
line 817: " Kixtart
line 818: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 819: 
line 820: " Kimwitu[++]
line 821: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 822: 
line 823: " Kivy
line 824: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 825: 
line 826: " KDE script
line 827: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 828: 
line 829: " Kconfig
line 830: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 831: 
line 832: " Lace (ISE)
line 833: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 834: 
line 835: " Latte
line 836: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 837: 
line 838: " Limits
line 839: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 840: 
line 841: " LambdaProlog (*.mod too, see Modsim)
line 842: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 843: 
line 844: " LDAP LDIF
line 845: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 846: 
line 847: " Ld loader
line 848: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 849: 
line 850: " Less
line 851: au BufNewFile,BufRead *.less^I^I^Isetf less
line 852: 
line 853: " Lex
line 854: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 855: 
line 856: " Libao
line 857: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 858: 
line 859: " Libsensors
line 860: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 861: 
line 862: " LFTP
line 863: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 864: 
line 865: " Lifelines (or Lex for C++!)
line 866: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 867: 
line 868: " Lilo: Linux loader
line 869: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 870: 
line 871: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 872: if has("fname_case")
line 873:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 874: else
line 875:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 876: endif
line 877: 
line 878: " SBCL implementation of Common Lisp
line 879: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 880: 
line 881: " Liquid
line 882: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 883: 
line 884: " Lite
line 885: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 886: 
line 887: " LiteStep RC files
line 888: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 889: 
line 890: " Login access
line 891: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 892: 
line 893: " Login defs
line 894: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 895: 
line 896: " Logtalk
line 897: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 898: 
line 899: " LOTOS
line 900: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 901: 
line 902: " Lout (also: *.lt)
line 903: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 904: 
line 905: " Lua
line 906: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 907: 
line 908: " Luarocks
line 909: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 910: 
line 911: " Linden Scripting Language (Second Life)
line 912: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 913: 
line 914: " Lynx style file (or LotusScript!)
line 915: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 916: 
line 917: " M4
line 919: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 920: 
line 921: " MaGic Point
line 922: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 923: 
line 924: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 925: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 926: 
line 927: " Mail aliases
line 928: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 929: 
line 930: " Mailcap configuration file
line 931: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 932: 
line 933: " Makefile
line 934: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 935: 
line 936: " MakeIndex
line 937: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 938: 
line 939: " Mallard
line 940: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 941: 
line 942: " Manpage
line 943: au BufNewFile,BufRead *.man^I^I^Isetf man
line 944: 
line 945: " Man config
line 946: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 947: 
line 948: " Maple V
line 949: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 950: 
line 951: " Map (UMN mapserver config file)
line 952: au BufNewFile,BufRead *.map^I^I^Isetf map
line 953: 
line 954: " Markdown
line 955: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 956: 
line 957: " Mason
line 958: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 959: 
line 960: " Mathematica, Matlab, Murphi or Objective C
line 961: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 962: 
line 963: " Mathematica notebook
line 964: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 965: 
line 966: " Maya Extension Language
line 967: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 968: 
line 969: " Mercurial (hg) commit file
line 970: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 971: 
line 972: " Mercurial config (looks like generic config file)
line 973: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 974: 
line 975: " Messages (logs mostly)
line 976: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 977: 
line 978: " Metafont
line 979: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 980: 
line 981: " MetaPost
line 982: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 983: 
line 984: " MGL
line 985: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 986: 
line 987: " MIX - Knuth assembly
line 988: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 989: 
line 990: " MMIX or VMS makefile
line 991: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 992: 
line 993: " Symbian meta-makefile definition (MMP)
line 994: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 995: 
line 996: " Modsim III (or LambdaProlog)
line 1002: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1003: 
line 1004: " Modula 2  (.md removed in favor of Markdown)
line 1005: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1006: 
line 1007: " Modula 3 (.m3, .i3, .mg, .ig)
line 1008: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1009: 
line 1010: " Monk
line 1011: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1012: 
line 1013: " MOO
line 1014: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1015: 
line 1016: " Modconf
line 1017: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1018: 
line 1019: " Mplayer config
line 1020: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1021: 
line 1022: " Motorola S record
line 1023: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1024: 
line 1025: " Mrxvtrc
line 1026: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1027: 
line 1028: " Msql
line 1029: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1030: 
line 1031: " Mysql
line 1032: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1033: 
line 1034: " Mutt setup files (must be before catch *.rc)
line 1035: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1036: 
line 1037: " M$ Resource files
line 1038: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1039: 
line 1040: " MuPAD source
line 1041: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1042: 
line 1043: " Mush
line 1044: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1045: 
line 1046: " Mutt setup file (also for Muttng)
line 1047: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1048: 
line 1049: " N1QL
line 1050: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1051: 
line 1052: " Nano
line 1053: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1054: 
line 1055: " Nastran input/DMAP
line 1056: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1057: 
line 1058: " Natural
line 1059: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1060: 
line 1061: " Noemutt setup file
line 1062: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1063: 
line 1064: " Netrc
line 1065: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1066: 
line 1067: " Ninja file
line 1068: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1069: 
line 1070: " Novell netware batch files
line 1071: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1072: 
line 1073: " Nroff/Troff (*.ms and *.t are checked below)
line 1077: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1078: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1079: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1080: 
line 1081: " Nroff or Objective C++
line 1082: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1083: 
line 1084: " Not Quite C
line 1085: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1086: 
line 1087: " NSE - Nmap Script Engine - uses Lua syntax
line 1088: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1089: 
line 1090: " NSIS
line 1091: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1092: 
line 1093: " OCAML
line 1094: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1095: 
line 1096: " Occam
line 1097: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1098: 
line 1099: " Omnimark
line 1100: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1101: 
line 1102: " OpenROAD
line 1103: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1104: 
line 1105: " OPL
line 1106: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1107: 
line 1108: " Oracle config file
line 1109: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1110: 
line 1111: " Packet filter conf
line 1112: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1113: 
line 1114: " Pam conf
line 1115: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1116: 
line 1117: " PApp
line 1118: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1119: 
line 1120: " Password file
line 1121: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1122: 
line 1123: " Pascal (also *.p)
line 1124: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1125: 
line 1126: " Delphi project file
line 1127: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1128: 
line 1129: " PDF
line 1130: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1131: 
line 1132: " PCMK - HAE - crm configure edit
line 1133: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
line 1134: 
line 1135: " Perl
line 1136: if has("fname_case")
line 1137:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
line 1138: else
line 1139:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
line 1140: endif
line 1141: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1142: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1143: 
line 1144: " Perl, XPM or XPM2
line 1152: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1153: 
line 1154: " Perl POD
line 1155: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1156: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1157: 
line 1158: " Php, php3, php4, etc.
line 1159: " Also Phtml (was used for PHP 2 in the past)
line 1160: " Also .ctp for Cake template file
line 1161: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1162: 
line 1163: " Pike and Cmod
line 1164: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1165: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1166: 
line 1167: " Pinfo config
line 1168: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1169: 
line 1170: " Palm Resource compiler
line 1171: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1172: 
line 1173: " Pine config
line 1174: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1175: 
line 1176: " PL/1, PL/I
line 1177: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1178: 
line 1179: " PL/M (also: *.inp)
line 1180: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1181: 
line 1182: " PL/SQL
line 1183: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1184: 
line 1185: " PLP
line 1186: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1187: 
line 1188: " PO and PO template (GNU gettext)
line 1189: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1190: 
line 1191: " Postfix main config
line 1192: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1193: 
line 1194: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1195: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1196: 
line 1197: " PostScript Printer Description
line 1198: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1199: 
line 1200: " Povray
line 1201: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1202: 
line 1203: " Povray configuration
line 1204: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1205: 
line 1206: " Povray, PHP or assembly
line 1207: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1208: 
line 1209: " Printcap and Termcap
line 1211: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1213: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1214: 
line 1215: " PCCTS / ANTRL
line 1216: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1217: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1218: 
line 1219: " PPWizard
line 1220: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1221: 
line 1222: " Obj 3D file format
line 1223: " TODO: is there a way to avoid MS-Windows Object files?
line 1224: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1225: 
line 1226: " Oracle Pro*C/C++
line 1227: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1228: 
line 1229: " Privoxy actions file
line 1230: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1231: 
line 1232: " Procmail
line 1233: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1234: 
line 1235: " Progress or CWEB
line 1236: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1237: 
line 1238: " Progress or assembly
line 1239: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
line 1240: 
line 1241: " Progress or Pascal
line 1242: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1243: 
line 1244: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1245: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1249: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1250: 
line 1251: " Prolog
line 1252: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1253: 
line 1254: " Promela
line 1255: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1256: 
line 1257: " Google protocol buffers
line 1258: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1259: 
line 1260: " Protocols
line 1261: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1262: 
line 1263: " Pyrex
line 1264: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1265: 
line 1266: " Python, Python Shell Startup and Python Stub Files
line 1267: " Quixote (Python-based web framework)
line 1268: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
line 1269: 
line 1270: " Radiance
line 1271: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1272: 
line 1273: " Ratpoison config/command files
line 1274: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1275: 
line 1276: " RCS file
line 1277: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1278: 
line 1279: " Readline
line 1280: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1281: 
line 1282: " Registry for MS-Windows
line 1284: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1285: 
line 1286: " Renderman Interface Bytestream
line 1287: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1288: 
line 1289: " Rexx
line 1290: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1291: 
line 1292: " R (Splus)
line 1293: if has("fname_case")
line 1294:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1295: else
line 1296:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1297: endif
line 1298: 
line 1299: " R Help file
line 1300: if has("fname_case")
line 1301:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1302: else
line 1303:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1304: endif
line 1305: 
line 1306: " R noweb file
line 1307: if has("fname_case")
line 1308:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1309: else
line 1310:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1311: endif
line 1312: 
line 1313: " R Markdown file
line 1314: if has("fname_case")
line 1315:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1316: else
line 1317:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1318: endif
line 1319: 
line 1320: " R reStructuredText file
line 1321: if has("fname_case")
line 1322:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1323: else
line 1324:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1325: endif
line 1326: 
line 1327: " Rexx, Rebol or R
line 1328: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1329: 
line 1330: " Remind
line 1331: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1332: 
line 1333: " Resolv.conf
line 1334: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1335: 
line 1336: " Relax NG Compact
line 1337: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1338: 
line 1339: " Relax NG XML
line 1340: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1341: 
line 1342: " RPL/2
line 1343: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1344: 
line 1345: " Robots.txt
line 1346: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1347: 
line 1348: " Rpcgen
line 1349: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1350: 
line 1351: " reStructuredText Documentation Format
line 1352: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1353: 
line 1354: " RTF
line 1355: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1356: 
line 1357: " Interactive Ruby shell
line 1358: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1359: 
line 1360: " Ruby
line 1361: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1362: 
line 1363: " RubyGems
line 1364: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1365: 
line 1366: " Rust
line 1367: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1368: 
line 1369: " Rackup
line 1370: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1371: 
line 1372: " Bundler
line 1373: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1374: 
line 1375: " Ruby on Rails
line 1376: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1377: 
line 1378: " Rantfile and Rakefile is like Ruby
line 1379: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1380: 
line 1381: " S-lang (or shader language, or SmallLisp)
line 1382: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1383: 
line 1384: " Samba config
line 1385: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1386: 
line 1387: " SAS script
line 1388: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1389: 
line 1390: " Sass
line 1391: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1392: 
line 1393: " Sather
line 1394: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1395: 
line 1396: " Scala
line 1397: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1398: 
line 1399: " SBT - Scala Build Tool
line 1400: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1401: 
line 1402: " Scilab
line 1403: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1404: 
line 1405: " SCSS
line 1406: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1407: 
line 1408: " SD: Streaming Descriptors
line 1409: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1410: 
line 1411: " SDL
line 1412: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1413: 
line 1414: " sed
line 1415: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1416: 
line 1417: " Sieve (RFC 3028, 5228)
line 1418: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1419: 
line 1420: " Sendmail
line 1421: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1422: 
line 1423: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1424: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1425: 
line 1426: " Services
line 1427: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1428: 
line 1429: " Service Location config
line 1430: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1431: 
line 1432: " Service Location registration
line 1433: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1434: 
line 1435: " Service Location SPI
line 1436: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1437: 
line 1438: " Setserial config
line 1439: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1440: 
line 1441: " SGML
line 1451: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1452: 
line 1453: " SGMLDECL
line 1457: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1458: 
line 1459: " SGML catalog file
line 1460: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1461: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1462: 
line 1463: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1464: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1465: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,PKGBUILD*,*.install,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
line 1466: au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1467: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1468: 
line 1469: " Shell script (Arch Linux) or PHP file (Drupal)
line 1475: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 1476: 
line 1477: " tcsh scripts
line 1478: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 1479: 
line 1480: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1481: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 1482: 
line 1483: " Z-Shell script
line 1484: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1485: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1486: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1487: 
line 1488: " Scheme
line 1489: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1490: 
line 1491: " Screen RC
line 1492: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1493: 
line 1494: " Simula
line 1495: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1496: 
line 1497: " SINDA
line 1498: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1499: 
line 1500: " SiSU
line 1501: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1502: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1503: 
line 1504: " SKILL
line 1505: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1506: 
line 1507: " SLRN
line 1508: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1509: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1510: 
line 1511: " Smalltalk (and TeX)
line 1512: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1520: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1521: 
line 1522: " Smarty templates
line 1523: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1524: 
line 1525: " SMIL or XML
line 1531: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1532: 
line 1533: " SMIL or SNMP MIB file
line 1539: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1540: 
line 1541: " SMITH
line 1542: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1543: 
line 1544: " Snobol4 and spitbol
line 1545: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1546: 
line 1547: " SNMP MIB files
line 1548: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1549: 
line 1550: " Snort Configuration
line 1551: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1552: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 1553: 
line 1554: " Spec (Linux RPM)
line 1555: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1556: 
line 1557: " Speedup (AspenTech plant simulator)
line 1558: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1559: 
line 1560: " Slice
line 1561: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 1562: 
line 1563: " Spice
line 1564: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 1565: 
line 1566: " Spyce
line 1567: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 1568: 
line 1569: " Squid
line 1570: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 1571: 
line 1572: " SQL for Oracle Designer
line 1573: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 1574: 
line 1575: " SQL
line 1576: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 1577: 
line 1578: " SQLJ
line 1579: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 1580: 
line 1581: " SQR
line 1582: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 1583: 
line 1584: " OpenSSH configuration
line 1585: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 1586: 
line 1587: " OpenSSH server configuration
line 1588: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 1589: 
line 1590: " Stata
line 1591: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 1592: " Also *.class, but not when it's a Java bytecode file
line 1594: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 1595: 
line 1596: " SMCL
line 1597: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 1598: 
line 1599: " Stored Procedures
line 1600: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 1601: 
line 1602: " Standard ML
line 1603: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 1604: 
line 1605: " Sratus VOS command macro
line 1606: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 1607: 
line 1608: " Sysctl
line 1609: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 1610: 
line 1611: " Systemd unit files
line 1612: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 1613: 
line 1614: " Synopsys Design Constraints
line 1615: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 1616: 
line 1617: " Sudoers
line 1618: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 1619: 
line 1620: " SVG (Scalable Vector Graphics)
line 1621: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 1622: 
line 1623: " Tads (or Nroff or Perl test file)
line 1625: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 1626: 
line 1627: " Tags
line 1628: au BufNewFile,BufRead tags^I^I^Isetf tags
line 1629: 
line 1630: " TAK
line 1631: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 1632: 
line 1633: " Task
line 1634: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 1635: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 1636: 
line 1637: " Tcl (JACL too)
line 1638: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 1639: 
line 1640: " TealInfo
line 1641: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 1642: 
line 1643: " Telix Salt
line 1644: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 1645: 
line 1646: " Tera Term Language
line 1647: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 1648: 
line 1649: " Terminfo
line 1650: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 1651: 
line 1652: " TeX
line 1653: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 1654: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 1655: 
line 1656: " ConTeXt
line 1657: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 1658: 
line 1659: " Texinfo
line 1660: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 1661: 
line 1662: " TeX configuration
line 1663: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 1664: 
line 1665: " Tidy config
line 1666: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 1667: 
line 1668: " TF mud client
line 1669: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 1670: 
line 1671: " tmux configuration
line 1672: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 1673: 
line 1674: " TPP - Text Presentation Program
line 1675: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 1676: 
line 1677: " Treetop
line 1678: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 1679: 
line 1680: " Trustees
line 1681: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 1682: 
line 1683: " TSS - Geometry
line 1684: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 1685: 
line 1686: " TSS - Optics
line 1687: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 1688: 
line 1689: " TSS - Command Line (temporary)
line 1690: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 1691: 
line 1692: " TWIG files
line 1693: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 1694: 
line 1695: " Motif UIT/UIL files
line 1696: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 1697: 
line 1698: " Udev conf
line 1699: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 1700: 
line 1701: " Udev permissions
line 1702: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 1703: "
line 1704: " Udev symlinks config
line 1705: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 1706: 
line 1707: " UnrealScript
line 1708: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 1709: 
line 1710: " Updatedb
line 1711: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 1712: 
line 1713: " Upstart (init(8)) config files
line 1714: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 1715: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 1716: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 1717: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 1718: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 1719: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 1720: 
line 1721: " Vera
line 1722: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 1723: 
line 1724: " Verilog HDL
line 1725: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 1726: 
line 1727: " Verilog-AMS HDL
line 1728: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 1729: 
line 1730: " SystemVerilog
line 1731: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 1732: 
line 1733: " VHDL
line 1734: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 1735: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 1736: 
line 1737: " Vim script
line 1738: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 1739: 
line 1740: " Viminfo file
line 1741: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 1742: 
line 1743: " Virata Config Script File or Drupal module
line 1749: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 1750: 
line 1751: " Visual Basic (also uses *.bas) or FORM
line 1752: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
line 1753: 
line 1754: " SaxBasic is close to Visual Basic
line 1755: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 1756: 
line 1757: " Vgrindefs file
line 1758: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 1759: 
line 1760: " VRML V1.0c
line 1761: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 1762: 
line 1763: " Vroom (vim testing and executable documentation)
line 1764: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 1765: 
line 1766: " Webmacro
line 1767: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 1768: 
line 1769: " WebAssembly
line 1770: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
line 1771: 
line 1772: " Wget config
line 1773: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 1774: 
line 1775: " Website MetaLanguage
line 1776: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 1777: 
line 1778: " Winbatch
line 1779: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 1780: 
line 1781: " WSML
line 1782: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 1783: 
line 1784: " WPL
line 1785: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 1786: 
line 1787: " WvDial
line 1788: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 1789: 
line 1790: " CVS RC file
line 1791: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 1792: 
line 1793: " CVS commit file
line 1794: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 1795: 
line 1796: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 1797: " lines in a WEB file).
line 1803: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 1804: 
line 1805: " Windows Scripting Host and Windows Script Component
line 1806: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 1807: 
line 1808: " XHTML
line 1809: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 1810: 
line 1811: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 1817: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 1818: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 1819: 
line 1820: " XFree86 config
line 1825: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 1828: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1829: 
line 1830: " Xorg config
line 1831: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1832: 
line 1833: " Xinetd conf
line 1834: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 1835: 
line 1836: " XS Perl extension interface language
line 1837: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 1838: 
line 1839: " X resources file
line 1840: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 1841: 
line 1842: " Xmath
line 1843: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 1845: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 1846: 
line 1847: " XML  specific variants: docbk and xbl
line 1848: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 1849: 
line 1850: " XMI (holding UML models) is also XML
line 1851: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 1852: 
line 1853: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 1854: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 1855: 
line 1856: " Qt Linguist translation source and Qt User Interface Files are XML
line 1857: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 1858: 
line 1859: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 1860: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 1861: 
line 1862: " Xdg menus
line 1863: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 1864: 
line 1865: " ATI graphics driver configuration
line 1866: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 1867: 
line 1868: " Web Services Description Language (WSDL)
line 1869: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 1870: 
line 1871: " XLIFF (XML Localisation Interchange File Format) is also XML
line 1872: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 1873: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 1874: 
line 1875: " XML User Interface Language
line 1876: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 1877: 
line 1878: " X11 xmodmap (also see below)
line 1879: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 1880: 
line 1881: " Xquery
line 1882: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 1883: 
line 1884: " XSD
line 1885: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 1886: 
line 1887: " Xslt
line 1888: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 1889: 
line 1890: " Yacc
line 1891: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 1892: 
line 1893: " Yacc or racc
line 1894: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 1895: 
line 1896: " Yaml
line 1897: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 1898: 
line 1899: " Raml
line 1900: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 1901: 
line 1902: " yum conf (close enough to dosini)
line 1903: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 1904: 
line 1905: " Zimbu
line 1906: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 1907: " Zimbu Templates
line 1908: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 1909: 
line 1910: " Zope
line 1911: "   dtml (zope dynamic template markup language), pt (zope page template),
line 1912: "   cpt (zope form controller page template)
line 1913: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 1914: "   zsql (zope sql method)
line 1915: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 1916: 
line 1917: " Z80 assembler asz80
line 1918: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 1919: 
line 1920: augroup END
line 1921: 
line 1922: 
line 1923: " Source the user-specified filetype file, for backwards compatibility with
line 1924: " Vim 5.x.
line 1925: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 1926:   execute "source " . myfiletypefile
line 1927: endif
line 1928: 
line 1929: 
line 1930: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 1931: " when there are no matching file name extensions.
line 1932: " Don't do this for compressed files.
line 1933: augroup filetypedetect
line 1936: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 1937: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 1938: 
line 1939: 
line 1940: " Extra checks for when no filetype has been detected now.  Mostly used for
line 1941: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 1942: " script file.
line 1943: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 1944: " like are used.
line 1945: 
line 1946: " More Apache style config files
line 1947: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 1948: 
line 1949: " More Apache config files
line 1950: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 1951: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 1952: 
line 1953: " Asterisk config file
line 1954: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 1955: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 1956: 
line 1957: " Bazaar version control
line 1958: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 1959: 
line 1960: " Bazel build file
line 1961: if !has("fname_case")
line 1962:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 1963: endif
line 1964: 
line 1965: " BIND zone
line 1966: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 1967: 
line 1968: " Calendar
line 1971: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 1972: 
line 1973: " Changelog
line 1979: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 1980: 
line 1981: " Crontab
line 1982: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 1983: 
line 1984: " dnsmasq(8) configuration
line 1985: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 1986: 
line 1987: " Dracula
line 1988: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 1989: 
line 1990: " Fvwm
line 1991: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 1993: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 1999: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2000: 
line 2001: " Gedcom
line 2002: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2003: 
line 2004: " GTK RC
line 2005: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2006: 
line 2007: " Jam
line 2008: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2009: 
line 2010: " Jargon
line 2014: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2015: 
line 2016: " Kconfig
line 2017: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2018: 
line 2019: " Lilo: Linux loader
line 2020: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2021: 
line 2022: " Logcheck
line 2023: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2024: 
line 2025: " Makefile
line 2026: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2027: 
line 2028: " Ruby Makefile
line 2029: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2030: 
line 2031: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2032: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2033: 
line 2034: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2035: 
line 2036: " Modconf
line 2040: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2041: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2042: 
line 2043: " Mutt setup file
line 2044: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2045: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2046: 
line 2047: " Neomutt setup file
line 2048: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2049: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2050: 
line 2051: " Nroff macros
line 2052: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2053: 
line 2054: " OpenBSD hostname.if
line 2055: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2056: 
line 2057: " Pam conf
line 2058: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2059: 
line 2060: " Printcap and Termcap
line 2064: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2068: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2069: 
line 2070: " ReDIF
line 2071: " Only used when the .rdf file was not detected to be XML.
line 2072: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2073: 
line 2074: " Remind
line 2075: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2076: 
line 2077: " Vim script
line 2078: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2079: 
line 2080: " Subversion commit file
line 2081: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2082: 
line 2083: " X resources file
line 2084: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2085: 
line 2086: " XFree86 config
line 2088: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2093: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2094: 
line 2095: " X11 xmodmap
line 2096: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2097: 
line 2098: " Xinetd conf
line 2099: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2100: 
line 2101: " yum conf (close enough to dosini)
line 2102: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2103: 
line 2104: " Z-Shell script
line 2105: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2106: 
line 2107: 
line 2108: " Plain text files, needs to be far down to not override others.  This avoids
line 2109: " the "conf" type being used if there is a line starting with '#'.
line 2110: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2111: 
line 2112: " Help files match *.txt but should have a last line that is a modeline.
line 2116: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2117: 
line 2118: 
line 2119: " Use the filetype detect plugins.  They may overrule any of the previously
line 2120: " detected filetypes.
line 2121: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 2121: sourcing "/usr/share/vim/vimfiles/ftdetect/conkyrc.vim"
line 1: " Vim filetype detection file for Conky config files
line 2: "
line 3: 
line 4: au BufNewFile,BufRead *conkyrc set filetype=conkyrc
line 5: au BufNewFile,BufRead conky.conf set filetype=conkyrc
finished sourcing /usr/share/vim/vimfiles/ftdetect/conkyrc.vim
continuing in /usr/share/vim/vim81/filetype.vim
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 2121: sourcing "/usr/share/vim/vimfiles/ftdetect/meson.vim"
line 1: au BufNewFile,BufRead meson.build set filetype=meson
line 2: au BufNewFile,BufRead meson_options.txt set filetype=meson
finished sourcing /usr/share/vim/vimfiles/ftdetect/meson.vim
continuing in /usr/share/vim/vim81/filetype.vim
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftdetect/*.vim"
Searching for "/home/ringu/.vim/after/ftdetect/*.vim"
line 2122: 
line 2123: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2124: " and started another one. Let's make sure it has ended to get to a consistent
line 2125: " state.
line 2126: augroup END
line 2127: 
line 2128: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2134: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2135: 
line 2136: 
line 2137: " If the GUI is already running, may still need to install the Syntax menu.
line 2138: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2140: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2141:   source <sfile>:p:h/menu.vim
line 2142: endif
line 2143: 
line 2144: " Function called for testing all functions defined here.  These are
line 2145: " script-local, thus need to be executed here.
line 2146: " Returns a string with error messages (hopefully empty).
line 2147: func! TestFiletypeFuncs(testlist)
line 2158: 
line 2159: " Restore 'cpoptions'
line 2160: let &cpo = s:cpo_save
line 2161: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/filetype.vim"
Searching for "/home/ringu/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftplugin.vim"
Searching for "/home/ringu/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/indent.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/indent.vim"
Searching for "/home/ringu/.vim/plugged/ale/indent.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/indent.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/indent.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/indent.vim"
Searching for "/home/ringu/.vim/after/indent.vim"
line 81:   if has('vim_starting')
line 82:     if has('syntax') && !exists('g:syntax_on')
line 83:       syntax enable
line 83: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 83: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in function plug#end
line 84:     end
line 85:   else
line 86:     call s:reload_plugins()
line 87:   endif
function plug#end returning #0

continuing in /home/ringu/.vimrc

line 20: 
line 21: set laststatus=2
line 22: set noshowmode
line 23: set showtabline=2
line 24: set t_Co=256
line 25: set background=dark
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 25: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 26: set noswapfile
line 27: set nowrap
line 28: set title
line 29: set updatetime=100
line 30: colorscheme gruvbox 
Searching for "colors/gruvbox.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/ale/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/colors/gruvbox.vim"
Searching for "/usr/share/vim/vimfiles/colors/gruvbox.vim"
chdir(/usr/share/vim/vimfiles/colors)
fchdir() to previous dir
line 30: sourcing "/usr/share/vim/vimfiles/colors/gruvbox.vim"
line 1: " -----------------------------------------------------------------------------
line 2: " File: gruvbox.vim
line 3: " Description: Retro groove color scheme for Vim
line 4: " Author: morhetz <morhetz@gmail.com>
line 5: " Source: https://github.com/morhetz/gruvbox
line 6: " Last Modified: 12 Aug 2017
line 7: " -----------------------------------------------------------------------------
line 8: 
line 9: " Supporting code -------------------------------------------------------------
line 10: " Initialisation: {{{
line 11: 
line 12: if version > 580
line 13:   hi clear
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 14:   if exists("syntax_on")
line 15:     syntax reset
line 15: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 16:   endif
line 17: endif
line 18: 
line 19: let g:colors_name='gruvbox'
line 20: 
line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256
line 22:   finish
line 23: endif
line 24: 
line 25: " }}}
line 26: " Global Settings: {{{
line 27: 
line 28: if !exists('g:gruvbox_bold')
line 29:   let g:gruvbox_bold=1
line 30: endif
line 31: if !exists('g:gruvbox_italic')
line 32:   if has('gui_running') || $TERM_ITALICS == 'true'
line 33:     let g:gruvbox_italic=1
line 34:   else
line 35:     let g:gruvbox_italic=0
line 36:   endif
line 37: endif
line 38: if !exists('g:gruvbox_undercurl')
line 39:   let g:gruvbox_undercurl=1
line 40: endif
line 41: if !exists('g:gruvbox_underline')
line 42:   let g:gruvbox_underline=1
line 43: endif
line 44: if !exists('g:gruvbox_inverse')
line 45:   let g:gruvbox_inverse=1
line 46: endif
line 47: 
line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
line 49:   let g:gruvbox_guisp_fallback='NONE'
line 50: endif
line 51: 
line 52: if !exists('g:gruvbox_improved_strings')
line 53:   let g:gruvbox_improved_strings=0
line 54: endif
line 55: 
line 56: if !exists('g:gruvbox_improved_warnings')
line 57:   let g:gruvbox_improved_warnings=0
line 58: endif
line 59: 
line 60: if !exists('g:gruvbox_termcolors')
line 61:   let g:gruvbox_termcolors=256
line 62: endif
line 63: 
line 64: if !exists('g:gruvbox_invert_indent_guides')
line 65:   let g:gruvbox_invert_indent_guides=0
line 66: endif
line 67: 
line 68: if exists('g:gruvbox_contrast')
line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
line 70: endif
line 71: 
line 72: if !exists('g:gruvbox_contrast_dark')
line 73:   let g:gruvbox_contrast_dark='medium'
line 74: endif
line 75: 
line 76: if !exists('g:gruvbox_contrast_light')
line 77:   let g:gruvbox_contrast_light='medium'
line 78: endif
line 79: 
line 80: let s:is_dark=(&background == 'dark')
line 81: 
line 82: " }}}
line 83: " Palette: {{{
line 84: 
line 85: " setup palette dictionary
line 86: let s:gb = {}
line 87: 
line 88: " fill it with absolute colors
line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40
line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69
line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
line 97: 
line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
line 100: 
line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132
line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
line 109: 
line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
line 117: 
line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
line 125: 
line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
line 133: 
line 134: " }}}
line 135: " Setup Emphasis: {{{
line 136: 
line 137: let s:bold = 'bold,'
line 138: if g:gruvbox_bold == 0
line 139:   let s:bold = ''
line 140: endif
line 141: 
line 142: let s:italic = 'italic,'
line 143: if g:gruvbox_italic == 0
line 144:   let s:italic = ''
line 145: endif
line 146: 
line 147: let s:underline = 'underline,'
line 148: if g:gruvbox_underline == 0
line 149:   let s:underline = ''
line 150: endif
line 151: 
line 152: let s:undercurl = 'undercurl,'
line 153: if g:gruvbox_undercurl == 0
line 154:   let s:undercurl = ''
line 155: endif
line 156: 
line 157: let s:inverse = 'inverse,'
line 158: if g:gruvbox_inverse == 0
line 159:   let s:inverse = ''
line 160: endif
line 161: 
line 162: " }}}
line 163: " Setup Colors: {{{
line 164: 
line 165: let s:vim_bg = ['bg', 'bg']
line 166: let s:vim_fg = ['fg', 'fg']
line 167: let s:none = ['NONE', 'NONE']
line 168: 
line 169: " determine relative colors
line 170: if s:is_dark
line 171:   let s:bg0  = s:gb.dark0
line 172:   if g:gruvbox_contrast_dark == 'soft'
line 173:     let s:bg0  = s:gb.dark0_soft
line 174:   elseif g:gruvbox_contrast_dark == 'hard'
line 175:     let s:bg0  = s:gb.dark0_hard
line 176:   endif
line 177: 
line 178:   let s:bg1  = s:gb.dark1
line 179:   let s:bg2  = s:gb.dark2
line 180:   let s:bg3  = s:gb.dark3
line 181:   let s:bg4  = s:gb.dark4
line 182: 
line 183:   let s:gray = s:gb.gray_245
line 184: 
line 185:   let s:fg0 = s:gb.light0
line 186:   let s:fg1 = s:gb.light1
line 187:   let s:fg2 = s:gb.light2
line 188:   let s:fg3 = s:gb.light3
line 189:   let s:fg4 = s:gb.light4
line 190: 
line 191:   let s:fg4_256 = s:gb.light4_256
line 192: 
line 193:   let s:red    = s:gb.bright_red
line 194:   let s:green  = s:gb.bright_green
line 195:   let s:yellow = s:gb.bright_yellow
line 196:   let s:blue   = s:gb.bright_blue
line 197:   let s:purple = s:gb.bright_purple
line 198:   let s:aqua   = s:gb.bright_aqua
line 199:   let s:orange = s:gb.bright_orange
line 200: else
line 201:   let s:bg0  = s:gb.light0
line 202:   if g:gruvbox_contrast_light == 'soft'
line 203:     let s:bg0  = s:gb.light0_soft
line 204:   elseif g:gruvbox_contrast_light == 'hard'
line 205:     let s:bg0  = s:gb.light0_hard
line 206:   endif
line 207: 
line 208:   let s:bg1  = s:gb.light1
line 209:   let s:bg2  = s:gb.light2
line 210:   let s:bg3  = s:gb.light3
line 211:   let s:bg4  = s:gb.light4
line 212: 
line 213:   let s:gray = s:gb.gray_244
line 214: 
line 215:   let s:fg0 = s:gb.dark0
line 216:   let s:fg1 = s:gb.dark1
line 217:   let s:fg2 = s:gb.dark2
line 218:   let s:fg3 = s:gb.dark3
line 219:   let s:fg4 = s:gb.dark4
line 220: 
line 221:   let s:fg4_256 = s:gb.dark4_256
line 222: 
line 223:   let s:red    = s:gb.faded_red
line 224:   let s:green  = s:gb.faded_green
line 225:   let s:yellow = s:gb.faded_yellow
line 226:   let s:blue   = s:gb.faded_blue
line 227:   let s:purple = s:gb.faded_purple
line 228:   let s:aqua   = s:gb.faded_aqua
line 229:   let s:orange = s:gb.faded_orange
line 230: endif
line 231: 
line 232: " reset to 16 colors fallback
line 233: if g:gruvbox_termcolors == 16
line 234:   let s:bg0[1]    = 0
line 235:   let s:fg4[1]    = 7
line 236:   let s:gray[1]   = 8
line 237:   let s:red[1]    = 9
line 238:   let s:green[1]  = 10
line 239:   let s:yellow[1] = 11
line 240:   let s:blue[1]   = 12
line 241:   let s:purple[1] = 13
line 242:   let s:aqua[1]   = 14
line 243:   let s:fg1[1]    = 15
line 244: endif
line 245: 
line 246: " save current relative colors back to palette dictionary
line 247: let s:gb.bg0 = s:bg0
line 248: let s:gb.bg1 = s:bg1
line 249: let s:gb.bg2 = s:bg2
line 250: let s:gb.bg3 = s:bg3
line 251: let s:gb.bg4 = s:bg4
line 252: 
line 253: let s:gb.gray = s:gray
line 254: 
line 255: let s:gb.fg0 = s:fg0
line 256: let s:gb.fg1 = s:fg1
line 257: let s:gb.fg2 = s:fg2
line 258: let s:gb.fg3 = s:fg3
line 259: let s:gb.fg4 = s:fg4
line 260: 
line 261: let s:gb.fg4_256 = s:fg4_256
line 262: 
line 263: let s:gb.red    = s:red
line 264: let s:gb.green  = s:green
line 265: let s:gb.yellow = s:yellow
line 266: let s:gb.blue   = s:blue
line 267: let s:gb.purple = s:purple
line 268: let s:gb.aqua   = s:aqua
line 269: let s:gb.orange = s:orange
line 270: 
line 271: " }}}
line 272: " Setup Terminal Colors For Neovim: {{{
line 273: 
line 274: if has('nvim')
line 275:   let g:terminal_color_0 = s:bg0[0]
line 276:   let g:terminal_color_8 = s:gray[0]
line 277: 
line 278:   let g:terminal_color_1 = s:gb.neutral_red[0]
line 279:   let g:terminal_color_9 = s:red[0]
line 280: 
line 281:   let g:terminal_color_2 = s:gb.neutral_green[0]
line 282:   let g:terminal_color_10 = s:green[0]
line 283: 
line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0]
line 285:   let g:terminal_color_11 = s:yellow[0]
line 286: 
line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0]
line 288:   let g:terminal_color_12 = s:blue[0]
line 289: 
line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0]
line 291:   let g:terminal_color_13 = s:purple[0]
line 292: 
line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0]
line 294:   let g:terminal_color_14 = s:aqua[0]
line 295: 
line 296:   let g:terminal_color_7 = s:fg4[0]
line 297:   let g:terminal_color_15 = s:fg1[0]
line 298: endif
line 299: 
line 300: " }}}
line 301: " Overload Setting: {{{
line 302: 
line 303: let s:hls_cursor = s:orange
line 304: if exists('g:gruvbox_hls_cursor')
line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
line 306: endif
line 307: 
line 308: let s:number_column = s:none
line 309: if exists('g:gruvbox_number_column')
line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)
line 311: endif
line 312: 
line 313: let s:sign_column = s:bg1
line 314: 
line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1
line 317:   let s:sign_column = s:number_column
line 318: else
line 319:   let g:gitgutter_override_sign_column_highlight = 0
line 320: 
line 321:   if exists('g:gruvbox_sign_column')
line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)
line 323:   endif
line 324: endif
line 325: 
line 326: let s:color_column = s:bg1
line 327: if exists('g:gruvbox_color_column')
line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)
line 329: endif
line 330: 
line 331: let s:vert_split = s:bg0
line 332: if exists('g:gruvbox_vert_split')
line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)
line 334: endif
line 335: 
line 336: let s:invert_signs = ''
line 337: if exists('g:gruvbox_invert_signs')
line 338:   if g:gruvbox_invert_signs == 1
line 339:     let s:invert_signs = s:inverse
line 340:   endif
line 341: endif
line 342: 
line 343: let s:invert_selection = s:inverse
line 344: if exists('g:gruvbox_invert_selection')
line 345:   if g:gruvbox_invert_selection == 0
line 346:     let s:invert_selection = ''
line 347:   endif
line 348: endif
line 349: 
line 350: let s:invert_tabline = ''
line 351: if exists('g:gruvbox_invert_tabline')
line 352:   if g:gruvbox_invert_tabline == 1
line 353:     let s:invert_tabline = s:inverse
line 354:   endif
line 355: endif
line 356: 
line 357: let s:italicize_comments = s:italic
line 358: if exists('g:gruvbox_italicize_comments')
line 359:   if g:gruvbox_italicize_comments == 0
line 360:     let s:italicize_comments = ''
line 361:   endif
line 362: endif
line 363: 
line 364: let s:italicize_strings = ''
line 365: if exists('g:gruvbox_italicize_strings')
line 366:   if g:gruvbox_italicize_strings == 1
line 367:     let s:italicize_strings = s:italic
line 368:   endif
line 369: endif
line 370: 
line 371: " }}}
line 372: " Highlighting Function: {{{
line 373: 
line 374: function! s:HL(group, fg, ...)
line 419: 
line 420: " }}}
line 421: " Gruvbox Hi Groups: {{{
line 422: 
line 423: " memoize common hi groups
line 424: call s:HL('GruvboxFg0', s:fg0)
calling function <SNR>14_HL('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 425: call s:HL('GruvboxFg1', s:fg1)
calling function <SNR>14_HL('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 426: call s:HL('GruvboxFg2', s:fg2)
calling function <SNR>14_HL('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 427: call s:HL('GruvboxFg3', s:fg3)
calling function <SNR>14_HL('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 428: call s:HL('GruvboxFg4', s:fg4)
calling function <SNR>14_HL('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 429: call s:HL('GruvboxGray', s:gray)
calling function <SNR>14_HL('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 430: call s:HL('GruvboxBg0', s:bg0)
calling function <SNR>14_HL('GruvboxBg0', ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg0 guifg=#282828 ctermfg=235 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 431: call s:HL('GruvboxBg1', s:bg1)
calling function <SNR>14_HL('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 432: call s:HL('GruvboxBg2', s:bg2)
calling function <SNR>14_HL('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 433: call s:HL('GruvboxBg3', s:bg3)
calling function <SNR>14_HL('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 434: call s:HL('GruvboxBg4', s:bg4)
calling function <SNR>14_HL('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 435: 
line 436: call s:HL('GruvboxRed', s:red)
calling function <SNR>14_HL('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
calling function <SNR>14_HL('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 438: call s:HL('GruvboxGreen', s:green)
calling function <SNR>14_HL('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
calling function <SNR>14_HL('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 440: call s:HL('GruvboxYellow', s:yellow)
calling function <SNR>14_HL('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
calling function <SNR>14_HL('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 442: call s:HL('GruvboxBlue', s:blue)
calling function <SNR>14_HL('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
calling function <SNR>14_HL('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 444: call s:HL('GruvboxPurple', s:purple)
calling function <SNR>14_HL('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
calling function <SNR>14_HL('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 446: call s:HL('GruvboxAqua', s:aqua)
calling function <SNR>14_HL('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
calling function <SNR>14_HL('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 448: call s:HL('GruvboxOrange', s:orange)
calling function <SNR>14_HL('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
calling function <SNR>14_HL('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 450: 
line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 457: 
line 458: " }}}
line 459: 
line 460: " Vanilla colorscheme ---------------------------------------------------------
line 461: " General UI: {{{
line 462: 
line 463: " Normal text
line 464: call s:HL('Normal', s:fg1, s:bg0)
calling function <SNR>14_HL('Normal', ['#ebdbb2', 223], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 465: 
line 466: " Correct background (see issue #7):
line 467: " --- Problem with changing between dark and light on 256 color terminal
line 468: " --- https://github.com/morhetz/gruvbox/issues/7
line 469: if s:is_dark
line 470:   set background=dark
line 471: else
line 472:   set background=light
line 473: endif
line 474: 
line 475: if version >= 700
line 476:   " Screen line that the cursor is
line 477:   call s:HL('CursorLine',   s:none, s:bg1)
calling function <SNR>14_HL('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 478:   " Screen column that the cursor is
line 479:   hi! link CursorColumn CursorLine
line 480: 
line 481:   " Tab pages line filler
line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 483:   " Active tab page label
line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 485:   " Not active tab page label
line 486:   hi! link TabLine TabLineFill
line 487: 
line 488:   " Match paired bracket under the cursor
line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)
calling function <SNR>14_HL('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 490: endif
line 491: 
line 492: if version >= 703
line 493:   " Highlighted screen columns
line 494:   call s:HL('ColorColumn',  s:none, s:color_column)
calling function <SNR>14_HL('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 495: 
line 496:   " Concealed element: \lambda  
line 497:   call s:HL('Conceal', s:blue, s:none)
calling function <SNR>14_HL('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 498: 
line 499:   " Line number of CursorLine
line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)
calling function <SNR>14_HL('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 501: endif
line 502: 
line 503: hi! link NonText GruvboxBg2
line 504: hi! link SpecialKey GruvboxBg2
line 505: 
line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
calling function <SNR>14_HL('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 507: hi! link VisualNOS Visual
line 508: 
line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('Search', ['#fabd2f', 214], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
calling function <SNR>14_HL('IncSearch', ['#fe8019', 208], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 511: 
line 512: call s:HL('Underlined', s:blue, s:none, s:underline)
calling function <SNR>14_HL('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 513: 
line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)
calling function <SNR>14_HL('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)
calling function <SNR>14_HL('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 516: 
line 517: " The column separating vertically split windows
line 518: call s:HL('VertSplit', s:bg3, s:vert_split)
calling function <SNR>14_HL('VertSplit', ['#665c54', 241], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 519: 
line 520: " Current match in wildmenu completion
line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 522: 
line 523: " Directory names, special names in listing
line 524: hi! link Directory GruvboxGreenBold
line 525: 
line 526: " Titles for output from :set all, :autocmd, etc.
line 527: hi! link Title GruvboxGreenBold
line 528: 
line 529: " Error messages on the command line
line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
calling function <SNR>14_HL('ErrorMsg', ['#282828', 235], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ErrorMsg guifg=#282828 ctermfg=235 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 531: " More prompt: -- More --
line 532: hi! link MoreMsg GruvboxYellowBold
line 533: " Current mode message: -- INSERT --
line 534: hi! link ModeMsg GruvboxYellowBold
line 535: " 'Press enter' prompt and yes/no questions
line 536: hi! link Question GruvboxOrangeBold
line 537: " Warning messages
line 538: hi! link WarningMsg GruvboxRedBold
line 539: 
line 540: " }}}
line 541: " Gutter: {{{
line 542: 
line 543: " Line number for :number and :# commands
line 544: call s:HL('LineNr', s:bg4, s:number_column)
calling function <SNR>14_HL('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 545: 
line 546: " Column where signs are displayed
line 547: call s:HL('SignColumn', s:none, s:sign_column)
calling function <SNR>14_HL('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 548: 
line 549: " Line used for closed folds
line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)
calling function <SNR>14_HL('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 551: " Column where folds are displayed
line 552: call s:HL('FoldColumn', s:gray, s:bg1)
calling function <SNR>14_HL('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 553: 
line 554: " }}}
line 555: " Cursor: {{{
line 556: 
line 557: " Character under cursor
line 558: call s:HL('Cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 559: " Visual mode cursor, selection
line 560: hi! link vCursor Cursor
line 561: " Input moder cursor
line 562: hi! link iCursor Cursor
line 563: " Language mapping cursor
line 564: hi! link lCursor Cursor
line 565: 
line 566: " }}}
line 567: " Syntax Highlighting: {{{
line 568: 
line 569: if g:gruvbox_improved_strings == 0
line 570:   hi! link Special GruvboxOrange
line 571: else
line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)
line 573: endif
line 574: 
line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)
calling function <SNR>14_HL('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
calling function <SNR>14_HL('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 578: 
line 579: " Generic statement
line 580: hi! link Statement GruvboxRed
line 581: " if, then, else, endif, swicth, etc.
line 582: hi! link Conditional GruvboxRed
line 583: " for, do, while, etc.
line 584: hi! link Repeat GruvboxRed
line 585: " case, default, etc.
line 586: hi! link Label GruvboxRed
line 587: " try, catch, throw
line 588: hi! link Exception GruvboxRed
line 589: " sizeof, "+", "*", etc.
line 590: hi! link Operator Normal
line 591: " Any other keyword
line 592: hi! link Keyword GruvboxRed
line 593: 
line 594: " Variable name
line 595: hi! link Identifier GruvboxBlue
line 596: " Function name
line 597: hi! link Function GruvboxGreenBold
line 598: 
line 599: " Generic preprocessor
line 600: hi! link PreProc GruvboxAqua
line 601: " Preprocessor #include
line 602: hi! link Include GruvboxAqua
line 603: " Preprocessor #define
line 604: hi! link Define GruvboxAqua
line 605: " Same as Define
line 606: hi! link Macro GruvboxAqua
line 607: " Preprocessor #if, #else, #endif, etc.
line 608: hi! link PreCondit GruvboxAqua
line 609: 
line 610: " Generic constant
line 611: hi! link Constant GruvboxPurple
line 612: " Character constant: 'c', '/n'
line 613: hi! link Character GruvboxPurple
line 614: " String constant: "this is a string"
line 615: if g:gruvbox_improved_strings == 0
line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)
calling function <SNR>14_HL('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 617: else
line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)
line 619: endif
line 620: " Boolean constant: TRUE, false
line 621: hi! link Boolean GruvboxPurple
line 622: " Number constant: 234, 0xff
line 623: hi! link Number GruvboxPurple
line 624: " Floating point constant: 2.3e10
line 625: hi! link Float GruvboxPurple
line 626: 
line 627: " Generic type
line 628: hi! link Type GruvboxYellow
line 629: " static, register, volatile, etc
line 630: hi! link StorageClass GruvboxOrange
line 631: " struct, union, enum, etc.
line 632: hi! link Structure GruvboxAqua
line 633: " typedef
line 634: hi! link Typedef GruvboxYellow
line 635: 
line 636: " }}}
line 637: " Completion Menu: {{{
line 638: 
line 639: if version >= 700
line 640:   " Popup menu: normal item
line 641:   call s:HL('Pmenu', s:fg1, s:bg2)
calling function <SNR>14_HL('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 642:   " Popup menu: selected item
line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
calling function <SNR>14_HL('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 644:   " Popup menu: scrollbar
line 645:   call s:HL('PmenuSbar', s:none, s:bg2)
calling function <SNR>14_HL('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 646:   " Popup menu: scrollbar thumb
line 647:   call s:HL('PmenuThumb', s:none, s:bg4)
calling function <SNR>14_HL('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 648: endif
line 649: 
line 650: " }}}
line 651: " Diffs: {{{
line 652: 
line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffDelete', ['#fb4934', 167], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffAdd', ['#b8bb26', 142], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 655: "call s:HL('DiffChange', s:bg0, s:blue)
line 656: "call s:HL('DiffText',   s:bg0, s:yellow)
line 657: 
line 658: " Alternative setting
line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffChange', ['#8ec07c', 108], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffText', ['#fabd2f', 214], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 661: 
line 662: " }}}
line 663: " Spelling: {{{
line 664: 
line 665: if has("spell")
line 666:   " Not capitalised word, or compile warnings
line 667:   if g:gruvbox_improved_warnings == 0
line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 669:   else
line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
line 671:   endif
line 672:   " Not recognized word
line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 674:   " Wrong spelling for selected region
line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
calling function <SNR>14_HL('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 676:   " Rare word
line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
calling function <SNR>14_HL('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 678: endif
line 679: 
line 680: " }}}
line 681: 
line 682: " Plugin specific -------------------------------------------------------------
line 683: " EasyMotion: {{{
line 684: 
line 685: hi! link EasyMotionTarget Search
line 686: hi! link EasyMotionShade Comment
line 687: 
line 688: " }}}
line 689: " Sneak: {{{
line 690: 
line 691: hi! link Sneak Search
line 692: hi! link SneakLabel Search
line 693: 
line 694: " }}}
line 695: " Indent Guides: {{{
line 696: 
line 697: if !exists('g:indent_guides_auto_colors')
line 698:   let g:indent_guides_auto_colors = 0
line 699: endif
line 700: 
line 701: if g:indent_guides_auto_colors == 0
line 702:   if g:gruvbox_invert_indent_guides == 0
line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
calling function <SNR>14_HL('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
calling function <SNR>14_HL('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 705:   else
line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
line 708:   endif
line 709: endif
line 710: 
line 711: " }}}
line 712: " IndentLine: {{{
line 713: 
line 714: if !exists('g:indentLine_color_term')
line 715:   let g:indentLine_color_term = s:bg2[1]
line 716: endif
line 717: if !exists('g:indentLine_color_gui')
line 718:   let g:indentLine_color_gui = s:bg2[0]
line 719: endif
line 720: 
line 721: " }}}
line 722: " Rainbow Parentheses: {{{
line 723: 
line 724: if !exists('g:rbpt_colorpairs')
line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ]
line 730: endif
line 731: 
line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
line 734: 
line 735: if !exists('g:rainbow_conf')
line 736:    let g:rainbow_conf = {}
line 737: endif
line 738: if !has_key(g:rainbow_conf, 'guifgs')
line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
line 740: endif
line 741: if !has_key(g:rainbow_conf, 'ctermfgs')
line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
line 743: endif
line 744: 
line 745: let g:niji_dark_colours = g:rbpt_colorpairs
line 746: let g:niji_light_colours = g:rbpt_colorpairs
line 747: 
line 748: "}}}
line 749: " GitGutter: {{{
line 750: 
line 751: hi! link GitGutterAdd GruvboxGreenSign
line 752: hi! link GitGutterChange GruvboxAquaSign
line 753: hi! link GitGutterDelete GruvboxRedSign
line 754: hi! link GitGutterChangeDelete GruvboxAquaSign
line 755: 
line 756: " }}}
line 757: " GitCommit: "{{{
line 758: 
line 759: hi! link gitcommitSelectedFile GruvboxGreen
line 760: hi! link gitcommitDiscardedFile GruvboxRed
line 761: 
line 762: " }}}
line 763: " Signify: {{{
line 764: 
line 765: hi! link SignifySignAdd GruvboxGreenSign
line 766: hi! link SignifySignChange GruvboxAquaSign
line 767: hi! link SignifySignDelete GruvboxRedSign
line 768: 
line 769: " }}}
line 770: " Syntastic: {{{
line 771: 
line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 774: 
line 775: hi! link SyntasticErrorSign GruvboxRedSign
line 776: hi! link SyntasticWarningSign GruvboxYellowSign
line 777: 
line 778: " }}}
line 779: " Signature: {{{
line 780: hi! link SignatureMarkText   GruvboxBlueSign
line 781: hi! link SignatureMarkerText GruvboxPurpleSign
line 782: 
line 783: " }}}
line 784: " ShowMarks: {{{
line 785: 
line 786: hi! link ShowMarksHLl GruvboxBlueSign
line 787: hi! link ShowMarksHLu GruvboxBlueSign
line 788: hi! link ShowMarksHLo GruvboxBlueSign
line 789: hi! link ShowMarksHLm GruvboxBlueSign
line 790: 
line 791: " }}}
line 792: " CtrlP: {{{
line 793: 
line 794: hi! link CtrlPMatch GruvboxYellow
line 795: hi! link CtrlPNoEntries GruvboxRed
line 796: hi! link CtrlPPrtBase GruvboxBg2
line 797: hi! link CtrlPPrtCursor GruvboxBlue
line 798: hi! link CtrlPLinePre GruvboxBg2
line 799: 
line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
calling function <SNR>14_HL('CtrlPMode2', ['#282828', 235], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode2 guifg=#282828 ctermfg=235 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 803: 
line 804: " }}}
line 805: " Startify: {{{
line 806: 
line 807: hi! link StartifyBracket GruvboxFg3
line 808: hi! link StartifyFile GruvboxFg1
line 809: hi! link StartifyNumber GruvboxBlue
line 810: hi! link StartifyPath GruvboxGray
line 811: hi! link StartifySlash GruvboxGray
line 812: hi! link StartifySection GruvboxYellow
line 813: hi! link StartifySpecial GruvboxBg2
line 814: hi! link StartifyHeader GruvboxOrange
line 815: hi! link StartifyFooter GruvboxBg2
line 816: 
line 817: " }}}
line 818: " Vimshell: {{{
line 819: 
line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ]
line 826: 
line 827: " }}}
line 828: " BufTabLine: {{{
line 829: 
line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
calling function <SNR>14_HL('BufTabLineCurrent', ['#282828', 235], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineCurrent guifg=#282828 ctermfg=235 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)
calling function <SNR>14_HL('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)
calling function <SNR>14_HL('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)
calling function <SNR>14_HL('BufTabLineFill', ['#282828', 235], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineFill guifg=#282828 ctermfg=235 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 834: 
line 835: " }}}
line 836: " Asynchronous Lint Engine: {{{
line 837: 
line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 841: 
line 842: hi! link ALEErrorSign GruvboxRedSign
line 843: hi! link ALEWarningSign GruvboxYellowSign
line 844: hi! link ALEInfoSign GruvboxBlueSign
line 845: 
line 846: " }}}
line 847: " Dirvish: {{{
line 848: 
line 849: hi! link DirvishPathTail GruvboxAqua
line 850: hi! link DirvishArg GruvboxYellow
line 851: 
line 852: " }}}
line 853: " Netrw: {{{
line 854: 
line 855: hi! link netrwDir GruvboxAqua
line 856: hi! link netrwClassify GruvboxAqua
line 857: hi! link netrwLink GruvboxGray
line 858: hi! link netrwSymLink GruvboxFg1
line 859: hi! link netrwExe GruvboxYellow
line 860: hi! link netrwComment GruvboxGray
line 861: hi! link netrwList GruvboxBlue
line 862: hi! link netrwHelpCmd GruvboxAqua
line 863: hi! link netrwCmdSep GruvboxFg3
line 864: hi! link netrwVersion GruvboxGreen
line 865: 
line 866: " }}}
line 867: " NERDTree: {{{
line 868: 
line 869: hi! link NERDTreeDir GruvboxAqua
line 870: hi! link NERDTreeDirSlash GruvboxAqua
line 871: 
line 872: hi! link NERDTreeOpenable GruvboxOrange
line 873: hi! link NERDTreeClosable GruvboxOrange
line 874: 
line 875: hi! link NERDTreeFile GruvboxFg1
line 876: hi! link NERDTreeExecFile GruvboxYellow
line 877: 
line 878: hi! link NERDTreeUp GruvboxGray
line 879: hi! link NERDTreeCWD GruvboxGreen
line 880: hi! link NERDTreeHelp GruvboxFg1
line 881: 
line 882: hi! link NERDTreeToggleOn GruvboxGreen
line 883: hi! link NERDTreeToggleOff GruvboxRed
line 884: 
line 885: " }}}
line 886: " Vim Multiple Cursors: {{{
line 887: 
line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)
calling function <SNR>14_HL('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 890: 
line 891: " }}}
line 892: 
line 893: " Filetype specific -----------------------------------------------------------
line 894: " Diff: {{{
line 895: 
line 896: hi! link diffAdded GruvboxGreen
line 897: hi! link diffRemoved GruvboxRed
line 898: hi! link diffChanged GruvboxAqua
line 899: 
line 900: hi! link diffFile GruvboxOrange
line 901: hi! link diffNewFile GruvboxYellow
line 902: 
line 903: hi! link diffLine GruvboxBlue
line 904: 
line 905: " }}}
line 906: " Html: {{{
line 907: 
line 908: hi! link htmlTag GruvboxBlue
line 909: hi! link htmlEndTag GruvboxBlue
line 910: 
line 911: hi! link htmlTagName GruvboxAquaBold
line 912: hi! link htmlArg GruvboxAqua
line 913: 
line 914: hi! link htmlScriptTag GruvboxPurple
line 915: hi! link htmlTagN GruvboxFg1
line 916: hi! link htmlSpecialTagName GruvboxAquaBold
line 917: 
line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)
calling function <SNR>14_HL('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 919: 
line 920: hi! link htmlSpecialChar GruvboxOrange
line 921: 
line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
calling function <SNR>14_HL('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
calling function <SNR>14_HL('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
calling function <SNR>14_HL('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 926: 
line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
calling function <SNR>14_HL('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
calling function <SNR>14_HL('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
calling function <SNR>14_HL('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 930: 
line 931: " }}}
line 932: " Xml: {{{
line 933: 
line 934: hi! link xmlTag GruvboxBlue
line 935: hi! link xmlEndTag GruvboxBlue
line 936: hi! link xmlTagName GruvboxBlue
line 937: hi! link xmlEqual GruvboxBlue
line 938: hi! link docbkKeyword GruvboxAquaBold
line 939: 
line 940: hi! link xmlDocTypeDecl GruvboxGray
line 941: hi! link xmlDocTypeKeyword GruvboxPurple
line 942: hi! link xmlCdataStart GruvboxGray
line 943: hi! link xmlCdataCdata GruvboxPurple
line 944: hi! link dtdFunction GruvboxGray
line 945: hi! link dtdTagName GruvboxPurple
line 946: 
line 947: hi! link xmlAttrib GruvboxAqua
line 948: hi! link xmlProcessingDelim GruvboxGray
line 949: hi! link dtdParamEntityPunct GruvboxGray
line 950: hi! link dtdParamEntityDPunct GruvboxGray
line 951: hi! link xmlAttribPunct GruvboxGray
line 952: 
line 953: hi! link xmlEntity GruvboxOrange
line 954: hi! link xmlEntityPunct GruvboxOrange
line 955: " }}}
line 956: " Vim: {{{
line 957: 
line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
calling function <SNR>14_HL('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 959: 
line 960: hi! link vimNotation GruvboxOrange
line 961: hi! link vimBracket GruvboxOrange
line 962: hi! link vimMapModKey GruvboxOrange
line 963: hi! link vimFuncSID GruvboxFg3
line 964: hi! link vimSetSep GruvboxFg3
line 965: hi! link vimSep GruvboxFg3
line 966: hi! link vimContinue GruvboxFg3
line 967: 
line 968: " }}}
line 969: " Clojure: {{{
line 970: 
line 971: hi! link clojureKeyword GruvboxBlue
line 972: hi! link clojureCond GruvboxOrange
line 973: hi! link clojureSpecial GruvboxOrange
line 974: hi! link clojureDefine GruvboxOrange
line 975: 
line 976: hi! link clojureFunc GruvboxYellow
line 977: hi! link clojureRepeat GruvboxYellow
line 978: hi! link clojureCharacter GruvboxAqua
line 979: hi! link clojureStringEscape GruvboxAqua
line 980: hi! link clojureException GruvboxRed
line 981: 
line 982: hi! link clojureRegexp GruvboxAqua
line 983: hi! link clojureRegexpEscape GruvboxAqua
line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
calling function <SNR>14_HL('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 985: hi! link clojureRegexpMod clojureRegexpCharClass
line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass
line 987: 
line 988: hi! link clojureParen GruvboxFg3
line 989: hi! link clojureAnonArg GruvboxYellow
line 990: hi! link clojureVariable GruvboxBlue
line 991: hi! link clojureMacro GruvboxOrange
line 992: 
line 993: hi! link clojureMeta GruvboxYellow
line 994: hi! link clojureDeref GruvboxYellow
line 995: hi! link clojureQuote GruvboxYellow
line 996: hi! link clojureUnquote GruvboxYellow
line 997: 
line 998: " }}}
line 999: " C: {{{
line 1000: 
line 1001: hi! link cOperator GruvboxPurple
line 1002: hi! link cStructure GruvboxOrange
line 1003: 
line 1004: " }}}
line 1005: " Python: {{{
line 1006: 
line 1007: hi! link pythonBuiltin GruvboxOrange
line 1008: hi! link pythonBuiltinObj GruvboxOrange
line 1009: hi! link pythonBuiltinFunc GruvboxOrange
line 1010: hi! link pythonFunction GruvboxAqua
line 1011: hi! link pythonDecorator GruvboxRed
line 1012: hi! link pythonInclude GruvboxBlue
line 1013: hi! link pythonImport GruvboxBlue
line 1014: hi! link pythonRun GruvboxBlue
line 1015: hi! link pythonCoding GruvboxBlue
line 1016: hi! link pythonOperator GruvboxRed
line 1017: hi! link pythonException GruvboxRed
line 1018: hi! link pythonExceptions GruvboxPurple
line 1019: hi! link pythonBoolean GruvboxPurple
line 1020: hi! link pythonDot GruvboxFg3
line 1021: hi! link pythonConditional GruvboxRed
line 1022: hi! link pythonRepeat GruvboxRed
line 1023: hi! link pythonDottedName GruvboxGreenBold
line 1024: 
line 1025: " }}}
line 1026: " CSS: {{{
line 1027: 
line 1028: hi! link cssBraces GruvboxBlue
line 1029: hi! link cssFunctionName GruvboxYellow
line 1030: hi! link cssIdentifier GruvboxOrange
line 1031: hi! link cssClassName GruvboxGreen
line 1032: hi! link cssColor GruvboxBlue
line 1033: hi! link cssSelectorOp GruvboxBlue
line 1034: hi! link cssSelectorOp2 GruvboxBlue
line 1035: hi! link cssImportant GruvboxGreen
line 1036: hi! link cssVendor GruvboxFg1
line 1037: 
line 1038: hi! link cssTextProp GruvboxAqua
line 1039: hi! link cssAnimationProp GruvboxAqua
line 1040: hi! link cssUIProp GruvboxYellow
line 1041: hi! link cssTransformProp GruvboxAqua
line 1042: hi! link cssTransitionProp GruvboxAqua
line 1043: hi! link cssPrintProp GruvboxAqua
line 1044: hi! link cssPositioningProp GruvboxYellow
line 1045: hi! link cssBoxProp GruvboxAqua
line 1046: hi! link cssFontDescriptorProp GruvboxAqua
line 1047: hi! link cssFlexibleBoxProp GruvboxAqua
line 1048: hi! link cssBorderOutlineProp GruvboxAqua
line 1049: hi! link cssBackgroundProp GruvboxAqua
line 1050: hi! link cssMarginProp GruvboxAqua
line 1051: hi! link cssListProp GruvboxAqua
line 1052: hi! link cssTableProp GruvboxAqua
line 1053: hi! link cssFontProp GruvboxAqua
line 1054: hi! link cssPaddingProp GruvboxAqua
line 1055: hi! link cssDimensionProp GruvboxAqua
line 1056: hi! link cssRenderProp GruvboxAqua
line 1057: hi! link cssColorProp GruvboxAqua
line 1058: hi! link cssGeneratedContentProp GruvboxAqua
line 1059: 
line 1060: " }}}
line 1061: " JavaScript: {{{
line 1062: 
line 1063: hi! link javaScriptBraces GruvboxFg1
line 1064: hi! link javaScriptFunction GruvboxAqua
line 1065: hi! link javaScriptIdentifier GruvboxRed
line 1066: hi! link javaScriptMember GruvboxBlue
line 1067: hi! link javaScriptNumber GruvboxPurple
line 1068: hi! link javaScriptNull GruvboxPurple
line 1069: hi! link javaScriptParens GruvboxFg3
line 1070: 
line 1071: " }}}
line 1072: " YAJS: {{{
line 1073: 
line 1074: hi! link javascriptImport GruvboxAqua
line 1075: hi! link javascriptExport GruvboxAqua
line 1076: hi! link javascriptClassKeyword GruvboxAqua
line 1077: hi! link javascriptClassExtends GruvboxAqua
line 1078: hi! link javascriptDefault GruvboxAqua
line 1079: 
line 1080: hi! link javascriptClassName GruvboxYellow
line 1081: hi! link javascriptClassSuperName GruvboxYellow
line 1082: hi! link javascriptGlobal GruvboxYellow
line 1083: 
line 1084: hi! link javascriptEndColons GruvboxFg1
line 1085: hi! link javascriptFuncArg GruvboxFg1
line 1086: hi! link javascriptGlobalMethod GruvboxFg1
line 1087: hi! link javascriptNodeGlobal GruvboxFg1
line 1088: hi! link javascriptBOMWindowProp GruvboxFg1
line 1089: hi! link javascriptArrayMethod GruvboxFg1
line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1
line 1091: hi! link javascriptCacheMethod GruvboxFg1
line 1092: hi! link javascriptDateMethod GruvboxFg1
line 1093: hi! link javascriptMathStaticMethod GruvboxFg1
line 1094: 
line 1095: " hi! link javascriptProp GruvboxFg1
line 1096: hi! link javascriptURLUtilsProp GruvboxFg1
line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1
line 1098: hi! link javascriptDOMDocMethod GruvboxFg1
line 1099: hi! link javascriptDOMDocProp GruvboxFg1
line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1
line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1
line 1102: hi! link javascriptStringMethod GruvboxFg1
line 1103: 
line 1104: hi! link javascriptVariable GruvboxOrange
line 1105: " hi! link javascriptVariable GruvboxRed
line 1106: " hi! link javascriptIdentifier GruvboxOrange
line 1107: " hi! link javascriptClassSuper GruvboxOrange
line 1108: hi! link javascriptIdentifier GruvboxOrange
line 1109: hi! link javascriptClassSuper GruvboxOrange
line 1110: 
line 1111: " hi! link javascriptFuncKeyword GruvboxOrange
line 1112: " hi! link javascriptAsyncFunc GruvboxOrange
line 1113: hi! link javascriptFuncKeyword GruvboxAqua
line 1114: hi! link javascriptAsyncFunc GruvboxAqua
line 1115: hi! link javascriptClassStatic GruvboxOrange
line 1116: 
line 1117: hi! link javascriptOperator GruvboxRed
line 1118: hi! link javascriptForOperator GruvboxRed
line 1119: hi! link javascriptYield GruvboxRed
line 1120: hi! link javascriptExceptions GruvboxRed
line 1121: hi! link javascriptMessage GruvboxRed
line 1122: 
line 1123: hi! link javascriptTemplateSB GruvboxAqua
line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1
line 1125: 
line 1126: " hi! link javascriptLabel GruvboxBlue
line 1127: " hi! link javascriptObjectLabel GruvboxBlue
line 1128: " hi! link javascriptPropertyName GruvboxBlue
line 1129: hi! link javascriptLabel GruvboxFg1
line 1130: hi! link javascriptObjectLabel GruvboxFg1
line 1131: hi! link javascriptPropertyName GruvboxFg1
line 1132: 
line 1133: hi! link javascriptLogicSymbols GruvboxFg1
line 1134: hi! link javascriptArrowFunc GruvboxYellow
line 1135: 
line 1136: hi! link javascriptDocParamName GruvboxFg4
line 1137: hi! link javascriptDocTags GruvboxFg4
line 1138: hi! link javascriptDocNotation GruvboxFg4
line 1139: hi! link javascriptDocParamType GruvboxFg4
line 1140: hi! link javascriptDocNamedParamType GruvboxFg4
line 1141: 
line 1142: hi! link javascriptBrackets GruvboxFg1
line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1
line 1144: hi! link javascriptDOMEventMethod GruvboxFg1
line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1
line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1
line 1147: hi! link javascriptHeadersMethod GruvboxFg1
line 1148: 
line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed
line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed
line 1151: 
line 1152: " }}}
line 1153: " PanglossJS: {{{
line 1154: 
line 1155: hi! link jsClassKeyword GruvboxAqua
line 1156: hi! link jsExtendsKeyword GruvboxAqua
line 1157: hi! link jsExportDefault GruvboxAqua
line 1158: hi! link jsTemplateBraces GruvboxAqua
line 1159: hi! link jsGlobalNodeObjects GruvboxFg1
line 1160: hi! link jsGlobalObjects GruvboxFg1
line 1161: hi! link jsFunction GruvboxAqua
line 1162: hi! link jsFuncParens GruvboxFg3
line 1163: hi! link jsParens GruvboxFg3
line 1164: hi! link jsNull GruvboxPurple
line 1165: hi! link jsUndefined GruvboxPurple
line 1166: hi! link jsClassDefinition GruvboxYellow
line 1167: 
line 1168: " }}}
line 1169: " TypeScript: {{{
line 1170: 
line 1171: hi! link typeScriptReserved GruvboxAqua
line 1172: hi! link typeScriptLabel GruvboxAqua
line 1173: hi! link typeScriptFuncKeyword GruvboxAqua
line 1174: hi! link typeScriptIdentifier GruvboxOrange
line 1175: hi! link typeScriptBraces GruvboxFg1
line 1176: hi! link typeScriptEndColons GruvboxFg1
line 1177: hi! link typeScriptDOMObjects GruvboxFg1
line 1178: hi! link typeScriptAjaxMethods GruvboxFg1
line 1179: hi! link typeScriptLogicSymbols GruvboxFg1
line 1180: hi! link typeScriptDocSeeTag Comment
line 1181: hi! link typeScriptDocParam Comment
line 1182: hi! link typeScriptDocTags vimCommentTitle
line 1183: hi! link typeScriptGlobalObjects GruvboxFg1
line 1184: hi! link typeScriptParens GruvboxFg3
line 1185: hi! link typeScriptOpSymbols GruvboxFg3
line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1
line 1187: hi! link typeScriptNull GruvboxPurple
line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua
line 1189: 
line 1190: " }}}
line 1191: " PureScript: {{{
line 1192: 
line 1193: hi! link purescriptModuleKeyword GruvboxAqua
line 1194: hi! link purescriptModuleName GruvboxFg1
line 1195: hi! link purescriptWhere GruvboxAqua
line 1196: hi! link purescriptDelimiter GruvboxFg4
line 1197: hi! link purescriptType GruvboxFg1
line 1198: hi! link purescriptImportKeyword GruvboxAqua
line 1199: hi! link purescriptHidingKeyword GruvboxAqua
line 1200: hi! link purescriptAsKeyword GruvboxAqua
line 1201: hi! link purescriptStructure GruvboxAqua
line 1202: hi! link purescriptOperator GruvboxBlue
line 1203: 
line 1204: hi! link purescriptTypeVar GruvboxFg1
line 1205: hi! link purescriptConstructor GruvboxFg1
line 1206: hi! link purescriptFunction GruvboxFg1
line 1207: hi! link purescriptConditional GruvboxOrange
line 1208: hi! link purescriptBacktick GruvboxOrange
line 1209: 
line 1210: " }}}
line 1211: " CoffeeScript: {{{
line 1212: 
line 1213: hi! link coffeeExtendedOp GruvboxFg3
line 1214: hi! link coffeeSpecialOp GruvboxFg3
line 1215: hi! link coffeeCurly GruvboxOrange
line 1216: hi! link coffeeParen GruvboxFg3
line 1217: hi! link coffeeBracket GruvboxOrange
line 1218: 
line 1219: " }}}
line 1220: " Ruby: {{{
line 1221: 
line 1222: hi! link rubyStringDelimiter GruvboxGreen
line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua
line 1224: 
line 1225: " }}}
line 1226: " ObjectiveC: {{{
line 1227: 
line 1228: hi! link objcTypeModifier GruvboxRed
line 1229: hi! link objcDirective GruvboxBlue
line 1230: 
line 1231: " }}}
line 1232: " Go: {{{
line 1233: 
line 1234: hi! link goDirective GruvboxAqua
line 1235: hi! link goConstants GruvboxPurple
line 1236: hi! link goDeclaration GruvboxRed
line 1237: hi! link goDeclType GruvboxBlue
line 1238: hi! link goBuiltins GruvboxOrange
line 1239: 
line 1240: " }}}
line 1241: " Lua: {{{
line 1242: 
line 1243: hi! link luaIn GruvboxRed
line 1244: hi! link luaFunction GruvboxAqua
line 1245: hi! link luaTable GruvboxOrange
line 1246: 
line 1247: " }}}
line 1248: " MoonScript: {{{
line 1249: 
line 1250: hi! link moonSpecialOp GruvboxFg3
line 1251: hi! link moonExtendedOp GruvboxFg3
line 1252: hi! link moonFunction GruvboxFg3
line 1253: hi! link moonObject GruvboxYellow
line 1254: 
line 1255: " }}}
line 1256: " Java: {{{
line 1257: 
line 1258: hi! link javaAnnotation GruvboxBlue
line 1259: hi! link javaDocTags GruvboxAqua
line 1260: hi! link javaCommentTitle vimCommentTitle
line 1261: hi! link javaParen GruvboxFg3
line 1262: hi! link javaParen1 GruvboxFg3
line 1263: hi! link javaParen2 GruvboxFg3
line 1264: hi! link javaParen3 GruvboxFg3
line 1265: hi! link javaParen4 GruvboxFg3
line 1266: hi! link javaParen5 GruvboxFg3
line 1267: hi! link javaOperator GruvboxOrange
line 1268: 
line 1269: hi! link javaVarArg GruvboxGreen
line 1270: 
line 1271: " }}}
line 1272: " Elixir: {{{
line 1273: 
line 1274: hi! link elixirDocString Comment
line 1275: 
line 1276: hi! link elixirStringDelimiter GruvboxGreen
line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua
line 1278: 
line 1279: hi! link elixirModuleDeclaration GruvboxYellow
line 1280: 
line 1281: " }}}
line 1282: " Scala: {{{
line 1283: 
line 1284: " NB: scala vim syntax file is kinda horrible
line 1285: hi! link scalaNameDefinition GruvboxFg1
line 1286: hi! link scalaCaseFollowing GruvboxFg1
line 1287: hi! link scalaCapitalWord GruvboxFg1
line 1288: hi! link scalaTypeExtension GruvboxFg1
line 1289: 
line 1290: hi! link scalaKeyword GruvboxRed
line 1291: hi! link scalaKeywordModifier GruvboxRed
line 1292: 
line 1293: hi! link scalaSpecial GruvboxAqua
line 1294: hi! link scalaOperator GruvboxFg1
line 1295: 
line 1296: hi! link scalaTypeDeclaration GruvboxYellow
line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow
line 1298: 
line 1299: hi! link scalaInstanceDeclaration GruvboxFg1
line 1300: hi! link scalaInterpolation GruvboxAqua
line 1301: 
line 1302: " }}}
line 1303: " Markdown: {{{
line 1304: 
line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)
calling function <SNR>14_HL('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1306: 
line 1307: hi! link markdownH1 GruvboxGreenBold
line 1308: hi! link markdownH2 GruvboxGreenBold
line 1309: hi! link markdownH3 GruvboxYellowBold
line 1310: hi! link markdownH4 GruvboxYellowBold
line 1311: hi! link markdownH5 GruvboxYellow
line 1312: hi! link markdownH6 GruvboxYellow
line 1313: 
line 1314: hi! link markdownCode GruvboxAqua
line 1315: hi! link markdownCodeBlock GruvboxAqua
line 1316: hi! link markdownCodeDelimiter GruvboxAqua
line 1317: 
line 1318: hi! link markdownBlockquote GruvboxGray
line 1319: hi! link markdownListMarker GruvboxGray
line 1320: hi! link markdownOrderedListMarker GruvboxGray
line 1321: hi! link markdownRule GruvboxGray
line 1322: hi! link markdownHeadingRule GruvboxGray
line 1323: 
line 1324: hi! link markdownUrlDelimiter GruvboxFg3
line 1325: hi! link markdownLinkDelimiter GruvboxFg3
line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3
line 1327: 
line 1328: hi! link markdownHeadingDelimiter GruvboxOrange
line 1329: hi! link markdownUrl GruvboxPurple
line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen
line 1331: 
line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)
calling function <SNR>14_HL('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1333: hi! link markdownIdDeclaration markdownLinkText
line 1334: 
line 1335: " }}}
line 1336: " Haskell: {{{
line 1337: 
line 1338: " hi! link haskellType GruvboxYellow
line 1339: " hi! link haskellOperators GruvboxOrange
line 1340: " hi! link haskellConditional GruvboxAqua
line 1341: " hi! link haskellLet GruvboxOrange
line 1342: "
line 1343: hi! link haskellType GruvboxFg1
line 1344: hi! link haskellIdentifier GruvboxFg1
line 1345: hi! link haskellSeparator GruvboxFg1
line 1346: hi! link haskellDelimiter GruvboxFg4
line 1347: hi! link haskellOperators GruvboxBlue
line 1348: "
line 1349: hi! link haskellBacktick GruvboxOrange
line 1350: hi! link haskellStatement GruvboxOrange
line 1351: hi! link haskellConditional GruvboxOrange
line 1352: 
line 1353: hi! link haskellLet GruvboxAqua
line 1354: hi! link haskellDefault GruvboxAqua
line 1355: hi! link haskellWhere GruvboxAqua
line 1356: hi! link haskellBottom GruvboxAqua
line 1357: hi! link haskellBlockKeywords GruvboxAqua
line 1358: hi! link haskellImportKeywords GruvboxAqua
line 1359: hi! link haskellDeclKeyword GruvboxAqua
line 1360: hi! link haskellDeriving GruvboxAqua
line 1361: hi! link haskellAssocType GruvboxAqua
line 1362: 
line 1363: hi! link haskellNumber GruvboxPurple
line 1364: hi! link haskellPragma GruvboxPurple
line 1365: 
line 1366: hi! link haskellString GruvboxGreen
line 1367: hi! link haskellChar GruvboxGreen
line 1368: 
line 1369: " }}}
line 1370: " Json: {{{
line 1371: 
line 1372: hi! link jsonKeyword GruvboxGreen
line 1373: hi! link jsonQuote GruvboxGreen
line 1374: hi! link jsonBraces GruvboxFg1
line 1375: hi! link jsonString GruvboxFg1
line 1376: 
line 1377: " }}}
line 1378: 
line 1379: 
line 1380: " Functions -------------------------------------------------------------------
line 1381: " Search Highlighting Cursor {{{
line 1382: 
line 1383: function! GruvboxHlsShowCursor()
line 1386: 
line 1387: function! GruvboxHlsHideCursor()
line 1390: 
line 1391: " }}}
line 1392: 
line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
finished sourcing /usr/share/vim/vimfiles/colors/gruvbox.vim
continuing in /home/ringu/.vimrc
line 31: 
line 42: let g:lightline = { 'colorscheme': 'one',   'active': {     'left':[ [ 'mode', 'paste' ],              [ 'gitbranch', 'readonly']     ]   },   'component_function': {     'gitbranch': 'fugitive#head',   } }
line 43: 
line 46: let g:lightline.separator = {   'left': '', 'right': ''}
line 49: let g:lightline.subseparator = {   'left': '', 'right': '' }
line 50: 
line 54: let g:lightline.tabline = { 'left': [['tabs','filename']], 'right': [['close']]}
line 55: 
line 59: let g:ale_fixers = { 'javascript': ['eslint'], 'css' : ['prettier'], }
line 60: 
line 63: let g:ale_linters = { 'javascript': ['eslint'], }
line 64: 
line 65: let g:gruvbox_contrast_dark='hard'
line 66: let g:indentLine_char='|'
line 67: 
line 68: set history=200^I^I" keep 200 lines of command line history
line 69: set ruler^I^I" show the cursor position all the time
line 70: set showcmd^I^I" display incomplete commands
line 71: set wildmenu^I^I" display completion matches in a status line
line 72: 
line 73: "show existing tab with 2 spaces width
line 74: set tabstop=2
line 75: set softtabstop=2
line 76: "when indenting with '>' use 2 spaces width
line 77: set shiftwidth=2
line 78: "On pressing tab insert 2 spaces
line 79: set expandtab
line 80: set number
line 81: set visualbell
line 82: set encoding=utf-8
line 83: 
line 84: " Switch syntax highlighting on when the terminal has colors or when using the
line 85: " GUI (which always has colors).
line 86: if &t_Co > 2 || has("gui_running")
line 87:   " Revert with ":syntax off".
line 88:   syntax on
line 88: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 88: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim81/syntax/nosyntax.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 19: colors gruvbox
Searching for "colors/gruvbox.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/ale/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/colors/gruvbox.vim"
Searching for "/usr/share/vim/vimfiles/colors/gruvbox.vim"
chdir(/usr/share/vim/vimfiles/colors)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vimfiles/colors/gruvbox.vim"
line 1: " -----------------------------------------------------------------------------
line 2: " File: gruvbox.vim
line 3: " Description: Retro groove color scheme for Vim
line 4: " Author: morhetz <morhetz@gmail.com>
line 5: " Source: https://github.com/morhetz/gruvbox
line 6: " Last Modified: 12 Aug 2017
line 7: " -----------------------------------------------------------------------------
line 8: 
line 9: " Supporting code -------------------------------------------------------------
line 10: " Initialisation: {{{
line 11: 
line 12: if version > 580
line 13:   hi clear
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 14:   if exists("syntax_on")
line 15:     syntax reset
line 15: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 16:   endif
line 17: endif
line 18: 
line 19: let g:colors_name='gruvbox'
line 20: 
line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256
line 22:   finish
line 23: endif
line 24: 
line 25: " }}}
line 26: " Global Settings: {{{
line 27: 
line 28: if !exists('g:gruvbox_bold')
line 29:   let g:gruvbox_bold=1
line 30: endif
line 31: if !exists('g:gruvbox_italic')
line 32:   if has('gui_running') || $TERM_ITALICS == 'true'
line 33:     let g:gruvbox_italic=1
line 34:   else
line 35:     let g:gruvbox_italic=0
line 36:   endif
line 37: endif
line 38: if !exists('g:gruvbox_undercurl')
line 39:   let g:gruvbox_undercurl=1
line 40: endif
line 41: if !exists('g:gruvbox_underline')
line 42:   let g:gruvbox_underline=1
line 43: endif
line 44: if !exists('g:gruvbox_inverse')
line 45:   let g:gruvbox_inverse=1
line 46: endif
line 47: 
line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
line 49:   let g:gruvbox_guisp_fallback='NONE'
line 50: endif
line 51: 
line 52: if !exists('g:gruvbox_improved_strings')
line 53:   let g:gruvbox_improved_strings=0
line 54: endif
line 55: 
line 56: if !exists('g:gruvbox_improved_warnings')
line 57:   let g:gruvbox_improved_warnings=0
line 58: endif
line 59: 
line 60: if !exists('g:gruvbox_termcolors')
line 61:   let g:gruvbox_termcolors=256
line 62: endif
line 63: 
line 64: if !exists('g:gruvbox_invert_indent_guides')
line 65:   let g:gruvbox_invert_indent_guides=0
line 66: endif
line 67: 
line 68: if exists('g:gruvbox_contrast')
line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
line 70: endif
line 71: 
line 72: if !exists('g:gruvbox_contrast_dark')
line 73:   let g:gruvbox_contrast_dark='medium'
line 74: endif
line 75: 
line 76: if !exists('g:gruvbox_contrast_light')
line 77:   let g:gruvbox_contrast_light='medium'
line 78: endif
line 79: 
line 80: let s:is_dark=(&background == 'dark')
line 81: 
line 82: " }}}
line 83: " Palette: {{{
line 84: 
line 85: " setup palette dictionary
line 86: let s:gb = {}
line 87: 
line 88: " fill it with absolute colors
line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40
line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69
line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
line 97: 
line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
line 100: 
line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132
line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
line 109: 
line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
line 117: 
line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
line 125: 
line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
line 133: 
line 134: " }}}
line 135: " Setup Emphasis: {{{
line 136: 
line 137: let s:bold = 'bold,'
line 138: if g:gruvbox_bold == 0
line 139:   let s:bold = ''
line 140: endif
line 141: 
line 142: let s:italic = 'italic,'
line 143: if g:gruvbox_italic == 0
line 144:   let s:italic = ''
line 145: endif
line 146: 
line 147: let s:underline = 'underline,'
line 148: if g:gruvbox_underline == 0
line 149:   let s:underline = ''
line 150: endif
line 151: 
line 152: let s:undercurl = 'undercurl,'
line 153: if g:gruvbox_undercurl == 0
line 154:   let s:undercurl = ''
line 155: endif
line 156: 
line 157: let s:inverse = 'inverse,'
line 158: if g:gruvbox_inverse == 0
line 159:   let s:inverse = ''
line 160: endif
line 161: 
line 162: " }}}
line 163: " Setup Colors: {{{
line 164: 
line 165: let s:vim_bg = ['bg', 'bg']
line 166: let s:vim_fg = ['fg', 'fg']
line 167: let s:none = ['NONE', 'NONE']
line 168: 
line 169: " determine relative colors
line 170: if s:is_dark
line 171:   let s:bg0  = s:gb.dark0
line 172:   if g:gruvbox_contrast_dark == 'soft'
line 173:     let s:bg0  = s:gb.dark0_soft
line 174:   elseif g:gruvbox_contrast_dark == 'hard'
line 175:     let s:bg0  = s:gb.dark0_hard
line 176:   endif
line 177: 
line 178:   let s:bg1  = s:gb.dark1
line 179:   let s:bg2  = s:gb.dark2
line 180:   let s:bg3  = s:gb.dark3
line 181:   let s:bg4  = s:gb.dark4
line 182: 
line 183:   let s:gray = s:gb.gray_245
line 184: 
line 185:   let s:fg0 = s:gb.light0
line 186:   let s:fg1 = s:gb.light1
line 187:   let s:fg2 = s:gb.light2
line 188:   let s:fg3 = s:gb.light3
line 189:   let s:fg4 = s:gb.light4
line 190: 
line 191:   let s:fg4_256 = s:gb.light4_256
line 192: 
line 193:   let s:red    = s:gb.bright_red
line 194:   let s:green  = s:gb.bright_green
line 195:   let s:yellow = s:gb.bright_yellow
line 196:   let s:blue   = s:gb.bright_blue
line 197:   let s:purple = s:gb.bright_purple
line 198:   let s:aqua   = s:gb.bright_aqua
line 199:   let s:orange = s:gb.bright_orange
line 200: else
line 201:   let s:bg0  = s:gb.light0
line 202:   if g:gruvbox_contrast_light == 'soft'
line 203:     let s:bg0  = s:gb.light0_soft
line 204:   elseif g:gruvbox_contrast_light == 'hard'
line 205:     let s:bg0  = s:gb.light0_hard
line 206:   endif
line 207: 
line 208:   let s:bg1  = s:gb.light1
line 209:   let s:bg2  = s:gb.light2
line 210:   let s:bg3  = s:gb.light3
line 211:   let s:bg4  = s:gb.light4
line 212: 
line 213:   let s:gray = s:gb.gray_244
line 214: 
line 215:   let s:fg0 = s:gb.dark0
line 216:   let s:fg1 = s:gb.dark1
line 217:   let s:fg2 = s:gb.dark2
line 218:   let s:fg3 = s:gb.dark3
line 219:   let s:fg4 = s:gb.dark4
line 220: 
line 221:   let s:fg4_256 = s:gb.dark4_256
line 222: 
line 223:   let s:red    = s:gb.faded_red
line 224:   let s:green  = s:gb.faded_green
line 225:   let s:yellow = s:gb.faded_yellow
line 226:   let s:blue   = s:gb.faded_blue
line 227:   let s:purple = s:gb.faded_purple
line 228:   let s:aqua   = s:gb.faded_aqua
line 229:   let s:orange = s:gb.faded_orange
line 230: endif
line 231: 
line 232: " reset to 16 colors fallback
line 233: if g:gruvbox_termcolors == 16
line 234:   let s:bg0[1]    = 0
line 235:   let s:fg4[1]    = 7
line 236:   let s:gray[1]   = 8
line 237:   let s:red[1]    = 9
line 238:   let s:green[1]  = 10
line 239:   let s:yellow[1] = 11
line 240:   let s:blue[1]   = 12
line 241:   let s:purple[1] = 13
line 242:   let s:aqua[1]   = 14
line 243:   let s:fg1[1]    = 15
line 244: endif
line 245: 
line 246: " save current relative colors back to palette dictionary
line 247: let s:gb.bg0 = s:bg0
line 248: let s:gb.bg1 = s:bg1
line 249: let s:gb.bg2 = s:bg2
line 250: let s:gb.bg3 = s:bg3
line 251: let s:gb.bg4 = s:bg4
line 252: 
line 253: let s:gb.gray = s:gray
line 254: 
line 255: let s:gb.fg0 = s:fg0
line 256: let s:gb.fg1 = s:fg1
line 257: let s:gb.fg2 = s:fg2
line 258: let s:gb.fg3 = s:fg3
line 259: let s:gb.fg4 = s:fg4
line 260: 
line 261: let s:gb.fg4_256 = s:fg4_256
line 262: 
line 263: let s:gb.red    = s:red
line 264: let s:gb.green  = s:green
line 265: let s:gb.yellow = s:yellow
line 266: let s:gb.blue   = s:blue
line 267: let s:gb.purple = s:purple
line 268: let s:gb.aqua   = s:aqua
line 269: let s:gb.orange = s:orange
line 270: 
line 271: " }}}
line 272: " Setup Terminal Colors For Neovim: {{{
line 273: 
line 274: if has('nvim')
line 275:   let g:terminal_color_0 = s:bg0[0]
line 276:   let g:terminal_color_8 = s:gray[0]
line 277: 
line 278:   let g:terminal_color_1 = s:gb.neutral_red[0]
line 279:   let g:terminal_color_9 = s:red[0]
line 280: 
line 281:   let g:terminal_color_2 = s:gb.neutral_green[0]
line 282:   let g:terminal_color_10 = s:green[0]
line 283: 
line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0]
line 285:   let g:terminal_color_11 = s:yellow[0]
line 286: 
line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0]
line 288:   let g:terminal_color_12 = s:blue[0]
line 289: 
line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0]
line 291:   let g:terminal_color_13 = s:purple[0]
line 292: 
line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0]
line 294:   let g:terminal_color_14 = s:aqua[0]
line 295: 
line 296:   let g:terminal_color_7 = s:fg4[0]
line 297:   let g:terminal_color_15 = s:fg1[0]
line 298: endif
line 299: 
line 300: " }}}
line 301: " Overload Setting: {{{
line 302: 
line 303: let s:hls_cursor = s:orange
line 304: if exists('g:gruvbox_hls_cursor')
line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
line 306: endif
line 307: 
line 308: let s:number_column = s:none
line 309: if exists('g:gruvbox_number_column')
line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)
line 311: endif
line 312: 
line 313: let s:sign_column = s:bg1
line 314: 
line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1
line 317:   let s:sign_column = s:number_column
line 318: else
line 319:   let g:gitgutter_override_sign_column_highlight = 0
line 320: 
line 321:   if exists('g:gruvbox_sign_column')
line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)
line 323:   endif
line 324: endif
line 325: 
line 326: let s:color_column = s:bg1
line 327: if exists('g:gruvbox_color_column')
line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)
line 329: endif
line 330: 
line 331: let s:vert_split = s:bg0
line 332: if exists('g:gruvbox_vert_split')
line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)
line 334: endif
line 335: 
line 336: let s:invert_signs = ''
line 337: if exists('g:gruvbox_invert_signs')
line 338:   if g:gruvbox_invert_signs == 1
line 339:     let s:invert_signs = s:inverse
line 340:   endif
line 341: endif
line 342: 
line 343: let s:invert_selection = s:inverse
line 344: if exists('g:gruvbox_invert_selection')
line 345:   if g:gruvbox_invert_selection == 0
line 346:     let s:invert_selection = ''
line 347:   endif
line 348: endif
line 349: 
line 350: let s:invert_tabline = ''
line 351: if exists('g:gruvbox_invert_tabline')
line 352:   if g:gruvbox_invert_tabline == 1
line 353:     let s:invert_tabline = s:inverse
line 354:   endif
line 355: endif
line 356: 
line 357: let s:italicize_comments = s:italic
line 358: if exists('g:gruvbox_italicize_comments')
line 359:   if g:gruvbox_italicize_comments == 0
line 360:     let s:italicize_comments = ''
line 361:   endif
line 362: endif
line 363: 
line 364: let s:italicize_strings = ''
line 365: if exists('g:gruvbox_italicize_strings')
line 366:   if g:gruvbox_italicize_strings == 1
line 367:     let s:italicize_strings = s:italic
line 368:   endif
line 369: endif
line 370: 
line 371: " }}}
line 372: " Highlighting Function: {{{
line 373: 
line 374: function! s:HL(group, fg, ...)
line 419: 
line 420: " }}}
line 421: " Gruvbox Hi Groups: {{{
line 422: 
line 423: " memoize common hi groups
line 424: call s:HL('GruvboxFg0', s:fg0)
calling function <SNR>14_HL('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 425: call s:HL('GruvboxFg1', s:fg1)
calling function <SNR>14_HL('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 426: call s:HL('GruvboxFg2', s:fg2)
calling function <SNR>14_HL('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 427: call s:HL('GruvboxFg3', s:fg3)
calling function <SNR>14_HL('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 428: call s:HL('GruvboxFg4', s:fg4)
calling function <SNR>14_HL('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 429: call s:HL('GruvboxGray', s:gray)
calling function <SNR>14_HL('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 430: call s:HL('GruvboxBg0', s:bg0)
calling function <SNR>14_HL('GruvboxBg0', ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg0 guifg=#1d2021 ctermfg=234 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 431: call s:HL('GruvboxBg1', s:bg1)
calling function <SNR>14_HL('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 432: call s:HL('GruvboxBg2', s:bg2)
calling function <SNR>14_HL('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 433: call s:HL('GruvboxBg3', s:bg3)
calling function <SNR>14_HL('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 434: call s:HL('GruvboxBg4', s:bg4)
calling function <SNR>14_HL('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 435: 
line 436: call s:HL('GruvboxRed', s:red)
calling function <SNR>14_HL('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
calling function <SNR>14_HL('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 438: call s:HL('GruvboxGreen', s:green)
calling function <SNR>14_HL('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
calling function <SNR>14_HL('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 440: call s:HL('GruvboxYellow', s:yellow)
calling function <SNR>14_HL('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
calling function <SNR>14_HL('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 442: call s:HL('GruvboxBlue', s:blue)
calling function <SNR>14_HL('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
calling function <SNR>14_HL('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 444: call s:HL('GruvboxPurple', s:purple)
calling function <SNR>14_HL('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
calling function <SNR>14_HL('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 446: call s:HL('GruvboxAqua', s:aqua)
calling function <SNR>14_HL('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
calling function <SNR>14_HL('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 448: call s:HL('GruvboxOrange', s:orange)
calling function <SNR>14_HL('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
calling function <SNR>14_HL('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 450: 
line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 457: 
line 458: " }}}
line 459: 
line 460: " Vanilla colorscheme ---------------------------------------------------------
line 461: " General UI: {{{
line 462: 
line 463: " Normal text
line 464: call s:HL('Normal', s:fg1, s:bg0)
calling function <SNR>14_HL('Normal', ['#ebdbb2', 223], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 465: 
line 466: " Correct background (see issue #7):
line 467: " --- Problem with changing between dark and light on 256 color terminal
line 468: " --- https://github.com/morhetz/gruvbox/issues/7
line 469: if s:is_dark
line 470:   set background=dark
line 471: else
line 472:   set background=light
line 473: endif
line 474: 
line 475: if version >= 700
line 476:   " Screen line that the cursor is
line 477:   call s:HL('CursorLine',   s:none, s:bg1)
calling function <SNR>14_HL('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 478:   " Screen column that the cursor is
line 479:   hi! link CursorColumn CursorLine
line 480: 
line 481:   " Tab pages line filler
line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 483:   " Active tab page label
line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 485:   " Not active tab page label
line 486:   hi! link TabLine TabLineFill
line 487: 
line 488:   " Match paired bracket under the cursor
line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)
calling function <SNR>14_HL('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 490: endif
line 491: 
line 492: if version >= 703
line 493:   " Highlighted screen columns
line 494:   call s:HL('ColorColumn',  s:none, s:color_column)
calling function <SNR>14_HL('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 495: 
line 496:   " Concealed element: \lambda  
line 497:   call s:HL('Conceal', s:blue, s:none)
calling function <SNR>14_HL('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 498: 
line 499:   " Line number of CursorLine
line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)
calling function <SNR>14_HL('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 501: endif
line 502: 
line 503: hi! link NonText GruvboxBg2
line 504: hi! link SpecialKey GruvboxBg2
line 505: 
line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
calling function <SNR>14_HL('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 507: hi! link VisualNOS Visual
line 508: 
line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('Search', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
calling function <SNR>14_HL('IncSearch', ['#fe8019', 208], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 511: 
line 512: call s:HL('Underlined', s:blue, s:none, s:underline)
calling function <SNR>14_HL('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 513: 
line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)
calling function <SNR>14_HL('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)
calling function <SNR>14_HL('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 516: 
line 517: " The column separating vertically split windows
line 518: call s:HL('VertSplit', s:bg3, s:vert_split)
calling function <SNR>14_HL('VertSplit', ['#665c54', 241], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 519: 
line 520: " Current match in wildmenu completion
line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 522: 
line 523: " Directory names, special names in listing
line 524: hi! link Directory GruvboxGreenBold
line 525: 
line 526: " Titles for output from :set all, :autocmd, etc.
line 527: hi! link Title GruvboxGreenBold
line 528: 
line 529: " Error messages on the command line
line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
calling function <SNR>14_HL('ErrorMsg', ['#1d2021', 234], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ErrorMsg guifg=#1d2021 ctermfg=234 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 531: " More prompt: -- More --
line 532: hi! link MoreMsg GruvboxYellowBold
line 533: " Current mode message: -- INSERT --
line 534: hi! link ModeMsg GruvboxYellowBold
line 535: " 'Press enter' prompt and yes/no questions
line 536: hi! link Question GruvboxOrangeBold
line 537: " Warning messages
line 538: hi! link WarningMsg GruvboxRedBold
line 539: 
line 540: " }}}
line 541: " Gutter: {{{
line 542: 
line 543: " Line number for :number and :# commands
line 544: call s:HL('LineNr', s:bg4, s:number_column)
calling function <SNR>14_HL('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 545: 
line 546: " Column where signs are displayed
line 547: call s:HL('SignColumn', s:none, s:sign_column)
calling function <SNR>14_HL('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 548: 
line 549: " Line used for closed folds
line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)
calling function <SNR>14_HL('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 551: " Column where folds are displayed
line 552: call s:HL('FoldColumn', s:gray, s:bg1)
calling function <SNR>14_HL('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 553: 
line 554: " }}}
line 555: " Cursor: {{{
line 556: 
line 557: " Character under cursor
line 558: call s:HL('Cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 559: " Visual mode cursor, selection
line 560: hi! link vCursor Cursor
line 561: " Input moder cursor
line 562: hi! link iCursor Cursor
line 563: " Language mapping cursor
line 564: hi! link lCursor Cursor
line 565: 
line 566: " }}}
line 567: " Syntax Highlighting: {{{
line 568: 
line 569: if g:gruvbox_improved_strings == 0
line 570:   hi! link Special GruvboxOrange
line 571: else
line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)
line 573: endif
line 574: 
line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)
calling function <SNR>14_HL('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
calling function <SNR>14_HL('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 578: 
line 579: " Generic statement
line 580: hi! link Statement GruvboxRed
line 581: " if, then, else, endif, swicth, etc.
line 582: hi! link Conditional GruvboxRed
line 583: " for, do, while, etc.
line 584: hi! link Repeat GruvboxRed
line 585: " case, default, etc.
line 586: hi! link Label GruvboxRed
line 587: " try, catch, throw
line 588: hi! link Exception GruvboxRed
line 589: " sizeof, "+", "*", etc.
line 590: hi! link Operator Normal
line 591: " Any other keyword
line 592: hi! link Keyword GruvboxRed
line 593: 
line 594: " Variable name
line 595: hi! link Identifier GruvboxBlue
line 596: " Function name
line 597: hi! link Function GruvboxGreenBold
line 598: 
line 599: " Generic preprocessor
line 600: hi! link PreProc GruvboxAqua
line 601: " Preprocessor #include
line 602: hi! link Include GruvboxAqua
line 603: " Preprocessor #define
line 604: hi! link Define GruvboxAqua
line 605: " Same as Define
line 606: hi! link Macro GruvboxAqua
line 607: " Preprocessor #if, #else, #endif, etc.
line 608: hi! link PreCondit GruvboxAqua
line 609: 
line 610: " Generic constant
line 611: hi! link Constant GruvboxPurple
line 612: " Character constant: 'c', '/n'
line 613: hi! link Character GruvboxPurple
line 614: " String constant: "this is a string"
line 615: if g:gruvbox_improved_strings == 0
line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)
calling function <SNR>14_HL('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 617: else
line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)
line 619: endif
line 620: " Boolean constant: TRUE, false
line 621: hi! link Boolean GruvboxPurple
line 622: " Number constant: 234, 0xff
line 623: hi! link Number GruvboxPurple
line 624: " Floating point constant: 2.3e10
line 625: hi! link Float GruvboxPurple
line 626: 
line 627: " Generic type
line 628: hi! link Type GruvboxYellow
line 629: " static, register, volatile, etc
line 630: hi! link StorageClass GruvboxOrange
line 631: " struct, union, enum, etc.
line 632: hi! link Structure GruvboxAqua
line 633: " typedef
line 634: hi! link Typedef GruvboxYellow
line 635: 
line 636: " }}}
line 637: " Completion Menu: {{{
line 638: 
line 639: if version >= 700
line 640:   " Popup menu: normal item
line 641:   call s:HL('Pmenu', s:fg1, s:bg2)
calling function <SNR>14_HL('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 642:   " Popup menu: selected item
line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
calling function <SNR>14_HL('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 644:   " Popup menu: scrollbar
line 645:   call s:HL('PmenuSbar', s:none, s:bg2)
calling function <SNR>14_HL('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 646:   " Popup menu: scrollbar thumb
line 647:   call s:HL('PmenuThumb', s:none, s:bg4)
calling function <SNR>14_HL('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 648: endif
line 649: 
line 650: " }}}
line 651: " Diffs: {{{
line 652: 
line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffDelete', ['#fb4934', 167], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffAdd', ['#b8bb26', 142], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 655: "call s:HL('DiffChange', s:bg0, s:blue)
line 656: "call s:HL('DiffText',   s:bg0, s:yellow)
line 657: 
line 658: " Alternative setting
line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffChange', ['#8ec07c', 108], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffText', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 661: 
line 662: " }}}
line 663: " Spelling: {{{
line 664: 
line 665: if has("spell")
line 666:   " Not capitalised word, or compile warnings
line 667:   if g:gruvbox_improved_warnings == 0
line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 669:   else
line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
line 671:   endif
line 672:   " Not recognized word
line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 674:   " Wrong spelling for selected region
line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
calling function <SNR>14_HL('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 676:   " Rare word
line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
calling function <SNR>14_HL('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 678: endif
line 679: 
line 680: " }}}
line 681: 
line 682: " Plugin specific -------------------------------------------------------------
line 683: " EasyMotion: {{{
line 684: 
line 685: hi! link EasyMotionTarget Search
line 686: hi! link EasyMotionShade Comment
line 687: 
line 688: " }}}
line 689: " Sneak: {{{
line 690: 
line 691: hi! link Sneak Search
line 692: hi! link SneakLabel Search
line 693: 
line 694: " }}}
line 695: " Indent Guides: {{{
line 696: 
line 697: if !exists('g:indent_guides_auto_colors')
line 698:   let g:indent_guides_auto_colors = 0
line 699: endif
line 700: 
line 701: if g:indent_guides_auto_colors == 0
line 702:   if g:gruvbox_invert_indent_guides == 0
line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
calling function <SNR>14_HL('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
calling function <SNR>14_HL('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 705:   else
line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
line 708:   endif
line 709: endif
line 710: 
line 711: " }}}
line 712: " IndentLine: {{{
line 713: 
line 714: if !exists('g:indentLine_color_term')
line 715:   let g:indentLine_color_term = s:bg2[1]
line 716: endif
line 717: if !exists('g:indentLine_color_gui')
line 718:   let g:indentLine_color_gui = s:bg2[0]
line 719: endif
line 720: 
line 721: " }}}
line 722: " Rainbow Parentheses: {{{
line 723: 
line 724: if !exists('g:rbpt_colorpairs')
line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ]
line 730: endif
line 731: 
line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
line 734: 
line 735: if !exists('g:rainbow_conf')
line 736:    let g:rainbow_conf = {}
line 737: endif
line 738: if !has_key(g:rainbow_conf, 'guifgs')
line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
line 740: endif
line 741: if !has_key(g:rainbow_conf, 'ctermfgs')
line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
line 743: endif
line 744: 
line 745: let g:niji_dark_colours = g:rbpt_colorpairs
line 746: let g:niji_light_colours = g:rbpt_colorpairs
line 747: 
line 748: "}}}
line 749: " GitGutter: {{{
line 750: 
line 751: hi! link GitGutterAdd GruvboxGreenSign
line 752: hi! link GitGutterChange GruvboxAquaSign
line 753: hi! link GitGutterDelete GruvboxRedSign
line 754: hi! link GitGutterChangeDelete GruvboxAquaSign
line 755: 
line 756: " }}}
line 757: " GitCommit: "{{{
line 758: 
line 759: hi! link gitcommitSelectedFile GruvboxGreen
line 760: hi! link gitcommitDiscardedFile GruvboxRed
line 761: 
line 762: " }}}
line 763: " Signify: {{{
line 764: 
line 765: hi! link SignifySignAdd GruvboxGreenSign
line 766: hi! link SignifySignChange GruvboxAquaSign
line 767: hi! link SignifySignDelete GruvboxRedSign
line 768: 
line 769: " }}}
line 770: " Syntastic: {{{
line 771: 
line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 774: 
line 775: hi! link SyntasticErrorSign GruvboxRedSign
line 776: hi! link SyntasticWarningSign GruvboxYellowSign
line 777: 
line 778: " }}}
line 779: " Signature: {{{
line 780: hi! link SignatureMarkText   GruvboxBlueSign
line 781: hi! link SignatureMarkerText GruvboxPurpleSign
line 782: 
line 783: " }}}
line 784: " ShowMarks: {{{
line 785: 
line 786: hi! link ShowMarksHLl GruvboxBlueSign
line 787: hi! link ShowMarksHLu GruvboxBlueSign
line 788: hi! link ShowMarksHLo GruvboxBlueSign
line 789: hi! link ShowMarksHLm GruvboxBlueSign
line 790: 
line 791: " }}}
line 792: " CtrlP: {{{
line 793: 
line 794: hi! link CtrlPMatch GruvboxYellow
line 795: hi! link CtrlPNoEntries GruvboxRed
line 796: hi! link CtrlPPrtBase GruvboxBg2
line 797: hi! link CtrlPPrtCursor GruvboxBlue
line 798: hi! link CtrlPLinePre GruvboxBg2
line 799: 
line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
calling function <SNR>14_HL('CtrlPMode2', ['#1d2021', 234], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode2 guifg=#1d2021 ctermfg=234 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 803: 
line 804: " }}}
line 805: " Startify: {{{
line 806: 
line 807: hi! link StartifyBracket GruvboxFg3
line 808: hi! link StartifyFile GruvboxFg1
line 809: hi! link StartifyNumber GruvboxBlue
line 810: hi! link StartifyPath GruvboxGray
line 811: hi! link StartifySlash GruvboxGray
line 812: hi! link StartifySection GruvboxYellow
line 813: hi! link StartifySpecial GruvboxBg2
line 814: hi! link StartifyHeader GruvboxOrange
line 815: hi! link StartifyFooter GruvboxBg2
line 816: 
line 817: " }}}
line 818: " Vimshell: {{{
line 819: 
line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ]
line 826: 
line 827: " }}}
line 828: " BufTabLine: {{{
line 829: 
line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
calling function <SNR>14_HL('BufTabLineCurrent', ['#1d2021', 234], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineCurrent guifg=#1d2021 ctermfg=234 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)
calling function <SNR>14_HL('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)
calling function <SNR>14_HL('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)
calling function <SNR>14_HL('BufTabLineFill', ['#1d2021', 234], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineFill guifg=#1d2021 ctermfg=234 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 834: 
line 835: " }}}
line 836: " Asynchronous Lint Engine: {{{
line 837: 
line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 841: 
line 842: hi! link ALEErrorSign GruvboxRedSign
line 843: hi! link ALEWarningSign GruvboxYellowSign
line 844: hi! link ALEInfoSign GruvboxBlueSign
line 845: 
line 846: " }}}
line 847: " Dirvish: {{{
line 848: 
line 849: hi! link DirvishPathTail GruvboxAqua
line 850: hi! link DirvishArg GruvboxYellow
line 851: 
line 852: " }}}
line 853: " Netrw: {{{
line 854: 
line 855: hi! link netrwDir GruvboxAqua
line 856: hi! link netrwClassify GruvboxAqua
line 857: hi! link netrwLink GruvboxGray
line 858: hi! link netrwSymLink GruvboxFg1
line 859: hi! link netrwExe GruvboxYellow
line 860: hi! link netrwComment GruvboxGray
line 861: hi! link netrwList GruvboxBlue
line 862: hi! link netrwHelpCmd GruvboxAqua
line 863: hi! link netrwCmdSep GruvboxFg3
line 864: hi! link netrwVersion GruvboxGreen
line 865: 
line 866: " }}}
line 867: " NERDTree: {{{
line 868: 
line 869: hi! link NERDTreeDir GruvboxAqua
line 870: hi! link NERDTreeDirSlash GruvboxAqua
line 871: 
line 872: hi! link NERDTreeOpenable GruvboxOrange
line 873: hi! link NERDTreeClosable GruvboxOrange
line 874: 
line 875: hi! link NERDTreeFile GruvboxFg1
line 876: hi! link NERDTreeExecFile GruvboxYellow
line 877: 
line 878: hi! link NERDTreeUp GruvboxGray
line 879: hi! link NERDTreeCWD GruvboxGreen
line 880: hi! link NERDTreeHelp GruvboxFg1
line 881: 
line 882: hi! link NERDTreeToggleOn GruvboxGreen
line 883: hi! link NERDTreeToggleOff GruvboxRed
line 884: 
line 885: " }}}
line 886: " Vim Multiple Cursors: {{{
line 887: 
line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)
calling function <SNR>14_HL('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 890: 
line 891: " }}}
line 892: 
line 893: " Filetype specific -----------------------------------------------------------
line 894: " Diff: {{{
line 895: 
line 896: hi! link diffAdded GruvboxGreen
line 897: hi! link diffRemoved GruvboxRed
line 898: hi! link diffChanged GruvboxAqua
line 899: 
line 900: hi! link diffFile GruvboxOrange
line 901: hi! link diffNewFile GruvboxYellow
line 902: 
line 903: hi! link diffLine GruvboxBlue
line 904: 
line 905: " }}}
line 906: " Html: {{{
line 907: 
line 908: hi! link htmlTag GruvboxBlue
line 909: hi! link htmlEndTag GruvboxBlue
line 910: 
line 911: hi! link htmlTagName GruvboxAquaBold
line 912: hi! link htmlArg GruvboxAqua
line 913: 
line 914: hi! link htmlScriptTag GruvboxPurple
line 915: hi! link htmlTagN GruvboxFg1
line 916: hi! link htmlSpecialTagName GruvboxAquaBold
line 917: 
line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)
calling function <SNR>14_HL('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 919: 
line 920: hi! link htmlSpecialChar GruvboxOrange
line 921: 
line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
calling function <SNR>14_HL('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
calling function <SNR>14_HL('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
calling function <SNR>14_HL('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 926: 
line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
calling function <SNR>14_HL('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
calling function <SNR>14_HL('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
calling function <SNR>14_HL('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 930: 
line 931: " }}}
line 932: " Xml: {{{
line 933: 
line 934: hi! link xmlTag GruvboxBlue
line 935: hi! link xmlEndTag GruvboxBlue
line 936: hi! link xmlTagName GruvboxBlue
line 937: hi! link xmlEqual GruvboxBlue
line 938: hi! link docbkKeyword GruvboxAquaBold
line 939: 
line 940: hi! link xmlDocTypeDecl GruvboxGray
line 941: hi! link xmlDocTypeKeyword GruvboxPurple
line 942: hi! link xmlCdataStart GruvboxGray
line 943: hi! link xmlCdataCdata GruvboxPurple
line 944: hi! link dtdFunction GruvboxGray
line 945: hi! link dtdTagName GruvboxPurple
line 946: 
line 947: hi! link xmlAttrib GruvboxAqua
line 948: hi! link xmlProcessingDelim GruvboxGray
line 949: hi! link dtdParamEntityPunct GruvboxGray
line 950: hi! link dtdParamEntityDPunct GruvboxGray
line 951: hi! link xmlAttribPunct GruvboxGray
line 952: 
line 953: hi! link xmlEntity GruvboxOrange
line 954: hi! link xmlEntityPunct GruvboxOrange
line 955: " }}}
line 956: " Vim: {{{
line 957: 
line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
calling function <SNR>14_HL('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 959: 
line 960: hi! link vimNotation GruvboxOrange
line 961: hi! link vimBracket GruvboxOrange
line 962: hi! link vimMapModKey GruvboxOrange
line 963: hi! link vimFuncSID GruvboxFg3
line 964: hi! link vimSetSep GruvboxFg3
line 965: hi! link vimSep GruvboxFg3
line 966: hi! link vimContinue GruvboxFg3
line 967: 
line 968: " }}}
line 969: " Clojure: {{{
line 970: 
line 971: hi! link clojureKeyword GruvboxBlue
line 972: hi! link clojureCond GruvboxOrange
line 973: hi! link clojureSpecial GruvboxOrange
line 974: hi! link clojureDefine GruvboxOrange
line 975: 
line 976: hi! link clojureFunc GruvboxYellow
line 977: hi! link clojureRepeat GruvboxYellow
line 978: hi! link clojureCharacter GruvboxAqua
line 979: hi! link clojureStringEscape GruvboxAqua
line 980: hi! link clojureException GruvboxRed
line 981: 
line 982: hi! link clojureRegexp GruvboxAqua
line 983: hi! link clojureRegexpEscape GruvboxAqua
line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
calling function <SNR>14_HL('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 985: hi! link clojureRegexpMod clojureRegexpCharClass
line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass
line 987: 
line 988: hi! link clojureParen GruvboxFg3
line 989: hi! link clojureAnonArg GruvboxYellow
line 990: hi! link clojureVariable GruvboxBlue
line 991: hi! link clojureMacro GruvboxOrange
line 992: 
line 993: hi! link clojureMeta GruvboxYellow
line 994: hi! link clojureDeref GruvboxYellow
line 995: hi! link clojureQuote GruvboxYellow
line 996: hi! link clojureUnquote GruvboxYellow
line 997: 
line 998: " }}}
line 999: " C: {{{
line 1000: 
line 1001: hi! link cOperator GruvboxPurple
line 1002: hi! link cStructure GruvboxOrange
line 1003: 
line 1004: " }}}
line 1005: " Python: {{{
line 1006: 
line 1007: hi! link pythonBuiltin GruvboxOrange
line 1008: hi! link pythonBuiltinObj GruvboxOrange
line 1009: hi! link pythonBuiltinFunc GruvboxOrange
line 1010: hi! link pythonFunction GruvboxAqua
line 1011: hi! link pythonDecorator GruvboxRed
line 1012: hi! link pythonInclude GruvboxBlue
line 1013: hi! link pythonImport GruvboxBlue
line 1014: hi! link pythonRun GruvboxBlue
line 1015: hi! link pythonCoding GruvboxBlue
line 1016: hi! link pythonOperator GruvboxRed
line 1017: hi! link pythonException GruvboxRed
line 1018: hi! link pythonExceptions GruvboxPurple
line 1019: hi! link pythonBoolean GruvboxPurple
line 1020: hi! link pythonDot GruvboxFg3
line 1021: hi! link pythonConditional GruvboxRed
line 1022: hi! link pythonRepeat GruvboxRed
line 1023: hi! link pythonDottedName GruvboxGreenBold
line 1024: 
line 1025: " }}}
line 1026: " CSS: {{{
line 1027: 
line 1028: hi! link cssBraces GruvboxBlue
line 1029: hi! link cssFunctionName GruvboxYellow
line 1030: hi! link cssIdentifier GruvboxOrange
line 1031: hi! link cssClassName GruvboxGreen
line 1032: hi! link cssColor GruvboxBlue
line 1033: hi! link cssSelectorOp GruvboxBlue
line 1034: hi! link cssSelectorOp2 GruvboxBlue
line 1035: hi! link cssImportant GruvboxGreen
line 1036: hi! link cssVendor GruvboxFg1
line 1037: 
line 1038: hi! link cssTextProp GruvboxAqua
line 1039: hi! link cssAnimationProp GruvboxAqua
line 1040: hi! link cssUIProp GruvboxYellow
line 1041: hi! link cssTransformProp GruvboxAqua
line 1042: hi! link cssTransitionProp GruvboxAqua
line 1043: hi! link cssPrintProp GruvboxAqua
line 1044: hi! link cssPositioningProp GruvboxYellow
line 1045: hi! link cssBoxProp GruvboxAqua
line 1046: hi! link cssFontDescriptorProp GruvboxAqua
line 1047: hi! link cssFlexibleBoxProp GruvboxAqua
line 1048: hi! link cssBorderOutlineProp GruvboxAqua
line 1049: hi! link cssBackgroundProp GruvboxAqua
line 1050: hi! link cssMarginProp GruvboxAqua
line 1051: hi! link cssListProp GruvboxAqua
line 1052: hi! link cssTableProp GruvboxAqua
line 1053: hi! link cssFontProp GruvboxAqua
line 1054: hi! link cssPaddingProp GruvboxAqua
line 1055: hi! link cssDimensionProp GruvboxAqua
line 1056: hi! link cssRenderProp GruvboxAqua
line 1057: hi! link cssColorProp GruvboxAqua
line 1058: hi! link cssGeneratedContentProp GruvboxAqua
line 1059: 
line 1060: " }}}
line 1061: " JavaScript: {{{
line 1062: 
line 1063: hi! link javaScriptBraces GruvboxFg1
line 1064: hi! link javaScriptFunction GruvboxAqua
line 1065: hi! link javaScriptIdentifier GruvboxRed
line 1066: hi! link javaScriptMember GruvboxBlue
line 1067: hi! link javaScriptNumber GruvboxPurple
line 1068: hi! link javaScriptNull GruvboxPurple
line 1069: hi! link javaScriptParens GruvboxFg3
line 1070: 
line 1071: " }}}
line 1072: " YAJS: {{{
line 1073: 
line 1074: hi! link javascriptImport GruvboxAqua
line 1075: hi! link javascriptExport GruvboxAqua
line 1076: hi! link javascriptClassKeyword GruvboxAqua
line 1077: hi! link javascriptClassExtends GruvboxAqua
line 1078: hi! link javascriptDefault GruvboxAqua
line 1079: 
line 1080: hi! link javascriptClassName GruvboxYellow
line 1081: hi! link javascriptClassSuperName GruvboxYellow
line 1082: hi! link javascriptGlobal GruvboxYellow
line 1083: 
line 1084: hi! link javascriptEndColons GruvboxFg1
line 1085: hi! link javascriptFuncArg GruvboxFg1
line 1086: hi! link javascriptGlobalMethod GruvboxFg1
line 1087: hi! link javascriptNodeGlobal GruvboxFg1
line 1088: hi! link javascriptBOMWindowProp GruvboxFg1
line 1089: hi! link javascriptArrayMethod GruvboxFg1
line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1
line 1091: hi! link javascriptCacheMethod GruvboxFg1
line 1092: hi! link javascriptDateMethod GruvboxFg1
line 1093: hi! link javascriptMathStaticMethod GruvboxFg1
line 1094: 
line 1095: " hi! link javascriptProp GruvboxFg1
line 1096: hi! link javascriptURLUtilsProp GruvboxFg1
line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1
line 1098: hi! link javascriptDOMDocMethod GruvboxFg1
line 1099: hi! link javascriptDOMDocProp GruvboxFg1
line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1
line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1
line 1102: hi! link javascriptStringMethod GruvboxFg1
line 1103: 
line 1104: hi! link javascriptVariable GruvboxOrange
line 1105: " hi! link javascriptVariable GruvboxRed
line 1106: " hi! link javascriptIdentifier GruvboxOrange
line 1107: " hi! link javascriptClassSuper GruvboxOrange
line 1108: hi! link javascriptIdentifier GruvboxOrange
line 1109: hi! link javascriptClassSuper GruvboxOrange
line 1110: 
line 1111: " hi! link javascriptFuncKeyword GruvboxOrange
line 1112: " hi! link javascriptAsyncFunc GruvboxOrange
line 1113: hi! link javascriptFuncKeyword GruvboxAqua
line 1114: hi! link javascriptAsyncFunc GruvboxAqua
line 1115: hi! link javascriptClassStatic GruvboxOrange
line 1116: 
line 1117: hi! link javascriptOperator GruvboxRed
line 1118: hi! link javascriptForOperator GruvboxRed
line 1119: hi! link javascriptYield GruvboxRed
line 1120: hi! link javascriptExceptions GruvboxRed
line 1121: hi! link javascriptMessage GruvboxRed
line 1122: 
line 1123: hi! link javascriptTemplateSB GruvboxAqua
line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1
line 1125: 
line 1126: " hi! link javascriptLabel GruvboxBlue
line 1127: " hi! link javascriptObjectLabel GruvboxBlue
line 1128: " hi! link javascriptPropertyName GruvboxBlue
line 1129: hi! link javascriptLabel GruvboxFg1
line 1130: hi! link javascriptObjectLabel GruvboxFg1
line 1131: hi! link javascriptPropertyName GruvboxFg1
line 1132: 
line 1133: hi! link javascriptLogicSymbols GruvboxFg1
line 1134: hi! link javascriptArrowFunc GruvboxYellow
line 1135: 
line 1136: hi! link javascriptDocParamName GruvboxFg4
line 1137: hi! link javascriptDocTags GruvboxFg4
line 1138: hi! link javascriptDocNotation GruvboxFg4
line 1139: hi! link javascriptDocParamType GruvboxFg4
line 1140: hi! link javascriptDocNamedParamType GruvboxFg4
line 1141: 
line 1142: hi! link javascriptBrackets GruvboxFg1
line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1
line 1144: hi! link javascriptDOMEventMethod GruvboxFg1
line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1
line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1
line 1147: hi! link javascriptHeadersMethod GruvboxFg1
line 1148: 
line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed
line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed
line 1151: 
line 1152: " }}}
line 1153: " PanglossJS: {{{
line 1154: 
line 1155: hi! link jsClassKeyword GruvboxAqua
line 1156: hi! link jsExtendsKeyword GruvboxAqua
line 1157: hi! link jsExportDefault GruvboxAqua
line 1158: hi! link jsTemplateBraces GruvboxAqua
line 1159: hi! link jsGlobalNodeObjects GruvboxFg1
line 1160: hi! link jsGlobalObjects GruvboxFg1
line 1161: hi! link jsFunction GruvboxAqua
line 1162: hi! link jsFuncParens GruvboxFg3
line 1163: hi! link jsParens GruvboxFg3
line 1164: hi! link jsNull GruvboxPurple
line 1165: hi! link jsUndefined GruvboxPurple
line 1166: hi! link jsClassDefinition GruvboxYellow
line 1167: 
line 1168: " }}}
line 1169: " TypeScript: {{{
line 1170: 
line 1171: hi! link typeScriptReserved GruvboxAqua
line 1172: hi! link typeScriptLabel GruvboxAqua
line 1173: hi! link typeScriptFuncKeyword GruvboxAqua
line 1174: hi! link typeScriptIdentifier GruvboxOrange
line 1175: hi! link typeScriptBraces GruvboxFg1
line 1176: hi! link typeScriptEndColons GruvboxFg1
line 1177: hi! link typeScriptDOMObjects GruvboxFg1
line 1178: hi! link typeScriptAjaxMethods GruvboxFg1
line 1179: hi! link typeScriptLogicSymbols GruvboxFg1
line 1180: hi! link typeScriptDocSeeTag Comment
line 1181: hi! link typeScriptDocParam Comment
line 1182: hi! link typeScriptDocTags vimCommentTitle
line 1183: hi! link typeScriptGlobalObjects GruvboxFg1
line 1184: hi! link typeScriptParens GruvboxFg3
line 1185: hi! link typeScriptOpSymbols GruvboxFg3
line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1
line 1187: hi! link typeScriptNull GruvboxPurple
line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua
line 1189: 
line 1190: " }}}
line 1191: " PureScript: {{{
line 1192: 
line 1193: hi! link purescriptModuleKeyword GruvboxAqua
line 1194: hi! link purescriptModuleName GruvboxFg1
line 1195: hi! link purescriptWhere GruvboxAqua
line 1196: hi! link purescriptDelimiter GruvboxFg4
line 1197: hi! link purescriptType GruvboxFg1
line 1198: hi! link purescriptImportKeyword GruvboxAqua
line 1199: hi! link purescriptHidingKeyword GruvboxAqua
line 1200: hi! link purescriptAsKeyword GruvboxAqua
line 1201: hi! link purescriptStructure GruvboxAqua
line 1202: hi! link purescriptOperator GruvboxBlue
line 1203: 
line 1204: hi! link purescriptTypeVar GruvboxFg1
line 1205: hi! link purescriptConstructor GruvboxFg1
line 1206: hi! link purescriptFunction GruvboxFg1
line 1207: hi! link purescriptConditional GruvboxOrange
line 1208: hi! link purescriptBacktick GruvboxOrange
line 1209: 
line 1210: " }}}
line 1211: " CoffeeScript: {{{
line 1212: 
line 1213: hi! link coffeeExtendedOp GruvboxFg3
line 1214: hi! link coffeeSpecialOp GruvboxFg3
line 1215: hi! link coffeeCurly GruvboxOrange
line 1216: hi! link coffeeParen GruvboxFg3
line 1217: hi! link coffeeBracket GruvboxOrange
line 1218: 
line 1219: " }}}
line 1220: " Ruby: {{{
line 1221: 
line 1222: hi! link rubyStringDelimiter GruvboxGreen
line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua
line 1224: 
line 1225: " }}}
line 1226: " ObjectiveC: {{{
line 1227: 
line 1228: hi! link objcTypeModifier GruvboxRed
line 1229: hi! link objcDirective GruvboxBlue
line 1230: 
line 1231: " }}}
line 1232: " Go: {{{
line 1233: 
line 1234: hi! link goDirective GruvboxAqua
line 1235: hi! link goConstants GruvboxPurple
line 1236: hi! link goDeclaration GruvboxRed
line 1237: hi! link goDeclType GruvboxBlue
line 1238: hi! link goBuiltins GruvboxOrange
line 1239: 
line 1240: " }}}
line 1241: " Lua: {{{
line 1242: 
line 1243: hi! link luaIn GruvboxRed
line 1244: hi! link luaFunction GruvboxAqua
line 1245: hi! link luaTable GruvboxOrange
line 1246: 
line 1247: " }}}
line 1248: " MoonScript: {{{
line 1249: 
line 1250: hi! link moonSpecialOp GruvboxFg3
line 1251: hi! link moonExtendedOp GruvboxFg3
line 1252: hi! link moonFunction GruvboxFg3
line 1253: hi! link moonObject GruvboxYellow
line 1254: 
line 1255: " }}}
line 1256: " Java: {{{
line 1257: 
line 1258: hi! link javaAnnotation GruvboxBlue
line 1259: hi! link javaDocTags GruvboxAqua
line 1260: hi! link javaCommentTitle vimCommentTitle
line 1261: hi! link javaParen GruvboxFg3
line 1262: hi! link javaParen1 GruvboxFg3
line 1263: hi! link javaParen2 GruvboxFg3
line 1264: hi! link javaParen3 GruvboxFg3
line 1265: hi! link javaParen4 GruvboxFg3
line 1266: hi! link javaParen5 GruvboxFg3
line 1267: hi! link javaOperator GruvboxOrange
line 1268: 
line 1269: hi! link javaVarArg GruvboxGreen
line 1270: 
line 1271: " }}}
line 1272: " Elixir: {{{
line 1273: 
line 1274: hi! link elixirDocString Comment
line 1275: 
line 1276: hi! link elixirStringDelimiter GruvboxGreen
line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua
line 1278: 
line 1279: hi! link elixirModuleDeclaration GruvboxYellow
line 1280: 
line 1281: " }}}
line 1282: " Scala: {{{
line 1283: 
line 1284: " NB: scala vim syntax file is kinda horrible
line 1285: hi! link scalaNameDefinition GruvboxFg1
line 1286: hi! link scalaCaseFollowing GruvboxFg1
line 1287: hi! link scalaCapitalWord GruvboxFg1
line 1288: hi! link scalaTypeExtension GruvboxFg1
line 1289: 
line 1290: hi! link scalaKeyword GruvboxRed
line 1291: hi! link scalaKeywordModifier GruvboxRed
line 1292: 
line 1293: hi! link scalaSpecial GruvboxAqua
line 1294: hi! link scalaOperator GruvboxFg1
line 1295: 
line 1296: hi! link scalaTypeDeclaration GruvboxYellow
line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow
line 1298: 
line 1299: hi! link scalaInstanceDeclaration GruvboxFg1
line 1300: hi! link scalaInterpolation GruvboxAqua
line 1301: 
line 1302: " }}}
line 1303: " Markdown: {{{
line 1304: 
line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)
calling function <SNR>14_HL('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1306: 
line 1307: hi! link markdownH1 GruvboxGreenBold
line 1308: hi! link markdownH2 GruvboxGreenBold
line 1309: hi! link markdownH3 GruvboxYellowBold
line 1310: hi! link markdownH4 GruvboxYellowBold
line 1311: hi! link markdownH5 GruvboxYellow
line 1312: hi! link markdownH6 GruvboxYellow
line 1313: 
line 1314: hi! link markdownCode GruvboxAqua
line 1315: hi! link markdownCodeBlock GruvboxAqua
line 1316: hi! link markdownCodeDelimiter GruvboxAqua
line 1317: 
line 1318: hi! link markdownBlockquote GruvboxGray
line 1319: hi! link markdownListMarker GruvboxGray
line 1320: hi! link markdownOrderedListMarker GruvboxGray
line 1321: hi! link markdownRule GruvboxGray
line 1322: hi! link markdownHeadingRule GruvboxGray
line 1323: 
line 1324: hi! link markdownUrlDelimiter GruvboxFg3
line 1325: hi! link markdownLinkDelimiter GruvboxFg3
line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3
line 1327: 
line 1328: hi! link markdownHeadingDelimiter GruvboxOrange
line 1329: hi! link markdownUrl GruvboxPurple
line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen
line 1331: 
line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)
calling function <SNR>14_HL('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1333: hi! link markdownIdDeclaration markdownLinkText
line 1334: 
line 1335: " }}}
line 1336: " Haskell: {{{
line 1337: 
line 1338: " hi! link haskellType GruvboxYellow
line 1339: " hi! link haskellOperators GruvboxOrange
line 1340: " hi! link haskellConditional GruvboxAqua
line 1341: " hi! link haskellLet GruvboxOrange
line 1342: "
line 1343: hi! link haskellType GruvboxFg1
line 1344: hi! link haskellIdentifier GruvboxFg1
line 1345: hi! link haskellSeparator GruvboxFg1
line 1346: hi! link haskellDelimiter GruvboxFg4
line 1347: hi! link haskellOperators GruvboxBlue
line 1348: "
line 1349: hi! link haskellBacktick GruvboxOrange
line 1350: hi! link haskellStatement GruvboxOrange
line 1351: hi! link haskellConditional GruvboxOrange
line 1352: 
line 1353: hi! link haskellLet GruvboxAqua
line 1354: hi! link haskellDefault GruvboxAqua
line 1355: hi! link haskellWhere GruvboxAqua
line 1356: hi! link haskellBottom GruvboxAqua
line 1357: hi! link haskellBlockKeywords GruvboxAqua
line 1358: hi! link haskellImportKeywords GruvboxAqua
line 1359: hi! link haskellDeclKeyword GruvboxAqua
line 1360: hi! link haskellDeriving GruvboxAqua
line 1361: hi! link haskellAssocType GruvboxAqua
line 1362: 
line 1363: hi! link haskellNumber GruvboxPurple
line 1364: hi! link haskellPragma GruvboxPurple
line 1365: 
line 1366: hi! link haskellString GruvboxGreen
line 1367: hi! link haskellChar GruvboxGreen
line 1368: 
line 1369: " }}}
line 1370: " Json: {{{
line 1371: 
line 1372: hi! link jsonKeyword GruvboxGreen
line 1373: hi! link jsonQuote GruvboxGreen
line 1374: hi! link jsonBraces GruvboxFg1
line 1375: hi! link jsonString GruvboxFg1
line 1376: 
line 1377: " }}}
line 1378: 
line 1379: 
line 1380: " Functions -------------------------------------------------------------------
line 1381: " Search Highlighting Cursor {{{
line 1382: 
line 1383: function! GruvboxHlsShowCursor()
line 1386: 
line 1387: function! GruvboxHlsHideCursor()
line 1390: 
line 1391: " }}}
line 1392: 
line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
finished sourcing /usr/share/vim/vimfiles/colors/gruvbox.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
line 20: else
line 21:   runtime! syntax/syncolor.vim
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /home/ringu/.vimrc
line 89: 
line 90:   " I like highlighting strings inside C comments.
line 91:   " Revert with ":unlet c_comment_strings".
line 92:   let c_comment_strings=1
line 93: endif
line 94: 
line 95: " Only do this part when compiled with support for autocommands.
line 96: if has("autocmd")
line 97: 
line 98:   " Enable file type detection.
line 99:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
line 100:   " 'cindent' is on in C files, etc.
line 101:   " Also load indent files, to automatically do language-dependent indenting.
line 102:   " Revert with ":filetype off".
line 103:   filetype plugin indent on
Searching for "filetype.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/filetype.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/filetype.vim"
Searching for "/home/ringu/.vim/plugged/ale/filetype.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/filetype.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2018 May 04
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/filetype.vim"
Searching for "/home/ringu/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftplugin.vim"
Searching for "/home/ringu/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/indent.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/indent.vim"
Searching for "/home/ringu/.vim/plugged/ale/indent.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/indent.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/indent.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/indent.vim"
Searching for "/home/ringu/.vim/after/indent.vim"
line 104: 
line 105:   " Put these in an autocmd group, so that you can revert them with:
line 106:   " ":augroup vimStartup | au! | augroup END"
line 107:   augroup vimStartup
line 108:     au!
line 109: 
line 110:     " When editing a file, always jump to the last known cursor position.
line 111:     " Don't do it when the position is invalid, when inside an event handler
line 112:     " (happens when dropping a file on gvim) and for a commit message (it's
line 113:     " likely a different one than last time).
line 117:     autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' |   exe "normal! g`\"" | endif
line 118: 
line 119:   augroup END
line 120: 
line 121: endif " has("autocmd")
line 122: 
line 123: "press space to auto close tags after </
line 124: :iabbrev </ </<C-X><C-O>
line 125: 
line 126: "nerdtree is ctrl+n
line 127: map <F2> :NERDTreeToggle<CR>
line 128: 
line 129: "autocmd filetype javascript set formatprg=prettier\ --stdin
line 130: 
line 131: "remapping hjkl to jkl;
line 132: noremap ; l
line 133: noremap l k
line 134: noremap k j
line 135: noremap j h
line 136: 
line 137: imap <c-space><Plug>(asyncomplete_force_refresh)

                                                          No mapping found
line 138: autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
line 139: 
line 140: if executable('flow')
line 146:   au User lsp_setup call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })
line 147: endif
line 148: 
line 149: if executable('css-languageserver')
line 154:   au User lsp_setup call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })
line 155: endif
line 156: 
line 157: let g:asyncomplete_smart_completion=1
line 158: let g:asyncomplete_auto_popup=1
line 159: 
line 160: let g:WebDevIconsUnicodeDecorateFolderNodes=1
line 161: let g:WebDevIconsNerdTreeAfterGlyphPadding=' '
line 162: let g:NERDTreeDirArrowExpandable='+'
line 163: let g:NERDTreeDirArrowCollapsible='-'
finished sourcing $HOME/.vimrc
Searching for "pack/*/start/*" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/ringu/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/lightline.vim/plugin/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: plugin/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/06/22 08:49:00.
line 6: " =============================================================================
line 7: 
line 8: if exists('g:loaded_lightline') || v:version < 700
line 9:   finish
line 10: endif
line 11: let g:loaded_lightline = 1
line 12: 
line 13: let s:save_cpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup lightline
line 17:   autocmd!
line 18:   autocmd WinEnter,BufWinEnter,FileType,SessionLoadPost * call lightline#update()
line 19:   autocmd SessionLoadPost * call lightline#highlight()
line 21:   autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim' | call lightline#update() | call lightline#highlight() | endif
line 22:   autocmd CursorMoved,BufUnload * call lightline#update_once()
line 23: augroup END
line 24: 
line 25: let &cpo = s:save_cpo
line 26: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/plugin/lightline.vim
Searching for "/home/ringu/.vim/plugged/vim-surround/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-surround/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-surround/plugin/surround.vim"
line 1: " surround.vim - Surroundings
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: " Version:      2.1
line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
line 5: 
line 6: if exists("g:loaded_surround") || &cp || v:version < 700
line 7:   finish
line 8: endif
line 9: let g:loaded_surround = 1
line 10: 
line 11: " Input functions {{{1
line 12: 
line 13: function! s:getchar()
line 20: 
line 21: function! s:inputtarget()
line 35: 
line 36: function! s:inputreplacement()
line 47: 
line 48: function! s:beep()
line 52: 
line 53: function! s:redraw()
line 57: 
line 58: " }}}1
line 59: 
line 60: " Wrapping functions {{{1
line 61: 
line 62: function! s:extractbefore(str)
line 69: 
line 70: function! s:extractafter(str)
line 77: 
line 78: function! s:fixindent(str,spc)
line 87: 
line 88: function! s:process(string)
line 126: 
line 127: function! s:wrap(string,char,type,removed,special)
line 302: 
line 303: function! s:wrapreg(reg,char,removed,special)
line 309: " }}}1
line 310: 
line 311: function! s:insert(...) " {{{1
line 353: 
line 354: function! s:reindent() " {{{1
line 359: 
line 360: function! s:dosurround(...) " {{{1
line 473: 
line 474: function! s:changesurround(...) " {{{1
line 485: 
line 486: function! s:opfunc(type, ...) abort " {{{1
line 552: 
line 553: function! s:opfunc2(...) abort
line 560: 
line 561: function! s:closematch(str) " {{{1
line 576: 
line 577: nnoremap <silent> <Plug>SurroundRepeat .
line 578: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
line 579: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
line 580: nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
line 581: nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
line 582: nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
line 583: nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
line 584: nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
line 585: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
line 586: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
line 587: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
line 588: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
line 589: 
line 590: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
line 591:   nmap ds  <Plug>Dsurround
line 592:   nmap cs  <Plug>Csurround
line 593:   nmap cS  <Plug>CSurround
line 594:   nmap ys  <Plug>Ysurround
line 595:   nmap yS  <Plug>YSurround
line 596:   nmap yss <Plug>Yssurround
line 597:   nmap ySs <Plug>YSsurround
line 598:   nmap ySS <Plug>YSsurround
line 599:   xmap S   <Plug>VSurround
line 600:   xmap gS  <Plug>VgSurround
line 601:   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
line 602:     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
line 603:       imap    <C-S> <Plug>Isurround
line 604:     endif
line 605:     imap      <C-G>s <Plug>Isurround
line 606:     imap      <C-G>S <Plug>ISurround
line 607:   endif
line 608: endif
line 609: 
line 610: " vim:set ft=vim sw=2 sts=2 et:
finished sourcing /home/ringu/.vim/plugged/vim-surround/plugin/surround.vim
Searching for "/home/ringu/.vim/plugged/auto-pairs/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/auto-pairs/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/auto-pairs/plugin/auto-pairs.vim"
line 1: " Insert or delete brackets, parens, quotes in pairs.
line 2: " Maintainer:^IJiangMiao <jiangfriend@gmail.com>
line 3: " Contributor: camthompson
line 4: " Last Change:  2017-06-17
line 5: " Version: 1.3.3
line 6: " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
line 7: " Repository: https://github.com/jiangmiao/auto-pairs
line 8: " License: MIT
line 9: 
line 10: if exists('g:AutoPairsLoaded') || &cp
line 11:   finish
line 12: end
line 13: let g:AutoPairsLoaded = 1
line 14: 
line 15: if !exists('g:AutoPairs')
line 16:   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
line 17: end
line 18: 
line 19: if !exists('g:AutoPairsParens')
line 20:   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
line 21: end
line 22: 
line 23: if !exists('g:AutoPairsMapBS')
line 24:   let g:AutoPairsMapBS = 1
line 25: end
line 26: 
line 27: " Map <C-h> as the same BS
line 28: if !exists('g:AutoPairsMapCh')
line 29:   let g:AutoPairsMapCh = 1
line 30: end
line 31: 
line 32: if !exists('g:AutoPairsMapCR')
line 33:   let g:AutoPairsMapCR = 1
line 34: end
line 35: 
line 36: if !exists('g:AutoPairsMapSpace')
line 37:   let g:AutoPairsMapSpace = 1
line 38: end
line 39: 
line 40: if !exists('g:AutoPairsCenterLine')
line 41:   let g:AutoPairsCenterLine = 1
line 42: end
line 43: 
line 44: if !exists('g:AutoPairsShortcutToggle')
line 45:   let g:AutoPairsShortcutToggle = '<M-p>'
line 46: end
line 47: 
line 48: if !exists('g:AutoPairsShortcutFastWrap')
line 49:   let g:AutoPairsShortcutFastWrap = '<M-e>'
line 50: end
line 51: 
line 52: if !exists('g:AutoPairsMoveCharacter')
line 53:   let g:AutoPairsMoveCharacter = "()[]{}\"'"
line 54: end
line 55: 
line 56: if !exists('g:AutoPairsShortcutJump')
line 57:   let g:AutoPairsShortcutJump = '<M-n>'
line 58: endif
line 59: 
line 60: " Fly mode will for closed pair to jump to closed pair instead of insert.
line 61: " also support AutoPairsBackInsert to insert pairs where jumped.
line 62: if !exists('g:AutoPairsFlyMode')
line 63:   let g:AutoPairsFlyMode = 0
line 64: endif
line 65: 
line 66: " When skipping the closed pair, look at the current and
line 67: " next line as well.
line 68: if !exists('g:AutoPairsMultilineClose')
line 69:   let g:AutoPairsMultilineClose = 1
line 70: endif
line 71: 
line 72: " Work with Fly Mode, insert pair where jumped
line 73: if !exists('g:AutoPairsShortcutBackInsert')
line 74:   let g:AutoPairsShortcutBackInsert = '<M-b>'
line 75: endif
line 76: 
line 77: if !exists('g:AutoPairsSmartQuotes')
line 78:   let g:AutoPairsSmartQuotes = 1
line 79: endif
line 80: 
line 81: " 7.4.849 support <C-G>U to avoid breaking '.'
line 82: " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
line 83: " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
line 84: if v:version > 704 || v:version == 704 && has("patch849")
line 85:   let s:Go = "\<C-G>U"
line 86: else
line 87:   let s:Go = ""
line 88: endif
line 89: 
line 90: let s:Left = s:Go."\<LEFT>"
line 91: let s:Right = s:Go."\<RIGHT>"
line 92: 
line 93: 
line 94: " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
line 95: let g:AutoPairsClosedPairs = {}
line 96: 
line 97: 
line 98: function! AutoPairsInsert(key)
line 225: 
line 226: function! AutoPairsDelete()
line 291: 
line 292: function! AutoPairsJump()
line 295: " string_chunk cannot use standalone
line 296: let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
line 297: let s:ss_pattern = '\v''' . s:string_chunk . ''''
line 298: let s:ds_pattern = '\v"'  . s:string_chunk . '"'
line 299: 
line 300: func! s:RegexpQuote(str)
line 303: 
line 304: func! s:RegexpQuoteInSquare(str)
line 307: 
line 308: " Search next open or close pair
line 309: func! s:FormatChunk(open, close)
line 320: 
line 321: " Fast wrap the word in brackets
line 322: function! AutoPairsFastWrap()
line 353: 
line 354: function! AutoPairsMap(key)
line 365: 
line 366: function! AutoPairsToggle()
line 376: 
line 377: function! AutoPairsMoveCharacter(key)
line 382: 
line 383: function! AutoPairsReturn()
line 415: 
line 416: function! AutoPairsSpace()
line 426: 
line 427: function! AutoPairsBackInsert()
line 436: 
line 437: function! AutoPairsInit()
line 505: 
line 506: function! s:ExpandMap(map)
line 511: 
line 512: function! AutoPairsTryInit()
line 576: 
line 577: " Always silent the command
line 578: inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
line 579: imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
line 580: 
line 581: 
line 582: au BufEnter * :call AutoPairsTryInit()
finished sourcing /home/ringu/.vim/plugged/auto-pairs/plugin/auto-pairs.vim
Searching for "/home/ringu/.vim/plugged/ale/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/ale/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/ale/plugin/ale.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: Main entry point for the plugin: sets up prefs and autocommands
line 3: "   Preferences can be set in vimrc files and so on to configure ale
line 4: 
line 5: " Sanity Checks
line 6: 
line 7: if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
line 8:     finish
line 9: endif
line 10: 
line 11: " Set a special flag used only by this plugin for preventing doubly
line 12: " loading the script.
line 13: let g:loaded_ale_dont_use_this_in_other_plugins_please = 1
line 14: 
line 15: " A flag for detecting if the required features are set.
line 16: if has('nvim')
line 17:     let s:has_features = has('timers') && has('nvim-0.2.0')
line 18: else
line 19:     " Check if Job and Channel functions are available, instead of the
line 20:     " features. This works better on old MacVim versions.
line 21:     let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
line 22: endif
line 23: 
line 24: if !s:has_features
line 25:     " Only output a warning if editing some special files.
line 26:     if index(['', 'gitcommit'], &filetype) == -1
line 27:         execute 'echoerr ''ALE requires NeoVim >= 0.2.0 or Vim 8 with +timers +job +channel'''
line 28:         execute 'echoerr ''Please update your editor appropriately.'''
line 29:     endif
line 30: 
line 31:     " Stop here, as it won't work.
line 32:     finish
line 33: endif
line 34: 
line 35: " Set this flag so that other plugins can use it, like airline.
line 36: let g:loaded_ale = 1
line 37: 
line 38: " This global variable is used internally by ALE for tracking information for
line 39: " each buffer which linters are being run against.
line 40: let g:ale_buffer_info = {}
line 41: " This global Dictionary tracks data for fixing code. Don't mess with it.
line 42: let g:ale_fix_buffer_data = {}
line 43: 
line 44: " User Configuration
line 45: 
line 46: " This option prevents ALE autocmd commands from being run for particular
line 47: " filetypes which can cause issues.
line 54: let g:ale_filetype_blacklist = [   'dirvish',   'nerdtree',   'qf',   'tags',   'unite',]
line 55: 
line 56: " This Dictionary configures which linters are enabled for which languages.
line 57: let g:ale_linters = get(g:, 'ale_linters', {})
line 58: " This option can be changed to only enable explicitly selected linters.
line 59: let g:ale_linters_explicit = get(g:, 'ale_linters_explicit', 0)
line 60: 
line 61: " This Dictionary configures which functions will be used for fixing problems.
line 62: let g:ale_fixers = get(g:, 'ale_fixers', {})
line 63: 
line 64: " This Dictionary allows users to set up filetype aliases for new filetypes.
line 65: let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})
line 66: 
line 67: " This flag can be set with a number of milliseconds for delaying the
line 68: " execution of a linter when text is changed. The timeout will be set and
line 69: " cleared each time text is changed, so repeated edits won't trigger the
line 70: " jobs for linting until enough time has passed after editing is done.
line 71: let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)
line 72: 
line 73: " This flag can be set to 'never' to disable linting when text is changed.
line 74: " This flag can also be set to 'insert' or 'normal' to lint when text is
line 75: " changed only in insert or normal mode respectively.
line 76: let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'always')
line 77: 
line 78: " This flag can be set to 1 to enable linting when leaving insert mode.
line 79: let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', 0)
line 80: 
line 81: " This flag can be set to 0 to disable linting when the buffer is entered.
line 82: let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', 1)
line 83: 
line 84: " This flag can be set to 1 to enable linting when a buffer is written.
line 85: let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', 1)
line 86: 
line 87: " This flag can be set to 1 to enable linting when the filetype is changed.
line 88: let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', 1)
line 89: 
line 90: " This flag can be set to 1 to enable automatically fixing files on save.
line 91: let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', 0)
line 92: 
line 93: " This flag may be set to 0 to disable ale. After ale is loaded, :ALEToggle
line 94: " should be used instead.
line 95: let g:ale_enabled = get(g:, 'ale_enabled', 1)
line 96: 
line 97: " These flags dictates if ale uses the quickfix or the loclist (loclist is the
line 98: " default, quickfix overrides loclist).
line 99: let g:ale_set_loclist = get(g:, 'ale_set_loclist', 1)
line 100: let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', 0)
line 101: 
line 102: " This flag can be set to 0 to disable setting signs.
line 103: " This is enabled by default only if the 'signs' feature exists.
line 104: let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs'))
line 105: 
line 106: " This flag can be set to 0 to disable setting error highlights.
line 107: let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax'))
line 108: 
line 109: " This flag can be set to 0 to disable echoing when the cursor moves.
line 110: let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', 1)
line 111: 
line 112: " This flag can be set to 1 to automatically show errors in the preview window.
line 113: let g:ale_cursor_detail = get(g:, 'ale_cursor_detail', 0)
line 114: 
line 115: " This flag can be set to 1 to enable virtual text when the cursor moves.
line 116: let g:ale_virtualtext_cursor = get(g:, 'ale_virtualtext_cursor', 0)
line 117: 
line 118: " This flag can be set to 1 to automatically close the preview window upon
line 119: " entering Insert Mode.
line 120: let g:ale_close_preview_on_insert = get(g:, 'ale_close_preview_on_insert', 0)
line 121: 
line 122: " This flag can be set to 0 to disable balloon support.
line 123: let g:ale_set_balloons = get(g:, 'ale_set_balloons', has('balloon_eval') && has('gui_running'))
line 124: 
line 125: " This flag can be set to 0 to disable warnings for trailing whitespace
line 126: let g:ale_warn_about_trailing_whitespace = get(g:, 'ale_warn_about_trailing_whitespace', 1)
line 127: " This flag can be set to 0 to disable warnings for trailing blank lines
line 128: let g:ale_warn_about_trailing_blank_lines = get(g:, 'ale_warn_about_trailing_blank_lines', 1)
line 129: 
line 130: " A flag for enabling or disabling the command history.
line 131: let g:ale_history_enabled = get(g:, 'ale_history_enabled', 1)
line 132: 
line 133: " A flag for storing the full output of commands in the history.
line 134: let g:ale_history_log_output = get(g:, 'ale_history_log_output', 1)
line 135: 
line 136: " Enable automatic completion with LSP servers and tsserver
line 137: let g:ale_completion_enabled = get(g:, 'ale_completion_enabled', 0)
line 138: 
line 139: " Enable automatic detection of pipenv for Python linters.
line 140: let g:ale_python_auto_pipenv = get(g:, 'ale_python_auto_pipenv', 0)
line 141: 
line 142: if g:ale_set_balloons
line 143:     call ale#balloon#Enable()
line 144: endif
line 145: 
line 146: if g:ale_completion_enabled
line 147:     call ale#completion#Enable()
line 148: endif
line 149: 
line 150: " Define commands for moving through warnings and errors.
line 151: command! -bar ALEPrevious :call ale#loclist_jumping#Jump('before', 0)
line 152: command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)
line 153: command! -bar ALENext :call ale#loclist_jumping#Jump('after', 0)
line 154: command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)
line 155: command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)
line 156: command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)
line 157: 
line 158: " A command for showing error details.
line 159: command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()
line 160: 
line 161: " Define commands for turning ALE on or off.
line 162: command! -bar ALEToggle :call ale#toggle#Toggle()
line 163: command! -bar ALEEnable :call ale#toggle#Enable()
line 164: command! -bar ALEDisable :call ale#toggle#Disable()
line 165: command! -bar ALEReset :call ale#toggle#Reset()
line 166: " Commands for turning ALE on or off for a buffer.
line 167: command! -bar ALEToggleBuffer :call ale#toggle#ToggleBuffer(bufnr(''))
line 168: command! -bar ALEEnableBuffer :call ale#toggle#EnableBuffer(bufnr(''))
line 169: command! -bar ALEDisableBuffer :call ale#toggle#DisableBuffer(bufnr(''))
line 170: command! -bar ALEResetBuffer :call ale#toggle#ResetBuffer(bufnr(''))
line 171: " A command to stop all LSP-like clients, including tsserver.
line 172: command! -bar ALEStopAllLSPs :call ale#lsp#reset#StopAllLSPs()
line 173: 
line 174: " A command for linting manually.
line 175: command! -bar ALELint :call ale#Queue(0, 'lint_file')
line 176: 
line 177: " Define a command to get information about current filetype.
line 178: command! -bar ALEInfo :call ale#debugging#Info()
line 179: " The same, but copy output to your clipboard.
line 180: command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboard()
line 181: " Copy ALE information to a file.
line 182: command! -bar -nargs=1 ALEInfoToFile :call ale#debugging#InfoToFile(<f-args>)
line 183: 
line 184: " Fix problems in files.
line 185: command! -bar -nargs=* -complete=customlist,ale#fix#registry#CompleteFixers ALEFix :call ale#fix#Fix(bufnr(''), '', <f-args>)
line 186: " Suggest registered functions to use for fixing problems.
line 187: command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)
line 188: 
line 189: " Go to definition for tsserver and LSP
line 190: command! -bar ALEGoToDefinition :call ale#definition#GoTo({})
line 191: command! -bar ALEGoToDefinitionInTab :call ale#definition#GoTo({'open_in': 'tab'})
line 192: command! -bar ALEGoToDefinitionInSplit :call ale#definition#GoTo({'open_in': 'horizontal-split'})
line 193: command! -bar ALEGoToDefinitionInVSplit :call ale#definition#GoTo({'open_in': 'vertical-split'})
line 194: 
line 195: " Find references for tsserver and LSP
line 196: command! -bar ALEFindReferences :call ale#references#Find()
line 197: 
line 198: " Show summary information for the cursor.
line 199: command! -bar ALEHover :call ale#hover#ShowAtCursor()
line 200: 
line 201: " Show documentation for the cursor.
line 202: command! -bar ALEDocumentation :call ale#hover#ShowDocumentationAtCursor()
line 203: 
line 204: " Search for appearances of a symbol, such as a type name or function name.
line 205: command! -nargs=1 ALESymbolSearch :call ale#symbol#Search(<q-args>)
line 206: 
line 207: command! -bar ALEComplete :call ale#completion#AlwaysGetCompletions(0)
line 208: 
line 209: " <Plug> mappings for commands
line 210: nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>
line 211: nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>
line 212: nnoremap <silent> <Plug>(ale_next) :ALENext<Return>
line 213: nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>
line 214: nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>
line 215: nnoremap <silent> <Plug>(ale_last) :ALELast<Return>
line 216: nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>
line 217: nnoremap <silent> <Plug>(ale_enable) :ALEEnable<Return>
line 218: nnoremap <silent> <Plug>(ale_disable) :ALEDisable<Return>
line 219: nnoremap <silent> <Plug>(ale_reset) :ALEReset<Return>
line 220: nnoremap <silent> <Plug>(ale_toggle_buffer) :ALEToggleBuffer<Return>
line 221: nnoremap <silent> <Plug>(ale_enable_buffer) :ALEEnableBuffer<Return>
line 222: nnoremap <silent> <Plug>(ale_disable_buffer) :ALEDisableBuffer<Return>
line 223: nnoremap <silent> <Plug>(ale_reset_buffer) :ALEResetBuffer<Return>
line 224: nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>
line 225: nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>
line 226: nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>
line 227: nnoremap <silent> <Plug>(ale_go_to_definition) :ALEGoToDefinition<Return>
line 228: nnoremap <silent> <Plug>(ale_go_to_definition_in_tab) :ALEGoToDefinitionInTab<Return>
line 229: nnoremap <silent> <Plug>(ale_go_to_definition_in_split) :ALEGoToDefinitionInSplit<Return>
line 230: nnoremap <silent> <Plug>(ale_go_to_definition_in_vsplit) :ALEGoToDefinitionInVSplit<Return>
line 231: nnoremap <silent> <Plug>(ale_find_references) :ALEFindReferences<Return>
line 232: nnoremap <silent> <Plug>(ale_hover) :ALEHover<Return>
line 233: nnoremap <silent> <Plug>(ale_documentation) :ALEDocumentation<Return>
line 234: inoremap <silent> <Plug>(ale_complete) <C-\><C-O>:ALEComplete<Return>
line 235: 
line 236: " Set up autocmd groups now.
line 237: call ale#events#Init()
Searching for "autoload/ale/events.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/ale/events.vim"
chdir(/home/ringu/.vim/plugged/ale/autoload/ale)
fchdir() to previous dir
line 237: sourcing "/home/ringu/.vim/plugged/ale/autoload/ale/events.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: ALE functions for autocmd events.
line 3: 
line 4: " Get the number of milliseconds since some vague, but consistent, point in
line 5: " the past.
line 6: "
line 7: " This function can be used for timing execution, etc.
line 8: "
line 9: " The time will be returned as a Number.
line 10: function! ale#events#ClockMilliseconds() abort
line 13: 
line 14: function! ale#events#QuitEvent(buffer) abort
line 18: 
line 19: function! ale#events#QuitRecently(buffer) abort
line 24: 
line 25: function! ale#events#SaveEvent(buffer) abort
line 41: 
line 42: function! ale#events#LintOnEnter(buffer) abort
line 50: 
line 51: function! ale#events#ReadOrEnterEvent(buffer) abort
line 68: 
line 69: function! ale#events#FileTypeEvent(buffer, new_filetype) abort
line 86: 
line 87: function! ale#events#FileChangedEvent(buffer) abort
line 94: 
line 95: function! ale#events#Init() abort
finished sourcing /home/ringu/.vim/plugged/ale/autoload/ale/events.vim
continuing in /home/ringu/.vim/plugged/ale/plugin/ale.vim
calling function ale#events#Init()

line 1:     " This value used to be a Boolean as a Number, and is now a String.
line 2:     let l:text_changed = '' . g:ale_lint_on_text_changed
line 3: 
line 4:     augroup ALEEvents
line 5:         autocmd!
line 6: 
line 7:         " These events always need to be set up.
line 8:         autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
line 9:         autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
line 10: 
line 11:         if g:ale_enabled
line 12:             if l:text_changed is? 'always' || l:text_changed is# '1'
line 13:                 autocmd TextChanged,TextChangedI * call ale#Queue(g:ale_lint_delay)
line 14:             elseif l:text_changed is? 'normal'
line 15:                 autocmd TextChanged * call ale#Queue(g:ale_lint_delay)
line 16:             elseif l:text_changed is? 'insert'
line 17:                 autocmd TextChangedI * call ale#Queue(g:ale_lint_delay)
line 18:             endif
line 19: 
line 20:             if g:ale_lint_on_enter
line 21:                 autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
line 22:                 " Track when the file is changed outside of Vim.
line 23:                 autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
line 24:             endif
line 25: 
line 26:             if g:ale_lint_on_filetype_changed
line 27:                 " Only start linting if the FileType actually changes after
line 28:                 " opening a buffer. The FileType will fire when buffers are opened.
line 29:                 autocmd FileType * call ale#events#FileTypeEvent(   str2nr(expand('<abuf>')),   expand('<amatch>'))
line 33:             endif
line 34: 
line 35:             if g:ale_lint_on_insert_leave
line 36:                 autocmd InsertLeave * call ale#Queue(0)
line 37:             endif
line 38: 
line 39:             if g:ale_echo_cursor || g:ale_cursor_detail
line 40:                 autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
line 41:                 " Look for a warning to echo as soon as we leave Insert mode.
line 42:                 " The script's position variable used when moving the cursor will
line 43:                 " not be changed here.
line 44:                 autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarning() | endif
line 45:             endif
line 46: 
line 47:             if g:ale_virtualtext_cursor
line 48:                 autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
line 49:                 " Look for a warning to echo as soon as we leave Insert mode.
line 50:                 " The script's position variable used when moving the cursor will
line 51:                 " not be changed here.
line 52:                 autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarning() | endif
line 53:             endif
line 54: 
line 55:             if g:ale_close_preview_on_insert
line 56:                 autocmd InsertEnter * if exists('*ale#preview#CloseIfTypeMatches') | call ale#preview#CloseIfTypeMatches('ale-preview') | endif
line 57:             endif
line 58:         endif
line 59:     augroup END
function ale#events#Init returning #0

continuing in /home/ringu/.vim/plugged/ale/plugin/ale.vim

line 238: 
line 239: " Housekeeping
line 240: 
line 241: augroup ALECleanupGroup
line 242:     autocmd!
line 243:     " Clean up buffers automatically when they are unloaded.
line 244:     autocmd BufDelete * if exists('*ale#engine#Cleanup') | call ale#engine#Cleanup(str2nr(expand('<abuf>'))) | endif
line 245:     autocmd QuitPre * call ale#events#QuitEvent(str2nr(expand('<abuf>')))
line 246: 
line 247:     if exists('##VimSuspend')
line 248:       autocmd VimSuspend * if exists('*ale#engine#CleanupEveryBuffer') | call ale#engine#CleanupEveryBuffer() | endif
line 249:     endif
line 250: augroup END
finished sourcing /home/ringu/.vim/plugged/ale/plugin/ale.vim
Searching for "/home/ringu/.vim/plugged/nerdtree/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim"
line 1: " ============================================================================
line 2: " File:        NERD_tree.vim
line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 4: " License:     This program is free software. It comes without any warranty,
line 5: "              to the extent permitted by applicable law. You can redistribute
line 6: "              it and/or modify it under the terms of the Do What The Fuck You
line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: " ============================================================================
line 11: "
line 12: " SECTION: Script init stuff {{{1
line 13: "============================================================
line 14: if exists("loaded_nerd_tree")
line 15:     finish
line 16: endif
line 17: if v:version < 700
line 18:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
line 19:     finish
line 20: endif
line 21: let loaded_nerd_tree = 1
line 22: 
line 23: "for line continuation - i.e dont want C in &cpo
line 24: let s:old_cpo = &cpo
line 25: set cpo&vim
line 26: 
line 27: "Function: s:initVariable() function {{{2
line 28: "This function is used to initialise a given variable to a given value. The
line 29: "variable is only initialised if it does not exist prior
line 30: "
line 31: "Args:
line 32: "var: the name of the var to be initialised
line 33: "value: the value to initialise var to
line 34: "
line 35: "Returns:
line 36: "1 if the var is set, 0 otherwise
line 37: function! s:initVariable(var, value)
line 44: 
line 45: "SECTION: Init variable calls and other random constants {{{2
line 46: call s:initVariable("g:NERDTreeAutoCenter", 1)
calling function <SNR>21_initVariable('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenter = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 47: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
calling function <SNR>21_initVariable('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenterThreshold = '3'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 48: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
calling function <SNR>21_initVariable('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCaseSensitiveSort = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 49: call s:initVariable("g:NERDTreeNaturalSort", 0)
calling function <SNR>21_initVariable('g:NERDTreeNaturalSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNaturalSort = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 50: call s:initVariable("g:NERDTreeSortHiddenFirst", 1)
calling function <SNR>21_initVariable('g:NERDTreeSortHiddenFirst', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortHiddenFirst = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 51: call s:initVariable("g:NERDTreeChDirMode", 0)
calling function <SNR>21_initVariable('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeChDirMode = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 52: call s:initVariable("g:NERDTreeCreatePrefix", "silent")
calling function <SNR>21_initVariable('g:NERDTreeCreatePrefix', 'silent')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCreatePrefix = 'silent'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 53: call s:initVariable("g:NERDTreeMinimalUI", 0)
calling function <SNR>21_initVariable('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMinimalUI = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 54: if !exists("g:NERDTreeIgnore")
line 55:     let g:NERDTreeIgnore = ['\~$']
line 56: endif
line 57: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
calling function <SNR>21_initVariable('g:NERDTreeBookmarksFile', '/home/ringu/.NERDTreeBookmarks')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksFile = '/home/ringu/.NERDTreeBookmarks'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 58: call s:initVariable("g:NERDTreeBookmarksSort", 1)
calling function <SNR>21_initVariable('g:NERDTreeBookmarksSort', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksSort = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 59: call s:initVariable("g:NERDTreeHighlightCursorline", 1)
calling function <SNR>21_initVariable('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHighlightCursorline = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 60: call s:initVariable("g:NERDTreeHijackNetrw", 1)
calling function <SNR>21_initVariable('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHijackNetrw = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 61: call s:initVariable('g:NERDTreeMarkBookmarks', 1)
calling function <SNR>21_initVariable('g:NERDTreeMarkBookmarks', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMarkBookmarks = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 62: call s:initVariable("g:NERDTreeMouseMode", 1)
calling function <SNR>21_initVariable('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMouseMode = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 63: call s:initVariable("g:NERDTreeNotificationThreshold", 100)
calling function <SNR>21_initVariable('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNotificationThreshold = '100'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 64: call s:initVariable("g:NERDTreeQuitOnOpen", 0)
calling function <SNR>21_initVariable('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeQuitOnOpen = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 65: call s:initVariable("g:NERDTreeRespectWildIgnore", 0)
calling function <SNR>21_initVariable('g:NERDTreeRespectWildIgnore', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRespectWildIgnore = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 66: call s:initVariable("g:NERDTreeShowBookmarks", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowBookmarks = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 67: call s:initVariable("g:NERDTreeShowFiles", 1)
calling function <SNR>21_initVariable('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowFiles = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 68: call s:initVariable("g:NERDTreeShowHidden", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowHidden = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 69: call s:initVariable("g:NERDTreeShowLineNumbers", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowLineNumbers = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 70: call s:initVariable("g:NERDTreeSortDirs", 1)
calling function <SNR>21_initVariable('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortDirs = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 71: 
line 72: if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
Searching for "autoload/nerdtree.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/autoload)
fchdir() to previous dir
line 72: sourcing "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim"
line 1: if exists("g:loaded_nerdtree_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_autoload = 1
line 5: 
line 6: function! nerdtree#version()
line 9: 
line 10: " SECTION: General Functions {{{1
line 11: "============================================================
line 12: 
line 13: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
line 14: "inits a window tree in the current buffer if appropriate
line 15: function! nerdtree#checkForBrowse(dir)
line 26: 
line 27: "FUNCTION: s:reuseWin(dir) {{{2
line 28: "finds a NERDTree buffer with root of dir, and opens it.
line 29: function! s:reuseWin(dir) abort
line 48: 
line 49: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
line 50: " completion function for the bookmark commands
line 51: function! nerdtree#completeBookmarks(A,L,P)
line 54: 
line 55: "FUNCTION: nerdtree#compareNodes(dir) {{{2
line 56: function! nerdtree#compareNodes(n1, n2)
line 59: 
line 60: "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
line 61: function! nerdtree#compareNodesBySortKey(n1, n2)
line 93: 
line 94: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
line 95: " Issue a deprecation warning for a:func. If a second arg is given, use this
line 96: " as the deprecation message
line 97: function! nerdtree#deprecated(func, ...)
line 108: 
line 109: " FUNCTION: nerdtree#exec(cmd) {{{2
line 110: " Same as :exec cmd but with eventignore set for the duration
line 111: " to disable the autocommands used by NERDTree (BufEnter,
line 112: " BufLeave and VimEnter)
line 113: function! nerdtree#exec(cmd)
line 119: 
line 120: " FUNCTION: nerdtree#has_opt(options, name) {{{2
line 121: function! nerdtree#has_opt(options, name)
line 124: 
line 125: " FUNCTION: nerdtree#loadClassFiles() {{{2
line 126: function! nerdtree#loadClassFiles()
line 142: 
line 143: " FUNCTION: nerdtree#postSourceActions() {{{2
line 144: function! nerdtree#postSourceActions()
line 151: 
line 152: "FUNCTION: nerdtree#runningWindows(dir) {{{2
line 153: function! nerdtree#runningWindows()
line 156: 
line 157: "FUNCTION: nerdtree#runningCygwin(dir) {{{2
line 158: function! nerdtree#runningCygwin()
line 161: 
line 162: " SECTION: View Functions {{{1
line 163: "============================================================
line 164: 
line 165: "FUNCTION: nerdtree#echo  {{{2
line 166: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
line 167: "
line 168: "Args:
line 169: "msg: the message to echo
line 170: function! nerdtree#echo(msg)
line 174: 
line 175: "FUNCTION: nerdtree#echoError {{{2
line 176: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
line 177: "Args:
line 178: "msg: the message to echo
line 179: function! nerdtree#echoError(msg)
line 184: 
line 185: "FUNCTION: nerdtree#echoWarning {{{2
line 186: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
line 187: "Args:
line 188: "msg: the message to echo
line 189: function! nerdtree#echoWarning(msg)
line 194: 
line 195: "FUNCTION: nerdtree#renderView {{{2
line 196: function! nerdtree#renderView()
line 199: 
line 200: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim
continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

calling function nerdtree#runningCygwin()

line 1:     return has("win32unix")
function nerdtree#runningCygwin returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 73:     call s:initVariable("g:NERDTreeDirArrowExpandable", "")
calling function <SNR>21_initVariable('g:NERDTreeDirArrowExpandable', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 3:         return 1
line 4:     endif
line 5:     return 0
function <SNR>21_initVariable returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 74:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "")
calling function <SNR>21_initVariable('g:NERDTreeDirArrowCollapsible', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 3:         return 1
line 4:     endif
line 5:     return 0
function <SNR>21_initVariable returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 75: else
line 76:     call s:initVariable("g:NERDTreeDirArrowExpandable", "+")
line 77:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")
line 78: endif
line 79: call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)
calling function <SNR>21_initVariable('g:NERDTreeCascadeOpenSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeOpenSingleChildDir = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 80: call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)
calling function <SNR>21_initVariable('g:NERDTreeCascadeSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeSingleChildDir = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 81: 
line 82: if !exists("g:NERDTreeSortOrder")
line 83:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
line 84: endif
line 85: let g:NERDTreeOldSortOrder = []
line 86: 
line 87: call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")
calling function <SNR>21_initVariable('g:NERDTreeGlyphReadOnly', 'RO')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeGlyphReadOnly = 'RO'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 88: 
line 89: " ASCII 7: bell non-printing character used to delimit items in the tree's nodes.
line 90: call s:initVariable("g:NERDTreeNodeDelimiter", "\x07")
calling function <SNR>21_initVariable('g:NERDTreeNodeDelimiter', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNodeDelimiter = '^G'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 91: 
line 92: if !exists('g:NERDTreeStatusline')
line 93: 
line 94:     "the exists() crap here is a hack to stop vim spazzing out when
line 95:     "loading a session that was created with an open nerd tree. It spazzes
line 96:     "because it doesnt store b:NERDTree(its a b: var, and its a hash)
line 97:     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
line 98: 
line 99: endif
line 100: call s:initVariable("g:NERDTreeWinPos", "left")
calling function <SNR>21_initVariable('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinPos = 'left'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 101: call s:initVariable("g:NERDTreeWinSize", 31)
calling function <SNR>21_initVariable('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinSize = '31'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 102: 
line 103: "init the shell commands that will be used to copy nodes, and remove dir trees
line 104: "
line 105: "Note: the space after the command is important
line 106: if nerdtree#runningWindows()
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 107:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
line 108:     call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')
line 109:     call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')
line 110: else
line 111:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
calling function <SNR>21_initVariable('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 112:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
calling function <SNR>21_initVariable('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCopyCmd = 'cp -r '
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 113: endif
line 114: 
line 115: 
line 116: "SECTION: Init variable calls for key mappings {{{2
line 117: call s:initVariable("g:NERDTreeMapActivateNode", "o")
calling function <SNR>21_initVariable('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapActivateNode = 'o'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 118: call s:initVariable("g:NERDTreeMapChangeRoot", "C")
calling function <SNR>21_initVariable('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChangeRoot = 'C'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 119: call s:initVariable("g:NERDTreeMapChdir", "cd")
calling function <SNR>21_initVariable('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChdir = 'cd'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 120: call s:initVariable("g:NERDTreeMapCloseChildren", "X")
calling function <SNR>21_initVariable('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseChildren = 'X'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 121: call s:initVariable("g:NERDTreeMapCloseDir", "x")
calling function <SNR>21_initVariable('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseDir = 'x'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 122: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
calling function <SNR>21_initVariable('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapDeleteBookmark = 'D'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 123: call s:initVariable("g:NERDTreeMapMenu", "m")
calling function <SNR>21_initVariable('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapMenu = 'm'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 124: call s:initVariable("g:NERDTreeMapHelp", "?")
calling function <SNR>21_initVariable('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapHelp = '?'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 125: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpFirstChild = 'K'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 126: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpLastChild = 'J'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 127: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 128: call s:initVariable("g:NERDTreeMapJumpParent", "p")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpParent = 'p'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 129: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 130: call s:initVariable("g:NERDTreeMapJumpRoot", "P")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpRoot = 'P'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 131: call s:initVariable("g:NERDTreeMapOpenExpl", "e")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenExpl = 'e'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 132: call s:initVariable("g:NERDTreeMapOpenInTab", "t")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTab = 't'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 133: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTabSilent = 'T'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 134: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenRecursively = 'O'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 135: call s:initVariable("g:NERDTreeMapOpenSplit", "i")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenSplit = 'i'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 136: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenVSplit = 's'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 137: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
calling function <SNR>21_initVariable('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreview = 'go'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 138: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
calling function <SNR>21_initVariable('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewSplit = 'gi'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 139: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
calling function <SNR>21_initVariable('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewVSplit = 'gs'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 140: call s:initVariable("g:NERDTreeMapQuit", "q")
calling function <SNR>21_initVariable('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapQuit = 'q'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 141: call s:initVariable("g:NERDTreeMapRefresh", "r")
calling function <SNR>21_initVariable('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefresh = 'r'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 142: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
calling function <SNR>21_initVariable('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefreshRoot = 'R'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 143: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleBookmarks = 'B'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 144: call s:initVariable("g:NERDTreeMapToggleFiles", "F")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFiles = 'F'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 145: call s:initVariable("g:NERDTreeMapToggleFilters", "f")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFilters = 'f'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 146: call s:initVariable("g:NERDTreeMapToggleHidden", "I")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleHidden = 'I'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 147: call s:initVariable("g:NERDTreeMapToggleZoom", "A")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleZoom = 'A'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 148: call s:initVariable("g:NERDTreeMapUpdir", "u")
calling function <SNR>21_initVariable('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdir = 'u'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 149: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
calling function <SNR>21_initVariable('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 150: call s:initVariable("g:NERDTreeMapCWD", "CD")
calling function <SNR>21_initVariable('g:NERDTreeMapCWD', 'CD')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCWD = 'CD'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 151: call s:initVariable("g:NERDTreeMenuDown", "j")
calling function <SNR>21_initVariable('g:NERDTreeMenuDown', 'j')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuDown = 'j'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 152: call s:initVariable("g:NERDTreeMenuUp", "k")
calling function <SNR>21_initVariable('g:NERDTreeMenuUp', 'k')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuUp = 'k'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 153: 
line 154: "SECTION: Load class files{{{2
line 155: call nerdtree#loadClassFiles()
calling function nerdtree#loadClassFiles()

line 1:     runtime lib/nerdtree/path.vim
Searching for "lib/nerdtree/path.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
line 1: " ============================================================================
line 2: " CLASS: Path
line 3: "
line 4: " The Path class provides an abstracted representation of a file system
line 5: " pathname.  Various operations on pathnames are provided and a number of
line 6: " representations of a given path name can be accessed here.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:Path = {}
line 11: let g:NERDTreePath = s:Path
line 12: 
line 13: " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
line 14: function! s:Path.AbsolutePathFor(pathStr)
line 31: 
line 32: " FUNCTION: Path.bookmarkNames() {{{1
line 33: function! s:Path.bookmarkNames()
line 39: 
line 40: " FUNCTION: Path.cacheDisplayString() {{{1
line 41: function! s:Path.cacheDisplayString() abort
line 66: 
line 67: " FUNCTION: Path.addDelimiter() {{{1
line 68: function! s:Path.addDelimiter(line)
line 75: 
line 76: " FUNCTION: Path.changeToDir() {{{1
line 77: function! s:Path.changeToDir()
line 90: 
line 91: " FUNCTION: Path.compareTo() {{{1
line 92: "
line 93: " Compares this Path to the given path and returns 0 if they are equal, -1 if
line 94: " this Path is "less than" the given path, or 1 if it is "greater".
line 95: "
line 96: " Args:
line 97: " path: the path object to compare this to
line 98: "
line 99: " Return:
line 100: " 1, -1 or 0
line 101: function! s:Path.compareTo(path)
line 134: 
line 135: " FUNCTION: Path.Create(fullpath) {{{1
line 136: "
line 137: " Factory method.
line 138: "
line 139: " Creates a path object with the given path. The path is also created on the
line 140: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
line 141: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
line 142: "
line 143: " Args:
line 144: " fullpath: the full filesystem path to the file/dir to create
line 145: function! s:Path.Create(fullpath)
line 171: 
line 172: " FUNCTION: Path.copy(dest) {{{1
line 173: "
line 174: " Copies the file/dir represented by this Path to the given location
line 175: "
line 176: " Args:
line 177: " dest: the location to copy this dir/file to
line 178: function! s:Path.copy(dest)
line 197: 
line 198: " FUNCTION: Path.CopyingSupported() {{{1
line 199: "
line 200: " returns 1 if copying is supported for this OS
line 201: function! s:Path.CopyingSupported()
line 204: 
line 205: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
line 206: "
line 207: " returns 1 if copy this path to the given location will cause files to
line 208: " overwritten
line 209: "
line 210: " Args:
line 211: " dest: the location this path will be copied to
line 212: function! s:Path.copyingWillOverwrite(dest)
line 224: 
line 225: " FUNCTION: Path.createParentDirectories(path) {{{1
line 226: "
line 227: " create parent directories for this path if needed
line 228: " without throwing any errors if those directories already exist
line 229: "
line 230: " Args:
line 231: " path: full path of the node whose parent directories may need to be created
line 232: function! s:Path.createParentDirectories(path)
line 238: 
line 239: " FUNCTION: Path.delete() {{{1
line 240: "
line 241: " Deletes the file or directory represented by this path.
line 242: "
line 243: " Throws NERDTree.Path.Deletion exceptions
line 244: function! s:Path.delete()
line 272: 
line 273: " FUNCTION: Path.displayString() {{{1
line 274: "
line 275: " Returns a string that specifies how the path should be represented as a
line 276: " string
line 277: function! s:Path.displayString()
line 284: 
line 285: " FUNCTION: Path.edit() {{{1
line 286: function! s:Path.edit()
line 289: 
line 290: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
line 291: "
line 292: " If running windows, cache the drive letter for this path
line 293: function! s:Path.extractDriveLetter(fullpath)
line 307: 
line 308: " FUNCTION: Path.exists() {{{1
line 309: " return 1 if this path points to a location that is readable or is a directory
line 310: function! s:Path.exists()
line 314: 
line 315: " FUNCTION: Path._escChars() {{{1
line 316: function! s:Path._escChars()
line 323: 
line 324: " FUNCTION: Path.getDir() {{{1
line 325: "
line 326: " Returns this path if it is a directory, else this paths parent.
line 327: "
line 328: " Return:
line 329: " a Path object
line 330: function! s:Path.getDir()
line 337: 
line 338: " FUNCTION: Path.getParent() {{{1
line 339: "
line 340: " Returns a new path object for this paths parent
line 341: "
line 342: " Return:
line 343: " a new Path object
line 344: function! s:Path.getParent()
line 353: 
line 354: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
line 355: "
line 356: " Gets the last part of this path.
line 357: "
line 358: " Args:
line 359: " dirSlash: if 1 then a trailing slash will be added to the returned value for
line 360: " directory nodes.
line 361: function! s:Path.getLastPathComponent(dirSlash)
line 371: 
line 372: " FUNCTION: Path.getSortOrderIndex() {{{1
line 373: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
line 374: function! s:Path.getSortOrderIndex()
line 385: 
line 386: " FUNCTION: Path._splitChunks(path) {{{1
line 387: " returns a list of path chunks
line 388: function! s:Path._splitChunks(path)
line 400: 
line 401: " FUNCTION: Path.getSortKey() {{{1
line 402: " returns a key used in compare function for sorting
line 403: function! s:Path.getSortKey()
line 427: 
line 428: " FUNCTION: Path.isHiddenUnder(path) {{{1
line 429: function! s:Path.isHiddenUnder(path)
line 447: 
line 448: " FUNCTION: Path.isUnixHiddenFile() {{{1
line 449: " check for unix hidden files
line 450: function! s:Path.isUnixHiddenFile()
line 453: 
line 454: " FUNCTION: Path.isUnixHiddenPath() {{{1
line 455: " check for unix path with hidden components
line 456: function! s:Path.isUnixHiddenPath()
line 468: 
line 469: " FUNCTION: Path.ignore(nerdtree) {{{1
line 470: " returns true if this path should be ignored
line 471: function! s:Path.ignore(nerdtree)
line 498: 
line 499: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
line 500: " returns true if this path matches the given ignore pattern
line 501: function! s:Path._ignorePatternMatches(pattern)
line 517: 
line 518: " FUNCTION: Path.isAncestor(path) {{{1
line 519: " return 1 if this path is somewhere above the given path in the filesystem.
line 520: "
line 521: " a:path should be a dir
line 522: function! s:Path.isAncestor(path)
line 531: 
line 532: " FUNCTION: Path.isUnder(path) {{{1
line 533: " return 1 if this path is somewhere under the given path in the filesystem.
line 534: function! s:Path.isUnder(path)
line 543: 
line 544: " FUNCTION: Path.JoinPathStrings(...) {{{1
line 545: function! s:Path.JoinPathStrings(...)
line 552: 
line 553: " FUNCTION: Path.equals() {{{1
line 554: "
line 555: " Determines whether 2 path objects are "equal".
line 556: " They are equal if the paths they represent are the same
line 557: "
line 558: " Args:
line 559: " path: the other path obj to compare this with
line 560: function! s:Path.equals(path)
line 563: 
line 564: " FUNCTION: Path.New(pathStr) {{{1
line 565: function! s:Path.New(pathStr)
line 575: 
line 576: " FUNCTION: Path.Slash() {{{1
line 577: " Return the path separator used by the underlying file system.  Special
line 578: " consideration is taken for the use of the 'shellslash' option on Windows
line 579: " systems.
line 580: function! s:Path.Slash()
line 592: 
line 593: " FUNCTION: Path.Resolve() {{{1
line 594: " Invoke the vim resolve() function and return the result
line 595: " This is necessary because in some versions of vim resolve() removes trailing
line 596: " slashes while in other versions it doesn't.  This always removes the trailing
line 597: " slash
line 598: function! s:Path.Resolve(path)
line 602: 
line 603: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
line 604: "
line 605: "
line 606: " Throws NERDTree.Path.InvalidArguments exception.
line 607: function! s:Path.readInfoFromDisk(fullpath)
line 656: 
line 657: " FUNCTION: Path.refresh(nerdtree) {{{1
line 658: function! s:Path.refresh(nerdtree)
line 663: 
line 664: " FUNCTION: Path.refreshFlags(nerdtree) {{{1
line 665: function! s:Path.refreshFlags(nerdtree)
line 669: 
line 670: " FUNCTION: Path.rename() {{{1
line 671: "
line 672: " Renames this node on the filesystem
line 673: function! s:Path.rename(newPath)
line 692: 
line 693: " FUNCTION: Path.str() {{{1
line 694: " Return a string representation of this Path object.
line 695: "
line 696: " Args:
line 697: " This function takes a single dictionary (optional) with keys and values that
line 698: " specify how the returned pathname should be formatted.
line 699: "
line 700: " The dictionary may have the following keys:
line 701: "  'format'
line 702: "  'escape'
line 703: "  'truncateTo'
line 704: "
line 705: " The 'format' key may have a value of:
line 706: "  'Cd' - a string to be used with ":cd" and similar commands
line 707: "  'Edit' - a string to be used with ":edit" and similar commands
line 708: "  'UI' - a string to be displayed in the NERDTree user interface
line 709: "
line 710: " The 'escape' key, if specified, will cause the output to be escaped with
line 711: " Vim's internal "shellescape()" function.
line 712: "
line 713: " The 'truncateTo' key shortens the length of the path to that given by the
line 714: " value associated with 'truncateTo'. A '<' is prepended.
line 715: function! s:Path.str(...)
line 750: 
line 751: " FUNCTION: Path._strForUI() {{{1
line 752: function! s:Path._strForUI()
line 759: 
line 760: " FUNCTION: Path._strForCd() {{{1
line 761: " Return a string representation of this Path that is suitable for use as an
line 762: " argument to Vim's internal ":cd" command.
line 763: function! s:Path._strForCd()
line 766: 
line 767: " FUNCTION: Path._strForEdit() {{{1
line 768: " Return a string representation of this Path that is suitable for use as an
line 769: " argument to Vim's internal ":edit" command.
line 770: function! s:Path._strForEdit()
line 789: 
line 790: " FUNCTION: Path._strForGlob() {{{1
line 791: function! s:Path._strForGlob()
line 806: 
line 807: " FUNCTION: Path._str() {{{1
line 808: " Return the absolute pathname associated with this Path object.  The pathname
line 809: " returned is appropriate for the underlying file system.
line 810: function! s:Path._str()
line 820: 
line 821: " FUNCTION: Path.strTrunk() {{{1
line 822: " Gets the path without the last segment on the end.
line 823: function! s:Path.strTrunk()
line 826: 
line 827: " FUNCTION: Path.tabnr() {{{1
line 828: " return the number of the first tab that is displaying this file
line 829: "
line 830: " return 0 if no tab was found
line 831: function! s:Path.tabnr()
line 842: 
line 843: " FUNCTION: Path.WinToUnixPath(pathstr){{{1
line 844: " Takes in a windows path and returns the unix equiv
line 845: "
line 846: " A class level method
line 847: "
line 848: " Args:
line 849: " pathstr: the windows path to convert
line 850: function! s:Path.WinToUnixPath(pathstr)
line 868: 
line 869: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim
continuing in function nerdtree#loadClassFiles
line 2:     runtime lib/nerdtree/menu_controller.vim
Searching for "lib/nerdtree/menu_controller.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
line 1: "CLASS: MenuController
line 2: "============================================================
line 3: let s:MenuController = {}
line 4: let g:NERDTreeMenuController = s:MenuController
line 5: 
line 6: "FUNCTION: MenuController.New(menuItems) {{{1
line 7: "create a new menu controller that operates on the given menu items
line 8: function! s:MenuController.New(menuItems)
line 17: 
line 18: " FUNCTION: MenuController.showMenu() {{{1
line 19: " Enter the main loop of the NERDTree menu, prompting the user to select
line 20: " a menu item.
line 21: function! s:MenuController.showMenu()
line 49: 
line 50: "FUNCTION: MenuController._echoPrompt() {{{1
line 51: function! s:MenuController._echoPrompt()
line 63: 
line 64: "FUNCTION: MenuController._current(key) {{{1
line 65: "get the MenuItem that is currently selected
line 66: function! s:MenuController._current()
line 69: 
line 70: "FUNCTION: MenuController._handleKeypress(key) {{{1
line 71: "change the selection (if appropriate) and return 1 if the user has made
line 72: "their choice, 0 otherwise
line 73: function! s:MenuController._handleKeypress(key)
line 95: 
line 96: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
line 97: "get indexes to all menu items with the given shortcut
line 98: function! s:MenuController._allIndexesFor(shortcut)
line 109: 
line 110: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
line 111: "get the index to the next menu item with the given shortcut, starts from the
line 112: "current cursor location and wraps around to the top again if need be
line 113: function! s:MenuController._nextIndexFor(shortcut)
line 128: 
line 129: "FUNCTION: MenuController._setCmdheight() {{{1
line 130: "sets &cmdheight to whatever is needed to display the menu
line 131: function! s:MenuController._setCmdheight()
line 134: 
line 135: "FUNCTION: MenuController._saveOptions() {{{1
line 136: "set any vim options that are required to make the menu work (saving their old
line 137: "values)
line 138: function! s:MenuController._saveOptions()
line 144: 
line 145: "FUNCTION: MenuController._restoreOptions() {{{1
line 146: "restore the options we saved in _saveOptions()
line 147: function! s:MenuController._restoreOptions()
line 151: 
line 152: "FUNCTION: MenuController._cursorDown() {{{1
line 153: "move the cursor to the next menu item, skipping separators
line 154: function! s:MenuController._cursorDown()
line 168: 
line 169: "FUNCTION: MenuController._cursorUp() {{{1
line 170: "move the cursor to the previous menu item, skipping separators
line 171: function! s:MenuController._cursorUp()
line 185: 
line 186: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim
continuing in function nerdtree#loadClassFiles
line 3:     runtime lib/nerdtree/menu_item.vim
Searching for "lib/nerdtree/menu_item.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 3: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
line 1: "CLASS: MenuItem
line 2: "============================================================
line 3: let s:MenuItem = {}
line 4: let g:NERDTreeMenuItem = s:MenuItem
line 5: 
line 6: "FUNCTION: MenuItem.All() {{{1
line 7: "get all top level menu items
line 8: function! s:MenuItem.All()
line 14: 
line 15: "FUNCTION: MenuItem.AllEnabled() {{{1
line 16: "get all top level menu items that are currently enabled
line 17: function! s:MenuItem.AllEnabled()
line 26: 
line 27: "FUNCTION: MenuItem.Create(options) {{{1
line 28: "make a new menu item and add it to the global list
line 29: function! s:MenuItem.Create(options)
line 54: 
line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1
line 56: "make a new separator menu item and add it to the global list
line 57: function! s:MenuItem.CreateSeparator(options)
line 65: 
line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
line 67: "make a new submenu and add it to global list
line 68: function! s:MenuItem.CreateSubmenu(options)
line 74: 
line 75: "FUNCTION: MenuItem.enabled() {{{1
line 76: "return 1 if this menu item should be displayed
line 77: "
line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was
line 79: "specified
line 80: function! s:MenuItem.enabled()
line 86: 
line 87: "FUNCTION: MenuItem.execute() {{{1
line 88: "perform the action behind this menu item, if this menuitem has children then
line 89: "display a new menu for them, otherwise deletegate off to the menuitem's
line 90: "callback
line 91: function! s:MenuItem.execute()
line 101: 
line 102: "FUNCTION: MenuItem.isSeparator() {{{1
line 103: "return 1 if this menuitem is a separator
line 104: function! s:MenuItem.isSeparator()
line 107: 
line 108: "FUNCTION: MenuItem.isSubmenu() {{{1
line 109: "return 1 if this menuitem is a submenu
line 110: function! s:MenuItem.isSubmenu()
line 113: 
line 114: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim
continuing in function nerdtree#loadClassFiles
line 4:     runtime lib/nerdtree/key_map.vim
Searching for "lib/nerdtree/key_map.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 4: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
line 1: "CLASS: KeyMap
line 2: "============================================================
line 3: let s:KeyMap = {}
line 4: let g:NERDTreeKeyMap = s:KeyMap
line 5: let s:keyMaps = {}
line 6: 
line 7: "FUNCTION: KeyMap.All() {{{1
line 8: function! s:KeyMap.All()
line 14: 
line 15: "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
line 16: function! s:KeyMap.Compare(keyMap1, keyMap2)
line 28: 
line 29: "FUNCTION: KeyMap.FindFor(key, scope) {{{1
line 30: function! s:KeyMap.FindFor(key, scope)
line 33: 
line 34: "FUNCTION: KeyMap.BindAll() {{{1
line 35: function! s:KeyMap.BindAll()
line 40: 
line 41: "FUNCTION: KeyMap.bind() {{{1
line 42: function! s:KeyMap.bind()
line 59: 
line 60: "FUNCTION: KeyMap.Remove(key, scope) {{{1
line 61: function! s:KeyMap.Remove(key, scope)
line 64: 
line 65: "FUNCTION: KeyMap.invoke() {{{1
line 66: "Call the KeyMaps callback function
line 67: function! s:KeyMap.invoke(...)
line 75: 
line 76: "FUNCTION: KeyMap.Invoke() {{{1
line 77: "Find a keymapping for a:key and the current scope invoke it.
line 78: "
line 79: "Scope is determined as follows:
line 80: "   * if the cursor is on a dir node then "DirNode"
line 81: "   * if the cursor is on a file node then "FileNode"
line 82: "   * if the cursor is on a bookmark then "Bookmark"
line 83: "
line 84: "If a keymap has the scope of "all" then it will be called if no other keymap
line 85: "is found for a:key and the scope.
line 86: function! s:KeyMap.Invoke(key)
line 139: 
line 140: "FUNCTION: KeyMap.Create(options) {{{1
line 141: function! s:KeyMap.Create(options)
line 157: 
line 158: "FUNCTION: KeyMap.Add(keymap) {{{1
line 159: function! s:KeyMap.Add(keymap)
line 162: 
line 163: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim
continuing in function nerdtree#loadClassFiles
line 5:     runtime lib/nerdtree/bookmark.vim
Searching for "lib/nerdtree/bookmark.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
line 1: " ============================================================================
line 2: " CLASS: Bookmark
line 3: "
line 4: " The Bookmark class serves two purposes:
line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.
line 6: "   (2) It provides an interface for client code to query and manipulate the
line 7: "       global list of Bookmark objects within the current Vim session.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Bookmark = {}
line 12: let g:NERDTreeBookmark = s:Bookmark
line 13: 
line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1
line 15: function! s:Bookmark.activate(nerdtree, ...)
line 18: 
line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists
line 21: " with the same name, just update the path for that bookmark
line 22: function! s:Bookmark.AddBookmark(name, path)
line 31: 
line 32: " FUNCTION: Bookmark.Bookmarks() {{{1
line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global
line 34: " variable
line 35: function! s:Bookmark.Bookmarks()
line 41: 
line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
line 43: " class method that returns 1 if a bookmark with the given name is found, 0
line 44: " otherwise
line 45: function! s:Bookmark.BookmarkExistsFor(name)
line 53: 
line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1
line 55: " Class method that returns the Bookmark object having the specified name.
line 56: " Throws "NERDTree.BookmarkNotFoundError" if no Bookmark is found.
line 57: function! s:Bookmark.BookmarkFor(name)
line 70: 
line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1
line 72: " Class method to return an array of all bookmark names
line 73: function! s:Bookmark.BookmarkNames()
line 80: 
line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
line 82: " Class method to read all bookmarks from the bookmarks file initialize
line 83: " bookmark objects for each one.
line 84: "
line 85: " Args:
line 86: " silent - dont echo an error msg if invalid bookmarks are found
line 87: function! s:Bookmark.CacheBookmarks(silent)
line 119: 
line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
line 121: " Class method that indicates the relative position of two bookmarks when
line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an
line 123: " option. Supports the "s:Bookmark.SortBookmarksList()" method.
line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
line 141: 
line 142: " FUNCTION: Bookmark.ClearAll() {{{1
line 143: " Class method to delete all bookmarks.
line 144: function! s:Bookmark.ClearAll()
line 150: 
line 151: " FUNCTION: Bookmark.delete() {{{1
line 152: " Delete this bookmark. If the node for this bookmark is under the current
line 153: " root, then recache bookmarks for its Path object
line 154: function! s:Bookmark.delete()
line 158: 
line 159: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
line 160: " Returns the tree node object associated with this Bookmark.
line 161: " Throws "NERDTree.BookmarkedNodeNotFoundError" if the node is not found.
line 162: "
line 163: " Args:
line 164: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
line 165: "   if true and from the current tree root if false
line 166: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
line 178: 
line 179: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
line 180: " Class method that returns the tree node object for the Bookmark with the
line 181: " given name. Throws "NERDTree.BookmarkNotFoundError" if a Bookmark with the
line 182: " name does not exist. Throws "NERDTree.BookmarkedNodeNotFoundError" if a
line 183: " tree node for the named Bookmark could not be found.
line 184: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
line 188: 
line 189: " FUNCTION: Bookmark.GetSelected() {{{1
line 190: " returns the Bookmark the cursor is over, or {}
line 191: function! s:Bookmark.GetSelected()
line 203: 
line 204: " FUNCTION: Bookmark.InvalidBookmarks() {{{1
line 205: " Class method to get all invalid bookmark strings read from the bookmarks
line 206: " file
line 207: function! s:Bookmark.InvalidBookmarks()
line 213: 
line 214: " FUNCTION: Bookmark.mustExist() {{{1
line 215: function! s:Bookmark.mustExist()
line 222: 
line 223: " FUNCTION: Bookmark.New(name, path) {{{1
line 224: " Create a new bookmark object with the given name and path object
line 225: function! s:Bookmark.New(name, path)
line 235: 
line 236: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
line 237: "Args:
line 238: "
line 239: "nerdtree: the tree to load open the bookmark in
line 240: "
line 241: "A dictionary containing the following keys (all optional):
line 242: "  'where': Specifies whether the node should be opened in new split/tab or in
line 243: "           the previous window. Can be either 'v' (vertical split), 'h'
line 244: "           (horizontal split), 't' (new tab) or 'p' (previous window).
line 245: "  'reuse': if a window is displaying the file then jump the cursor there
line 246: "  'keepopen': dont close the tree window
line 247: "  'stay': open the file, but keep the cursor in the tree win
line 248: "
line 249: function! s:Bookmark.open(nerdtree, ...)
line 259: 
line 260: " FUNCTION: Bookmark.openInNewTab(options) {{{1
line 261: " Create a new bookmark object with the given name and path object
line 262: function! s:Bookmark.openInNewTab(options)
line 266: 
line 267: " FUNCTION: Bookmark.setPath(path) {{{1
line 268: " makes this bookmark point to the given path
line 269: function! s:Bookmark.setPath(path)
line 272: 
line 273: " FUNCTION: Bookmark.SortBookmarksList() {{{1
line 274: " Class method that sorts the global list of bookmarks alphabetically by name.
line 275: " Note that case-sensitivity is determined by a user option.
line 276: function! s:Bookmark.SortBookmarksList()
line 279: 
line 280: " FUNCTION: Bookmark.str() {{{1
line 281: " Get the string that should be rendered in the view for this bookmark
line 282: function! s:Bookmark.str()
line 297: 
line 298: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
line 299: " Set the root of the given NERDTree to the node for this Bookmark. If a node
line 300: " for this Bookmark does not exist, a new one is initialized.
line 301: function! s:Bookmark.toRoot(nerdtree)
line 312: 
line 313: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
line 314: " Class method that makes the Bookmark with the given name the root of
line 315: " specified NERDTree.
line 316: function! s:Bookmark.ToRoot(name, nerdtree)
line 320: 
line 321: " FUNCTION: Bookmark.validate() {{{1
line 322: function! s:Bookmark.validate()
line 331: 
line 332: " FUNCTION: Bookmark.Write() {{{1
line 333: " Class method to write all bookmarks to the bookmarks file
line 334: function! s:Bookmark.Write()
line 353: 
line 354: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim
continuing in function nerdtree#loadClassFiles
line 6:     runtime lib/nerdtree/tree_file_node.vim
Searching for "lib/nerdtree/tree_file_node.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 6: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeFileNode
line 3: "
line 4: " This class is the parent of the "TreeDirNode" class and is the "Component"
line 5: " part of the composite design pattern between the NERDTree node classes.
line 6: " ============================================================================
line 7: 
line 8: 
line 9: let s:TreeFileNode = {}
line 10: let g:NERDTreeFileNode = s:TreeFileNode
line 11: 
line 12: " FUNCTION: TreeFileNode.activate(...) {{{1
line 13: function! s:TreeFileNode.activate(...)
line 16: 
line 17: " FUNCTION: TreeFileNode.bookmark(name) {{{1
line 18: " bookmark this node with a:name
line 19: function! s:TreeFileNode.bookmark(name)
line 38: 
line 39: " FUNCTION: TreeFileNode.cacheParent() {{{1
line 40: " initializes self.parent if it isnt already
line 41: function! s:TreeFileNode.cacheParent()
line 50: 
line 51: " FUNCTION: TreeFileNode.clearBookmarks() {{{1
line 52: function! s:TreeFileNode.clearBookmarks()
line 60: 
line 61: " FUNCTION: TreeFileNode.copy(dest) {{{1
line 62: function! s:TreeFileNode.copy(dest)
line 73: 
line 74: " FUNCTION: TreeFileNode.delete {{{1
line 75: " Removes this node from the tree and calls the Delete method for its path obj
line 76: function! s:TreeFileNode.delete()
line 80: 
line 81: " FUNCTION: TreeFileNode.displayString() {{{1
line 82: "
line 83: " Returns a string that specifies how the node should be represented as a
line 84: " string
line 85: "
line 86: " Return:
line 87: " a string that can be used in the view to represent this node
line 88: function! s:TreeFileNode.displayString()
line 91: 
line 92: " FUNCTION: TreeFileNode.equals(treenode) {{{1
line 93: "
line 94: " Compares this treenode to the input treenode and returns 1 if they are the
line 95: " same node.
line 96: "
line 97: " Use this method instead of ==  because sometimes when the treenodes contain
line 98: " many children, vim seg faults when doing ==
line 99: "
line 100: " Args:
line 101: " treenode: the other treenode to compare to
line 102: function! s:TreeFileNode.equals(treenode)
line 105: 
line 106: " FUNCTION: TreeFileNode.findNode(path) {{{1
line 107: " Returns self if this node.path.Equals the given path.
line 108: " Returns {} if not equal.
line 109: "
line 110: " Args:
line 111: " path: the path object to compare against
line 112: function! s:TreeFileNode.findNode(path)
line 118: 
line 119: " FUNCTION: TreeFileNode.findSibling(direction) {{{1
line 120: " Find the next or previous sibling of this node.
line 121: "
line 122: " Args:
line 123: " direction: 0 for previous, 1 for next
line 124: "
line 125: " Return:
line 126: " The next/previous TreeFileNode object or an empty dictionary if not found.
line 127: function! s:TreeFileNode.findSibling(direction)
line 155: 
line 156: " FUNCTION: TreeFileNode.getNerdtree(){{{1
line 157: function! s:TreeFileNode.getNerdtree()
line 160: 
line 161: " FUNCTION: TreeFileNode.GetRootForTab(){{{1
line 162: " get the root node for this tab
line 163: function! s:TreeFileNode.GetRootForTab()
line 169: 
line 170: " FUNCTION: TreeFileNode.GetSelected() {{{1
line 171: " If the cursor is currently positioned on a tree node, return the node.
line 172: " Otherwise, return the empty dictionary.
line 173: function! s:TreeFileNode.GetSelected()
line 187: 
line 188: " FUNCTION: TreeFileNode.isVisible() {{{1
line 189: " returns 1 if this node should be visible according to the tree filters and
line 190: " hidden file filters (and their on/off status)
line 191: function! s:TreeFileNode.isVisible()
line 194: 
line 195: " FUNCTION: TreeFileNode.isRoot() {{{1
line 196: function! s:TreeFileNode.isRoot()
line 203: 
line 204: " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
line 205: " Returns a new TreeNode object with the given path and parent
line 206: "
line 207: " Args:
line 208: " path: file/dir that the node represents
line 209: " nerdtree: the tree the node belongs to
line 210: function! s:TreeFileNode.New(path, nerdtree)
line 221: 
line 222: " FUNCTION: TreeFileNode.open() {{{1
line 223: function! s:TreeFileNode.open(...)
line 228: 
line 229: " FUNCTION: TreeFileNode.openSplit() {{{1
line 230: " Open this node in a new window
line 231: function! s:TreeFileNode.openSplit()
line 235: 
line 236: " FUNCTION: TreeFileNode.openVSplit() {{{1
line 237: " Open this node in a new vertical window
line 238: function! s:TreeFileNode.openVSplit()
line 242: 
line 243: " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
line 244: function! s:TreeFileNode.openInNewTab(options)
line 248: 
line 249: " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
line 250: " Places the cursor on the line number this node is rendered on
line 251: "
line 252: " Args:
line 253: " isJump: 1 if this cursor movement should be counted as a jump by vim
line 254: " recurseUpward: try to put the cursor on the parent if the this node isnt
line 255: " visible
line 256: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
line 275: 
line 276: " FUNCTION: TreeFileNode.refresh() {{{1
line 277: function! s:TreeFileNode.refresh()
line 280: 
line 281: " FUNCTION: TreeFileNode.refreshFlags() {{{1
line 282: function! s:TreeFileNode.refreshFlags()
line 285: 
line 286: " FUNCTION: TreeFileNode.rename() {{{1
line 287: " Calls the rename method for this nodes path obj
line 288: function! s:TreeFileNode.rename(newName)
line 301: 
line 302: " FUNCTION: TreeFileNode.renderToString {{{1
line 303: " returns a string representation for this tree to be rendered in the view
line 304: function! s:TreeFileNode.renderToString()
line 307: 
line 308: " Args:
line 309: " depth: the current depth in the tree for this call
line 310: " drawText: 1 if we should actually draw the line for this node (if 0 then the
line 311: " child nodes are rendered only)
line 312: " for each depth in the tree
line 313: function! s:TreeFileNode._renderToString(depth, drawText)
line 346: 
line 347: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim
continuing in function nerdtree#loadClassFiles
line 7:     runtime lib/nerdtree/tree_dir_node.vim
Searching for "lib/nerdtree/tree_dir_node.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 7: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeDirNode
line 3: "
line 4: " A subclass of NERDTreeFileNode.
line 5: "
line 6: " The 'composite' part of the file/dir composite.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)
line 11: let g:NERDTreeDirNode = s:TreeDirNode
line 12: 
line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
line 14: " Class method that returns the highest cached ancestor of the current root.
line 15: function! s:TreeDirNode.AbsoluteTreeRoot()
line 22: 
line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1
line 24: function! s:TreeDirNode.activate(...)
line 38: 
line 39: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
line 40: " Adds the given treenode to the list of children for this node
line 41: "
line 42: " Args:
line 43: " -treenode: the node to add
line 44: " -inOrder: 1 if the new node should be inserted in sorted order
line 45: function! s:TreeDirNode.addChild(treenode, inOrder)
line 53: 
line 54: " FUNCTION: TreeDirNode.close() {{{1
line 55: " Mark this TreeDirNode as closed.
line 56: function! s:TreeDirNode.close()
line 64: 
line 65: " FUNCTION: TreeDirNode.closeChildren() {{{1
line 66: " Recursively close any directory nodes that are descendants of this node.
line 67: function! s:TreeDirNode.closeChildren()
line 75: 
line 76: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
line 77: " Instantiates a new child node for this node with the given path. The new
line 78: " nodes parent is set to this node.
line 79: "
line 80: " Args:
line 81: " path: a Path object that this node will represent/contain
line 82: " inOrder: 1 if the new node should be inserted in sorted order
line 83: "
line 84: " Returns:
line 85: " the newly created node
line 86: function! s:TreeDirNode.createChild(path, inOrder)
line 91: 
line 92: " FUNCTION: TreeDirNode.displayString() {{{1
line 93: " Assemble and return a string that can represent this TreeDirNode object in
line 94: " the NERDTree window.
line 95: function! s:TreeDirNode.displayString()
line 118: 
line 119: " FUNCTION: TreeDirNode.findNode(path) {{{1
line 120: " Will find one of the children (recursively) that has the given path
line 121: "
line 122: " Args:
line 123: " path: a path object
line 124: unlet s:TreeDirNode.findNode
line 125: function! s:TreeDirNode.findNode(path)
line 143: 
line 144: " FUNCTION: TreeDirNode.getCascade() {{{1
line 145: " Return an array of dir nodes (starting from self) that can be cascade opened.
line 146: function! s:TreeDirNode.getCascade()
line 156: 
line 157: " FUNCTION: TreeDirNode.getCascadeRoot() {{{1
line 158: " Return the first directory node in the cascade in which this directory node
line 159: " is rendered.
line 160: function! s:TreeDirNode.getCascadeRoot()
line 182: 
line 183: " FUNCTION: TreeDirNode.getChildCount() {{{1
line 184: " Returns the number of children this node has
line 185: function! s:TreeDirNode.getChildCount()
line 188: 
line 189: " FUNCTION: TreeDirNode.getChild(path) {{{1
line 190: " Returns child node of this node that has the given path or {} if no such node
line 191: " exists.
line 192: "
line 193: " This function doesnt not recurse into child dir nodes
line 194: "
line 195: " Args:
line 196: " path: a path object
line 197: function! s:TreeDirNode.getChild(path)
line 210: 
line 211: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
line 212: " returns the child at the given index
line 213: "
line 214: " Args:
line 215: " indx: the index to get the child from
line 216: " visible: 1 if only the visible children array should be used, 0 if all the
line 217: " children should be searched.
line 218: function! s:TreeDirNode.getChildByIndex(indx, visible)
line 225: 
line 226: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
line 227: " Returns the index of the child node of this node that has the given path or
line 228: " -1 if no such node exists.
line 229: "
line 230: " This function doesnt not recurse into child dir nodes
line 231: "
line 232: " Args:
line 233: " path: a path object
line 234: function! s:TreeDirNode.getChildIndex(path)
line 256: 
line 257: " FUNCTION: TreeDirNode.getDirChildren() {{{1
line 258: " Return a list of all child nodes from "self.children" that are of type
line 259: " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
line 260: function! s:TreeDirNode.getDirChildren()
line 263: 
line 264: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
line 265: " Return a list of strings naming the descendants of the directory in this
line 266: " TreeDirNode object that match the specified glob pattern.
line 267: "
line 268: " Args:
line 269: " pattern: (string) the glob pattern to apply
line 270: " all: (0 or 1) if 1, include "." and ".." if they match "pattern"; if 0,
line 271: "      always exclude them
line 272: "
line 273: " Note: If the pathnames in the result list are below the working directory,
line 274: " they are returned as pathnames relative to that directory. This is because
line 275: " this function, internally, attempts to obey 'wildignore' rules that use
line 276: " relative paths.
line 277: function! s:TreeDirNode._glob(pattern, all)
line 337: 
line 338: " FUNCTION: TreeDirNode.GetSelected() {{{1
line 339: " Returns the current node if it is a dir node, or else returns the current
line 340: " nodes parent
line 341: unlet s:TreeDirNode.GetSelected
line 342: function! s:TreeDirNode.GetSelected()
line 351: 
line 352: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
line 353: " Returns the number of visible children this node has
line 354: function! s:TreeDirNode.getVisibleChildCount()
line 357: 
line 358: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
line 359: " Returns a list of children to display for this node, in the correct order
line 360: "
line 361: " Return:
line 362: " an array of treenodes
line 363: function! s:TreeDirNode.getVisibleChildren()
line 372: 
line 373: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
line 374: " returns 1 if this node has any childre, 0 otherwise..
line 375: function! s:TreeDirNode.hasVisibleChildren()
line 378: 
line 379: " FUNCTION: TreeDirNode.isCascadable() {{{1
line 380: " true if this dir has only one visible child that is also a dir
line 381: " false if this dir is bookmarked or symlinked. Why? Two reasons:
line 382: "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
line 383: "  2. If the parent is a symlink or is bookmarked, you end up with unparsable
line 384: "     text, and NERDTree cannot get the path of any child node.
line 385: function! s:TreeDirNode.isCascadable()
line 403: 
line 404: " FUNCTION: TreeDirNode._initChildren() {{{1
line 405: " Removes all childen from this node and re-reads them
line 406: "
line 407: " Args:
line 408: " silent: 1 if the function should not echo any "please wait" messages for
line 409: " large directories
line 410: "
line 411: " Return: the number of child nodes read
line 412: function! s:TreeDirNode._initChildren(silent)
line 444: 
line 445: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
line 446: " Return a new TreeDirNode object with the given path and parent.
line 447: "
line 448: " Args:
line 449: " path: dir that the node represents
line 450: " nerdtree: the tree the node belongs to
line 451: function! s:TreeDirNode.New(path, nerdtree)
line 467: 
line 468: " FUNCTION: TreeDirNode.open([options]) {{{1
line 469: " Open this directory node in the current tree or elsewhere if special options
line 470: " are provided. Return 0 if options were processed. Otherwise, return the
line 471: " number of new cached nodes.
line 472: function! s:TreeDirNode.open(...)
line 502: 
line 503: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
line 504: " recursive open the dir if it has only one directory child.
line 505: "
line 506: " return the level of opened directories.
line 507: function! s:TreeDirNode.openAlong(...)
line 523: 
line 524: " FUNCTION: TreeDirNode.openExplorer() {{{1
line 525: " Open an explorer window for this node in the previous window. The explorer
line 526: " can be a NERDTree window or a netrw window.
line 527: function! s:TreeDirNode.openExplorer()
line 530: 
line 531: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
line 532: unlet s:TreeDirNode.openInNewTab
line 533: function! s:TreeDirNode.openInNewTab(options)
line 537: 
line 538: " FUNCTION: TreeDirNode._openInNewTab() {{{1
line 539: function! s:TreeDirNode._openInNewTab()
line 543: 
line 544: " FUNCTION: TreeDirNode.openRecursively() {{{1
line 545: " Open this directory node and any descendant directory nodes whose pathnames
line 546: " are not ignored.
line 547: function! s:TreeDirNode.openRecursively()
line 556: 
line 557: " FUNCTION: TreeDirNode.refresh() {{{1
line 558: function! s:TreeDirNode.refresh()
line 595: 
line 596: " FUNCTION: TreeDirNode.refreshFlags() {{{1
line 597: unlet s:TreeDirNode.refreshFlags
line 598: function! s:TreeDirNode.refreshFlags()
line 604: 
line 605: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
line 606: function! s:TreeDirNode.refreshDirFlags()
line 609: 
line 610: " FUNCTION: TreeDirNode.reveal(path) {{{1
line 611: " reveal the given path, i.e. cache and open all treenodes needed to display it
line 612: " in the UI
line 613: " Returns the revealed node
line 614: function! s:TreeDirNode.reveal(path, ...)
line 639: 
line 640: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
line 641: " Remove the given treenode from "self.children".
line 642: " Throws "NERDTree.ChildNotFoundError" if the node is not found.
line 643: "
line 644: " Args:
line 645: " treenode: the node object to remove
line 646: function! s:TreeDirNode.removeChild(treenode)
line 656: 
line 657: " FUNCTION: TreeDirNode.sortChildren() {{{1
line 658: " Sort "self.children" by alphabetical order and directory priority.
line 659: function! s:TreeDirNode.sortChildren()
line 667: 
line 668: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
line 669: " Opens this directory if it is closed and vice versa
line 670: function! s:TreeDirNode.toggleOpen(...)
line 682: 
line 683: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
line 684: " Replaces the child of this with the given node (where the child node's full
line 685: " path matches a:newNode's fullpath). The search for the matching node is
line 686: " non-recursive
line 687: "
line 688: " Arg:
line 689: " newNode: the node to graft into the tree
line 690: function! s:TreeDirNode.transplantChild(newNode)
line 699: 
line 700: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim
continuing in function nerdtree#loadClassFiles
line 8:     runtime lib/nerdtree/opener.vim
Searching for "lib/nerdtree/opener.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 8: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
line 1: " ============================================================================
line 2: " CLASS: Opener
line 3: "
line 4: " The Opener class defines an API for "opening" operations.
line 5: " ============================================================================
line 6: 
line 7: 
line 8: let s:Opener = {}
line 9: let g:NERDTreeOpener = s:Opener
line 10: 
line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]]
line 13: " Determine the number of windows open to this buffer number.
line 14: " Care of Yegappan Lakshman.  Thanks!
line 15: "
line 16: " Args:
line 17: " bnum: the subject buffers buffer number
line 18: function! s:Opener._bufInWindows(bnum)
line 34: 
line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
line 36: " Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
line 37: " if the tree should be closed now.
line 38: "
line 39: " Args:
line 40: " a:newtab - boolean. If set, only close the tree now if we are opening the
line 41: " target in a new tab. This is needed because we have to close tree before we
line 42: " leave the tab
line 43: function! s:Opener._checkToCloseTree(newtab)
line 52: 
line 53: " FUNCTION: s:Opener._firstUsableWindow() {{{1
line 54: " find the window number of the first normal window
line 55: function! s:Opener._firstUsableWindow()
line 69: 
line 70: " FUNCTION: Opener._gotoTargetWin() {{{1
line 71: function! s:Opener._gotoTargetWin()
line 96: 
line 97: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
line 98: " Returns 0 if opening a file from the tree in the given window requires it to
line 99: " be split, 1 otherwise
line 100: "
line 101: " Args:
line 102: " winnumber: the number of the window in question
line 103: function! s:Opener._isWindowUsable(winnumber)
line 127: 
line 128: " FUNCTION: Opener.New(path, opts) {{{1
line 129: " Instantiate a new NERDTreeOpener object.
line 130: " Args:
line 131: " a:path: the path object that is to be opened
line 132: " a:opts: a dictionary containing the following optional keys...
line 133: "   'where': specifies whether the node should be opened in new split, in
line 134: "            a new tab or, in the last window; takes values "v", "h", or "t"
line 135: "   'reuse': if file is already shown in a window, jump there; takes values
line 136: "            "all", "currenttab", or empty
line 137: "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
line 138: "   'stay': boolean (0 or 1); if true, remain in tree window after opening
line 139: function! s:Opener.New(path, opts)
line 153: 
line 154: " FUNCTION: Opener._newSplit() {{{1
line 155: function! s:Opener._newSplit()
line 213: 
line 214: " FUNCTION: Opener._newVSplit() {{{1
line 215: function! s:Opener._newVSplit()
line 233: 
line 234: " FUNCTION: Opener.open(target) {{{1
line 235: function! s:Opener.open(target)
line 243: 
line 244: " FUNCTION: Opener._openFile() {{{1
line 245: function! s:Opener._openFile()
line 264: 
line 265: " FUNCTION: Opener._openDirectory(node) {{{1
line 266: function! s:Opener._openDirectory(node)
line 285: 
line 286: " FUNCTION: Opener._previousWindow() {{{1
line 287: function! s:Opener._previousWindow()
line 305: 
line 306: " FUNCTION: Opener._restoreCursorPos() {{{1
line 307: function! s:Opener._restoreCursorPos()
line 311: 
line 312: " FUNCTION: Opener._reuseWindow() {{{1
line 313: " put the cursor in the first window we find for this file
line 314: "
line 315: " return 1 if we were successful
line 316: function! s:Opener._reuseWindow()
line 345: 
line 346: " FUNCTION: Opener._saveCursorPos() {{{1
line 347: function! s:Opener._saveCursorPos()
line 351: 
line 352: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim
continuing in function nerdtree#loadClassFiles
line 9:     runtime lib/nerdtree/creator.vim
Searching for "lib/nerdtree/creator.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 9: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
line 1: " ============================================================================
line 2: " CLASS: Creator
line 3: "
line 4: " This class is responsible for creating NERDTree instances.  The new NERDTree
line 5: " may be a tab tree, a window tree, or a mirrored tree.  In the process of
line 6: " creating a NERDTree, it sets up all of the window and buffer options and key
line 7: " mappings etc.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Creator = {}
line 12: let g:NERDTreeCreator = s:Creator
line 13: 
line 14: " FUNCTION: s:Creator._bindMappings() {{{1
line 15: function! s:Creator._bindMappings()
line 30: 
line 31: " FUNCTION: s:Creator._broadcastInitEvent() {{{1
line 32: function! s:Creator._broadcastInitEvent()
line 35: 
line 36: " FUNCTION: s:Creator.BufNamePrefix() {{{1
line 37: function! s:Creator.BufNamePrefix()
line 40: 
line 41: " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
line 42: function! s:Creator.CreateTabTree(name)
line 46: 
line 47: " FUNCTION: s:Creator.createTabTree(a:name) {{{1
line 48: " name: the name of a bookmark or a directory
line 49: function! s:Creator.createTabTree(name)
line 75: 
line 76: " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
line 77: function! s:Creator.CreateWindowTree(dir)
line 81: 
line 82: " FUNCTION: s:Creator.createWindowTree(dir) {{{1
line 83: function! s:Creator.createWindowTree(dir)
line 108: 
line 109: " FUNCTION: s:Creator._createNERDTree(path) {{{1
line 110: function! s:Creator._createNERDTree(path, type)
line 120: 
line 121: " FUNCTION: s:Creator.CreateMirror() {{{1
line 122: function! s:Creator.CreateMirror()
line 126: 
line 127: " FUNCTION: s:Creator.createMirror() {{{1
line 128: function! s:Creator.createMirror()
line 179: 
line 180: " FUNCTION: s:Creator._createTreeWin() {{{1
line 181: " Initialize the NERDTree window.  Open the window, size it properly, set all
line 182: " local options, etc.
line 183: function! s:Creator._createTreeWin()
line 204: 
line 205: " FUNCTION: s:Creator._isBufHidden(nr) {{{1
line 206: function! s:Creator._isBufHidden(nr)
line 213: 
line 214: " FUNCTION: s:Creator.New() {{{1
line 215: function! s:Creator.New()
line 219: 
line 220: " FUNCTION: s:Creator._nextBufferName() {{{2
line 221: " returns the buffer name for the next nerd tree
line 222: function! s:Creator._nextBufferName()
line 226: 
line 227: " FUNCTION: s:Creator._nextBufferNumber() {{{2
line 228: " the number to add to the nerd tree buffer name to make the buf name unique
line 229: function! s:Creator._nextBufferNumber()
line 238: 
line 239: " FUNCTION: s:Creator._pathForString(str) {{{1
line 240: " find a bookmark or adirectory for the given string
line 241: function! s:Creator._pathForString(str)
line 267: 
line 268: " Function: s:Creator._removeTreeBufForTab()   {{{1
line 269: function! s:Creator._removeTreeBufForTab()
line 284: 
line 285: " FUNCTION: s:Creator._setCommonBufOptions() {{{1
line 286: function! s:Creator._setCommonBufOptions()
line 322: 
line 323: " FUNCTION: s:Creator._setupStatusline() {{{1
line 324: function! s:Creator._setupStatusline()
line 329: 
line 330: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
line 331: function! s:Creator._tabpagevar(tabnr, var)
line 347: 
line 348: " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
line 349: function! s:Creator.ToggleTabTree(dir)
line 353: 
line 354: " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
line 355: " Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
line 356: " closed it is restored or initialized (if it doesnt exist)
line 357: "
line 358: " Args:
line 359: " dir: the full path for the root node (is only used if the NERD tree is being
line 360: " initialized.
line 361: function! s:Creator.toggleTabTree(dir)
line 376: 
line 377: " Function: s:Creator._uniq(list)   {{{1
line 378: " returns a:list without duplicates
line 379: function! s:Creator._uniq(list)
line 388: 
line 389: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim
continuing in function nerdtree#loadClassFiles
line 10:     runtime lib/nerdtree/flag_set.vim
Searching for "lib/nerdtree/flag_set.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 10: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
line 1: "CLASS: FlagSet
line 2: "============================================================
line 3: let s:FlagSet = {}
line 4: let g:NERDTreeFlagSet = s:FlagSet
line 5: 
line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
line 7: function! s:FlagSet.addFlag(scope, flag)
line 13: 
line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1
line 15: function! s:FlagSet.clearFlags(scope)
line 18: 
line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1
line 20: function! s:FlagSet._flagsForScope(scope)
line 26: 
line 27: "FUNCTION: FlagSet.New() {{{1
line 28: function! s:FlagSet.New()
line 33: 
line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
line 35: function! s:FlagSet.removeFlag(scope, flag)
line 43: 
line 44: "FUNCTION: FlagSet.renderToString() {{{1
line 45: function! s:FlagSet.renderToString()
line 57: 
line 58: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim
continuing in function nerdtree#loadClassFiles
line 11:     runtime lib/nerdtree/nerdtree.vim
Searching for "lib/nerdtree/nerdtree.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 11: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
line 1: "CLASS: NERDTree
line 2: "============================================================
line 3: let s:NERDTree = {}
line 4: let g:NERDTree = s:NERDTree
line 5: 
line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1
line 7: function! s:NERDTree.AddPathFilter(callback)
line 10: 
line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1
line 12: function! s:NERDTree.changeRoot(node)
line 32: 
line 33: "FUNCTION: s:NERDTree.Close() {{{1
line 34: "Closes the tab tree window for this tab
line 35: function! s:NERDTree.Close()
line 65: 
line 66: "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
line 67: "Closes the NERD tree window if the close on open option is set
line 68: function! s:NERDTree.CloseIfQuitOnOpen()
line 73: 
line 74: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
line 75: "Places the cursor at the top of the bookmarks table
line 76: function! s:NERDTree.CursorToBookmarkTable()
line 96: 
line 97: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
line 98: "Places the cursor in the nerd tree window
line 99: function! s:NERDTree.CursorToTreeWin()
line 103: 
line 104: " Function: s:NERDTree.ExistsForBuffer()   {{{1
line 105: " Returns 1 if a nerd tree root exists in the current buffer
line 106: function! s:NERDTree.ExistsForBuf()
line 109: 
line 110: " Function: s:NERDTree.ExistsForTab()   {{{1
line 111: " Returns 1 if a nerd tree root exists in the current tab
line 112: function! s:NERDTree.ExistsForTab()
line 120: 
line 121: function! s:NERDTree.ForCurrentBuf()
line 128: 
line 129: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
line 130: function! s:NERDTree.ForCurrentTab()
line 138: 
line 139: "FUNCTION: s:NERDTree.getRoot() {{{1
line 140: function! s:NERDTree.getRoot()
line 143: 
line 144: "FUNCTION: s:NERDTree.GetWinNum() {{{1
line 145: "gets the nerd tree window number for this tab
line 146: function! s:NERDTree.GetWinNum()
line 153: 
line 154: "FUNCTION: s:NERDTree.IsOpen() {{{1
line 155: function! s:NERDTree.IsOpen()
line 158: 
line 159: "FUNCTION: s:NERDTree.isTabTree() {{{1
line 160: function! s:NERDTree.isTabTree()
line 163: 
line 164: "FUNCTION: s:NERDTree.isWinTree() {{{1
line 165: function! s:NERDTree.isWinTree()
line 168: 
line 169: "FUNCTION: s:NERDTree.MustBeOpen() {{{1
line 170: function! s:NERDTree.MustBeOpen()
line 175: 
line 176: "FUNCTION: s:NERDTree.New() {{{1
line 177: function! s:NERDTree.New(path, type)
line 184: 
line 185: "FUNCTION: s:NERDTree.PathFilters() {{{1
line 186: function! s:NERDTree.PathFilters()
line 192: 
line 193: "FUNCTION: s:NERDTree.previousBuf() {{{1
line 194: function! s:NERDTree.previousBuf()
line 197: 
line 198: function! s:NERDTree.setPreviousBuf(bnum)
line 201: 
line 202: "FUNCTION: s:NERDTree.render() {{{1
line 203: "A convenience function - since this is called often
line 204: function! s:NERDTree.render()
line 207: 
line 208: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim
continuing in function nerdtree#loadClassFiles
line 12:     runtime lib/nerdtree/ui.vim
Searching for "lib/nerdtree/ui.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 12: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
line 1: " ============================================================================
line 2: " CLASS: UI
line 3: " ============================================================================
line 4: 
line 5: 
line 6: let s:UI = {}
line 7: let g:NERDTreeUI = s:UI
line 8: 
line 9: " FUNCTION: s:UI.centerView() {{{2
line 10: " centers the nerd tree window around the cursor (provided the nerd tree
line 11: " options permit)
line 12: function! s:UI.centerView()
line 22: 
line 23: " FUNCTION: s:UI._dumpHelp  {{{1
line 24: " prints out the quick help
line 25: function! s:UI._dumpHelp()
line 128: 
line 129: 
line 130: " FUNCTION: s:UI.new(nerdtree) {{{1
line 131: function! s:UI.New(nerdtree)
line 142: 
line 143: " FUNCTION: s:UI.getPath(ln) {{{1
line 144: " Return the "Path" object for the node that is rendered on the given line
line 145: " number.  If the "up a dir" line is selected, return the "Path" object for
line 146: " the parent of the root.  Return the empty dictionary if the given line
line 147: " does not reference a tree node.
line 148: function! s:UI.getPath(ln)
line 196: 
line 197: " FUNCTION: s:UI.getLineNum(node) {{{1
line 198: " Return the line number where the given node is rendered.  Return -1 if the
line 199: " given node is not visible.
line 200: function! s:UI.getLineNum(node)
line 245: 
line 246: " FUNCTION: s:UI.getRootLineNum(){{{1
line 247: " gets the line number of the root node
line 248: function! s:UI.getRootLineNum()
line 255: 
line 256: " FUNCTION: s:UI.getShowBookmarks() {{{1
line 257: function! s:UI.getShowBookmarks()
line 260: 
line 261: " FUNCTION: s:UI.getShowFiles() {{{1
line 262: function! s:UI.getShowFiles()
line 265: 
line 266: " FUNCTION: s:UI.getShowHelp() {{{1
line 267: function! s:UI.getShowHelp()
line 270: 
line 271: " FUNCTION: s:UI.getShowHidden() {{{1
line 272: function! s:UI.getShowHidden()
line 275: 
line 276: " FUNCTION: s:UI._indentLevelFor(line) {{{1
line 277: function! s:UI._indentLevelFor(line)
line 285: 
line 286: " FUNCTION: s:UI.IndentWid() {{{1
line 287: function! s:UI.IndentWid()
line 290: 
line 291: " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
line 292: function! s:UI.isIgnoreFilterEnabled()
line 295: 
line 296: " FUNCTION: s:UI.isMinimal() {{{1
line 297: function! s:UI.isMinimal()
line 300: 
line 301: " FUNCTION: s:UI.MarkupReg() {{{1
line 302: function! s:UI.MarkupReg()
line 305: 
line 306: " FUNCTION: s:UI._renderBookmarks {{{1
line 307: function! s:UI._renderBookmarks()
line 326: 
line 327: " FUNCTION: s:UI.restoreScreenState() {{{1
line 328: "
line 329: " Sets the screen state back to what it was when nerdtree#saveScreenState was last
line 330: " called.
line 331: "
line 332: " Assumes the cursor is in the NERDTree window
line 333: function! s:UI.restoreScreenState()
line 346: 
line 347: " FUNCTION: s:UI.saveScreenState() {{{1
line 348: " Saves the current cursor position in the current buffer and the window
line 349: " scroll position
line 350: function! s:UI.saveScreenState()
line 359: 
line 360: " FUNCTION: s:UI.setShowHidden(val) {{{1
line 361: function! s:UI.setShowHidden(val)
line 364: 
line 365: " FUNCTION: s:UI._stripMarkup(line){{{1
line 366: " find the filename in the given line, and return it.
line 367: "
line 368: " Args:
line 369: " line: the subject line
line 370: function! s:UI._stripMarkup(line)
line 374: 
line 375: " FUNCTION: s:UI.render() {{{1
line 376: function! s:UI.render()
line 427: 
line 428: 
line 429: " FUNCTION: UI.renderViewSavingPosition {{{1
line 430: " Renders the tree and ensures the cursor stays on the current node or the
line 431: " current nodes parent if it is no longer available upon re-rendering
line 432: function! s:UI.renderViewSavingPosition()
line 447: 
line 448: " FUNCTION: s:UI.toggleHelp() {{{1
line 449: function! s:UI.toggleHelp()
line 452: 
line 453: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
line 454: " toggles the use of the NERDTreeIgnore option
line 455: function! s:UI.toggleIgnoreFilter()
line 460: 
line 461: " FUNCTION: s:UI.toggleShowBookmarks() {{{1
line 462: " Toggle the visibility of the Bookmark table.
line 463: function! s:UI.toggleShowBookmarks()
line 481: 
line 482: " FUNCTION: s:UI.toggleShowFiles() {{{1
line 483: " toggles the display of hidden files
line 484: function! s:UI.toggleShowFiles()
line 489: 
line 490: " FUNCTION: s:UI.toggleShowHidden() {{{1
line 491: " toggles the display of hidden files
line 492: function! s:UI.toggleShowHidden()
line 497: 
line 498: " FUNCTION: s:UI.toggleZoom() {{{1
line 499: " zoom (maximize/minimize) the NERDTree window
line 500: function! s:UI.toggleZoom()
line 510: 
line 511: " FUNCTION: s:UI.UpDirLine() {{{1
line 512: function! s:UI.UpDirLine()
line 515: 
line 516: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim
continuing in function nerdtree#loadClassFiles
line 13:     runtime lib/nerdtree/event.vim
Searching for "lib/nerdtree/event.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 13: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
line 1: "CLASS: Event
line 2: "============================================================
line 3: let s:Event = {}
line 4: let g:NERDTreeEvent = s:Event
line 5: 
line 6: function! s:Event.New(nerdtree, subject, action, params) abort
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim
continuing in function nerdtree#loadClassFiles
line 14:     runtime lib/nerdtree/notifier.vim
Searching for "lib/nerdtree/notifier.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 14: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
line 1: "CLASS: Notifier
line 2: "============================================================
line 3: let s:Notifier = {}
line 4: 
line 5: function! s:Notifier.AddListener(event, funcname)
line 13: 
line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
line 21: 
line 22: function! s:Notifier.GetListenersMap()
line 28: 
line 29: function! s:Notifier.GetListenersForEvent(name)
line 33: 
line 34: let g:NERDTreePathNotifier = deepcopy(s:Notifier)
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim
continuing in function nerdtree#loadClassFiles
function nerdtree#loadClassFiles returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 156: 
line 157: " SECTION: Commands {{{1
line 158: "============================================================
line 159: call nerdtree#ui_glue#setupCommands()
Searching for "autoload/nerdtree/ui_glue.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree)
fchdir() to previous dir
line 159: sourcing "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
line 1: if exists("g:loaded_nerdtree_ui_glue_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_ui_glue_autoload = 1
line 5: 
line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
line 7: function! nerdtree#ui_glue#createDefaultBindings()
line 73: 
line 74: 
line 75: "SECTION: Interface bindings {{{1
line 76: "============================================================
line 77: 
line 78: "FUNCTION: s:activateAll() {{{1
line 79: "handle the user activating the updir line
line 80: function! s:activateAll()
line 85: 
line 86: " FUNCTION: s:activateDirNode(directoryNode) {{{1
line 87: function! s:activateDirNode(directoryNode)
line 96: 
line 97: "FUNCTION: s:activateFileNode() {{{1
line 98: "handle the user activating a tree node
line 99: function! s:activateFileNode(node)
line 102: 
line 103: "FUNCTION: s:activateBookmark() {{{1
line 104: "handle the user activating a bookmark
line 105: function! s:activateBookmark(bm)
line 108: 
line 109: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
line 110: " Associate the current node with the given name
line 111: function! nerdtree#ui_glue#bookmarkNode(...)
line 128: 
line 129: " FUNCTION: s:chCwd(node) {{{1
line 130: function! s:chCwd(node)
line 137: 
line 138: " FUNCTION: s:chRoot(node) {{{1
line 139: " changes the current root to the selected one
line 140: function! s:chRoot(node)
line 143: 
line 144: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
line 145: " Change the NERDTree root to match the current working directory.
line 146: function! nerdtree#ui_glue#chRootCwd()
line 149: 
line 150: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
line 151: function! nerdtree#ui_glue#clearBookmarks(bookmarks)
line 166: 
line 167: " FUNCTION: s:closeChildren(node) {{{1
line 168: " closes all childnodes of the current node
line 169: function! s:closeChildren(node)
line 174: 
line 175: " FUNCTION: s:closeCurrentDir(node) {{{1
line 176: " Close the parent directory of the current node.
line 177: function! s:closeCurrentDir(node)
line 199: 
line 200: " FUNCTION: s:closeTreeWindow() {{{1
line 201: " close the tree window
line 202: function! s:closeTreeWindow()
line 213: 
line 214: " FUNCTION: s:deleteBookmark(bookmark) {{{1
line 215: " Prompt the user to confirm the deletion of the selected bookmark.
line 216: function! s:deleteBookmark(bookmark)
line 239: 
line 240: " FUNCTION: s:displayHelp() {{{1
line 241: " toggles the help display
line 242: function! s:displayHelp()
line 247: 
line 248: " FUNCTION: s:findAndRevealPath(pathStr) {{{1
line 249: function! s:findAndRevealPath(pathStr)
line 294: 
line 295: "FUNCTION: s:handleLeftClick() {{{1
line 296: "Checks if the click should open the current node
line 297: function! s:handleLeftClick()
line 330: 
line 331: " FUNCTION: s:handleMiddleMouse() {{{1
line 332: function! s:handleMiddleMouse()
line 351: 
line 352: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
line 353: "this is needed since I cant figure out how to invoke dict functions from a
line 354: "key map
line 355: function! nerdtree#ui_glue#invokeKeyMap(key)
line 358: 
line 359: " FUNCTION: s:jumpToFirstChild(node) {{{1
line 360: function! s:jumpToFirstChild(node)
line 363: 
line 364: " FUNCTION: s:jumpToLastChild(node) {{{1
line 365: function! s:jumpToLastChild(node)
line 368: 
line 369: " FUNCTION: s:jumpToChild(node, last) {{{2
line 370: " Jump to the first or last child node at the same file system level.
line 371: "
line 372: " Args:
line 373: " node: the node on which the cursor currently sits
line 374: " last: 1 (true) if jumping to last child, 0 (false) if jumping to first
line 375: function! s:jumpToChild(node, last)
line 390: 
line 391: " FUNCTION: s:jumpToParent(node) {{{1
line 392: " Move the cursor to the parent of the specified node.  For a cascade, move to
line 393: " the parent of the cascade's first node.  At the root node, do nothing.
line 394: function! s:jumpToParent(node)
line 409: 
line 410: " FUNCTION: s:jumpToRoot() {{{1
line 411: " moves the cursor to the root node
line 412: function! s:jumpToRoot()
line 416: 
line 417: " FUNCTION: s:jumpToNextSibling(node) {{{1
line 418: function! s:jumpToNextSibling(node)
line 421: 
line 422: " FUNCTION: s:jumpToPrevSibling(node) {{{1
line 423: function! s:jumpToPrevSibling(node)
line 426: 
line 427: " FUNCTION: s:jumpToSibling(node, forward) {{{2
line 428: " Move the cursor to the next or previous node at the same file system level.
line 429: "
line 430: " Args:
line 431: " node: the node on which the cursor currently sits
line 432: " forward: 0 to jump to previous sibling, 1 to jump to next sibling
line 433: function! s:jumpToSibling(node, forward)
line 444: 
line 445: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
line 446: " Open the Bookmark that has the specified name. This function provides the
line 447: " implementation for the ":OpenBookmark" command.
line 448: function! nerdtree#ui_glue#openBookmark(name)
line 461: 
line 462: " FUNCTION: s:openHSplit(target) {{{1
line 463: function! s:openHSplit(target)
line 466: 
line 467: " FUNCTION: s:openVSplit(target) {{{1
line 468: function! s:openVSplit(target)
line 471: 
line 472: " FUNCTION: s:openExplorer(node) {{{1
line 473: function! s:openExplorer(node)
line 476: 
line 477: " FUNCTION: s:openInNewTab(target) {{{1
line 478: function! s:openInNewTab(target)
line 482: 
line 483: " FUNCTION: s:openInNewTabSilent(target) {{{1
line 484: function! s:openInNewTabSilent(target)
line 488: 
line 489: " FUNCTION: s:openNodeRecursively(node) {{{1
line 490: function! s:openNodeRecursively(node)
line 497: 
line 498: "FUNCTION: s:previewNodeCurrent(node) {{{1
line 499: function! s:previewNodeCurrent(node)
line 502: 
line 503: "FUNCTION: s:previewNodeHSplit(node) {{{1
line 504: function! s:previewNodeHSplit(node)
line 507: 
line 508: "FUNCTION: s:previewNodeVSplit(node) {{{1
line 509: function! s:previewNodeVSplit(node)
line 512: 
line 513: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
line 514: " put the cursor on the node associate with the given name
line 515: function! nerdtree#ui_glue#revealBookmark(name)
line 523: 
line 524: " FUNCTION: s:refreshRoot() {{{1
line 525: " Reloads the current root. All nodes below this will be lost and the root dir
line 526: " will be reloaded.
line 527: function! s:refreshRoot()
line 541: 
line 542: " FUNCTION: s:refreshCurrent(node) {{{1
line 543: " refreshes the root for the current node
line 544: function! s:refreshCurrent(node)
line 556: 
line 557: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
line 558: function! nerdtree#ui_glue#setupCommands()
line 569: 
line 570: " Function: s:SID()   {{{1
line 571: function s:SID()
line 577: 
line 578: " FUNCTION: s:showMenu(node) {{{1
line 579: function! s:showMenu(node)
line 583: 
line 584: " FUNCTION: s:toggleIgnoreFilter() {{{1
line 585: function! s:toggleIgnoreFilter()
line 588: 
line 589: " FUNCTION: s:toggleShowBookmarks() {{{1
line 590: function! s:toggleShowBookmarks()
line 593: 
line 594: " FUNCTION: s:toggleShowFiles() {{{1
line 595: function! s:toggleShowFiles()
line 598: 
line 599: " FUNCTION: s:toggleShowHidden() {{{1
line 600: " toggles the display of hidden files
line 601: function! s:toggleShowHidden()
line 604: 
line 605: " FUNCTION: s:toggleZoom() {{{1
line 606: function! s:toggleZoom()
line 609: 
line 610: " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
line 611: " Move the NERDTree up one level.
line 612: "
line 613: " Args:
line 614: " preserveState: if 1, the current root is left open when the new tree is
line 615: " rendered; if 0, the current root node is closed
line 616: function! nerdtree#ui_glue#upDir(preserveState)
line 638: 
line 639: " FUNCTION: s:upDirCurrentRootOpen() {{{1
line 640: function! s:upDirCurrentRootOpen()
line 643: 
line 644: " FUNCTION: s:upDirCurrentRootClosed() {{{1
line 645: function! s:upDirCurrentRootClosed()
line 648: 
line 649: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim
continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#ui_glue#setupCommands()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
line 6:     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
line 7:     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
line 8:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
line 9:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
function nerdtree#ui_glue#setupCommands returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 160: 
line 161: " SECTION: Auto commands {{{1
line 162: "============================================================
line 163: augroup NERDTree
line 164:     "Save the cursor position whenever we close the nerd tree
line 165:     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"
calling function 185()

line 1:     return 'NERD_tree_'
function 185 returning 'NERD_tree_'

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 165: autocmd BufLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
line 166: 
line 167:     "disallow insert mode in the NERDTree
line 168:     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
calling function 185()

line 1:     return 'NERD_tree_'
function 185 returning 'NERD_tree_'

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 168: autocmd BufEnter NERD_tree_* stopinsert
line 169: augroup END
line 170: 
line 171: if g:NERDTreeHijackNetrw
line 172:     augroup NERDTreeHijackNetrw
line 173:         autocmd VimEnter * silent! autocmd! FileExplorer
line 174:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
line 175:     augroup END
line 176: endif
line 177: 
line 178: " SECTION: Public API {{{1
line 179: "============================================================
line 180: function! NERDTreeAddMenuItem(options)
line 183: 
line 184: function! NERDTreeAddMenuSeparator(...)
line 188: 
line 189: function! NERDTreeAddSubmenu(options)
line 192: 
line 193: function! NERDTreeAddKeyMap(options)
line 196: 
line 197: function! NERDTreeRender()
line 200: 
line 201: function! NERDTreeFocus()
line 208: 
line 209: function! NERDTreeCWD()
line 233: 
line 234: function! NERDTreeAddPathFilter(callback)
line 237: 
line 238: " SECTION: Post Source Actions {{{1
line 239: call nerdtree#postSourceActions()
calling function nerdtree#postSourceActions()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)
calling function nerdtree#postSourceActions[1]..86(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i != ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13:                 let path = fnamemodify(path, ':p')
line 14: 
line 15:                 try
line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
line 17:                     call add(g:NERDTreeBookmarks, bookmark)
line 18:                 catch /^NERDTree.InvalidArgumentsError/
line 19:                     call add(g:NERDTreeInvalidBookmarks, i)
line 20:                     let invalidBookmarksFound += 1
line 21:                 endtry
line 22:             endif
line 23:         endfor
line 24:         if invalidBookmarksFound
line 25:             call s:Bookmark.Write()
line 26:             if !a:silent
line 27:                 call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
line 28:             endif
line 29:         endif
line 30:     endif
function nerdtree#postSourceActions[1]..86 returning #0

continuing in function nerdtree#postSourceActions

line 2:     call nerdtree#ui_glue#createDefaultBindings()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings()

line 1:     let s = '<SNR>' . s:SID() . '_'
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>37_SID()

line 1:     if !exists("s:sid")
line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
line 3:     endif
line 4:     return s:sid
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>37_SID returning '37'

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 2: 
line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>37_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>37_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[4]..72('<MiddleMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>37_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>37_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[4]..72('<LeftRelease>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>37_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>37_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>37_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>37_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>37_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>37_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...7_activateAll', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 9: 
line 10: 
line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>37_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>37_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_activateDirNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>37_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>37_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_activateFileNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>37_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>37_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_activateBookmark', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 14:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_activateAll', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 15: 
line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap({'key': 'i', 'scope': 'Node', 'callback': '<SNR>37_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78({'key': 'i', 'scope': 'Node', 'callback': '<SNR>37_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[4]..72('i', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_openHSplit', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap({'key': 's', 'scope': 'Node', 'callback': '<SNR>37_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78({'key': 's', 'scope': 'Node', 'callback': '<SNR>37_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[4]..72('s', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_openVSplit', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 18: 
line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Node', 'callback': '<SNR>37_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78({'key': 'go', 'scope': 'Node', 'callback': '<SNR>37_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[4]..72('go', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_previewNodeCurrent', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 20:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>37_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>37_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[4]..72('gs', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_previewNodeVSplit', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 21:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>37_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>37_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[4]..72('gi', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_previewNodeHSplit', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 22: 
line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>37_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>37_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[4]..72('O', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_openNodeRecursively', 'key': 'O'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 24: 
line 25:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap({'key': 'u', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78({'key': 'u', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[4]..72('u', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...37_upDirCurrentRootClosed', 'key': 'u'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap({'key': 'U', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78({'key': 'U', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[4]..72('U', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...R>37_upDirCurrentRootOpen', 'key': 'U'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap({'key': 'C', 'scope': 'Node', 'callback': '<SNR>37_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78({'key': 'C', 'scope': 'Node', 'callback': '<SNR>37_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[4]..72('C', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...allback': '<SNR>37_chRoot', 'key': 'C'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 28: 
line 29:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>37_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>37_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[4]..72('cd', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...allback': '<SNR>37_chCwd', 'key': 'cd'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 30: 
line 31:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap({'key': 'q', 'scope': 'all', 'callback': '<SNR>37_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78({'key': 'q', 'scope': 'all', 'callback': '<SNR>37_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[4]..72('q', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_closeTreeWindow', 'key': 'q'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 32: 
line 33:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[4]..72('CD', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 34: 
line 35:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap({'key': 'R', 'scope': 'all', 'callback': '<SNR>37_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78({'key': 'R', 'scope': 'all', 'callback': '<SNR>37_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[4]..72('R', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_refreshRoot', 'key': 'R'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap({'key': 'r', 'scope': 'Node', 'callback': '<SNR>37_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78({'key': 'r', 'scope': 'Node', 'callback': '<SNR>37_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[4]..72('r', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...: '<SNR>37_refreshCurrent', 'key': 'r'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 37: 
line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap({'key': '?', 'scope': 'all', 'callback': '<SNR>37_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78({'key': '?', 'scope': 'all', 'callback': '<SNR>37_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[4]..72('?', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_displayHelp', 'key': '?'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 39:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap({'key': 'A', 'scope': 'all', 'callback': '<SNR>37_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78({'key': 'A', 'scope': 'all', 'callback': '<SNR>37_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[4]..72('A', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_toggleZoom', 'key': 'A'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap({'key': 'I', 'scope': 'all', 'callback': '<SNR>37_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78({'key': 'I', 'scope': 'all', 'callback': '<SNR>37_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[4]..72('I', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_toggleShowHidden', 'key': 'I'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 41:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap({'key': 'f', 'scope': 'all', 'callback': '<SNR>37_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78({'key': 'f', 'scope': 'all', 'callback': '<SNR>37_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[4]..72('f', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_toggleIgnoreFilter', 'key': 'f'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap({'key': 'F', 'scope': 'all', 'callback': '<SNR>37_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78({'key': 'F', 'scope': 'all', 'callback': '<SNR>37_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[4]..72('F', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_toggleShowFiles', 'key': 'F'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap({'key': 'B', 'scope': 'all', 'callback': '<SNR>37_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78({'key': 'B', 'scope': 'all', 'callback': '<SNR>37_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[4]..72('B', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_toggleShowBookmarks', 'key': 'B'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 44: 
line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap({'key': 'x', 'scope': 'Node', 'callback': '<SNR>37_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78({'key': 'x', 'scope': 'Node', 'callback': '<SNR>37_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[4]..72('x', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_closeCurrentDir', 'key': 'x'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>37_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>37_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[4]..72('X', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...': '<SNR>37_closeChildren', 'key': 'X'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 47: 
line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap({'key': 'm', 'scope': 'Node', 'callback': '<SNR>37_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78({'key': 'm', 'scope': 'Node', 'callback': '<SNR>37_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[4]..72('m', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...lback': '<SNR>37_showMenu', 'key': 'm'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 49: 
line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap({'key': 'p', 'scope': 'Node', 'callback': '<SNR>37_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78({'key': 'p', 'scope': 'Node', 'callback': '<SNR>37_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[4]..72('p', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_jumpToParent', 'key': 'p'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap({'key': 'K', 'scope': 'Node', 'callback': '<SNR>37_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78({'key': 'K', 'scope': 'Node', 'callback': '<SNR>37_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[4]..72('K', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_jumpToFirstChild', 'key': 'K'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap({'key': 'J', 'scope': 'Node', 'callback': '<SNR>37_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78({'key': 'J', 'scope': 'Node', 'callback': '<SNR>37_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[4]..72('J', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_jumpToLastChild', 'key': 'J'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap({'key': 'P', 'scope': 'all', 'callback': '<SNR>37_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78({'key': 'P', 'scope': 'all', 'callback': '<SNR>37_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[4]..72('P', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_jumpToRoot', 'key': 'P'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 54:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>37_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>37_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[4]..72('<C-j>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...>37_jumpToNextSibling', 'key': '<C-j>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>37_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>37_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[4]..72('<C-k>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...>37_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 56: 
line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Node', 'callback': '<SNR>37_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78({'key': 't', 'scope': 'Node', 'callback': '<SNR>37_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[4]..72('t', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Node', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78({'key': 'T', 'scope': 'Node', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[4]..72('T', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[4]..72('t', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[4]..72('T', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 61: 
line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>37_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>37_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[4]..72('e', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 63: 
line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>37_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>37_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[4]..72('D', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...: '<SNR>37_deleteBookmark', 'key': 'D'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings returning #0

continuing in function nerdtree#postSourceActions

line 3: 
line 4:     "load all nerdtree plugins
line 5:     runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/ale/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim"
line 1: " ============================================================================
line 2: " File:        exec_menuitem.vim
line 3: " Description: plugin for NERD Tree that provides an execute file menu item
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_exec_menuitem")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_exec_menuitem = 1
line 16: 
line 21: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning []

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeExecFile', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim

line 22: 
line 23: function! NERDTreeExecFileActive()
line 27: 
line 28: function! NERDTreeExecFile()
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim
continuing in function nerdtree#postSourceActions
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim"
line 1: " ============================================================================
line 2: " File:        fs_menu.vim
line 3: " Description: plugin for the NERD Tree that provides a file system menu
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_fs_menu")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_fs_menu = 1
line 16: 
line 17: "Automatically delete the buffer after deleting or renaming a file
line 18: if !exists("g:NERDTreeAutoDeleteBuffer")
line 19:     let g:NERDTreeAutoDeleteBuffer = 0
line 20: endif
line 21: 
line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeExecFile', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...TreeAddNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...reeAddNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeMoveNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeMoveNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...eDeleteNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 25: 
line 26: if has("gui_mac") || has("gui_macvim") || has("mac")
line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
line 30: endif
line 31: 
line 32: if executable("xdg-open")
line 33:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...DeleteNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...alFileLinux', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 34:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...lFileLinux', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...teFileLinux', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 35: endif
line 36: 
line 37: if g:NERDTreePath.CopyingSupported()
calling function 9()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
function 9 returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 38:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eFileLinux', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeCopyNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 39: endif
line 40: 
line 41: if has("unix") || has("osx")
line 42:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeCopyNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeListNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 43: else
line 44:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
line 45: endif
line 46: 
line 47: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
line 48: "prints out the given msg and, if the user responds by pushing 'y' then the
line 49: "buffer with the given bufnum is deleted
line 50: "
line 51: "Args:
line 52: "bufnum: the buffer that may be deleted
line 53: "msg: a message that will be echoed to the user asking them if they wish to
line 54: "     del the buffer
line 55: function! s:promptToDelBuffer(bufnum, msg)
line 85: 
line 86: "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
line 87: "The buffer with the given bufNum is replaced with a new one
line 88: "
line 89: "Args:
line 90: "bufNum: the buffer that may be deleted
line 91: "newNodeName: the name given to the renamed node
line 92: "isDirectory: determines how to do the create the new filenames
line 93: function! s:renameBuffer(bufNum, newNodeName, isDirectory)
line 113: "FUNCTION: NERDTreeAddNode(){{{1
line 114: function! NERDTreeAddNode()
line 147: 
line 148: "FUNCTION: NERDTreeMoveNode(){{{1
line 149: function! NERDTreeMoveNode()
line 198: 
line 199: " FUNCTION: NERDTreeDeleteNode() {{{1
line 200: function! NERDTreeDeleteNode()
line 243: 
line 244: " FUNCTION: NERDTreeListNode() {{{1
line 245: function! NERDTreeListNode()
line 265: 
line 266: " FUNCTION: NERDTreeListNodeWin32() {{{1
line 267: function! NERDTreeListNodeWin32()
line 283: 
line 284: " FUNCTION: NERDTreeCopyNode() {{{1
line 285: function! NERDTreeCopyNode()
line 325: 
line 326: " FUNCTION: NERDTreeQuickLook() {{{1
line 327: function! NERDTreeQuickLook()
line 333: 
line 334: " FUNCTION: NERDTreeRevealInFinder() {{{1
line 335: function! NERDTreeRevealInFinder()
line 341: 
line 342: " FUNCTION: NERDTreeExecuteFile() {{{1
line 343: function! NERDTreeExecuteFile()
line 349: 
line 350: " FUNCTION: NERDTreeRevealFileLinux() {{{1
line 351: function! NERDTreeRevealFileLinux()
line 358: 
line 359: " FUNCTION: NERDTreeExecuteFileLinux() {{{1
line 360: function! NERDTreeExecuteFileLinux()
line 366: 
line 367: " vim: set sw=4 sts=4 et fdm=marker:
line 368: 
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim
continuing in function nerdtree#postSourceActions
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim"
line 1: " ============================================================================
line 2: " File:        vcs.vim
line 3: " Description: NERDTree plugin that provides a command to open on the root of
line 4: "              a version control system repository.
line 5: " Maintainer:  Phil Runninger
line 6: " License:     This program is free software. It comes without any warranty,
line 7: "              to the extent permitted by applicable law. You can redistribute
line 8: "              it and/or modify it under the terms of the Do What The Fuck You
line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 11: "
line 12: " ============================================================================
line 13: command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
line 14: 
line 15: " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
line 16: function! s:CreateTabTreeVCS(name)
line 21: 
line 22: " FUNCTION: s:FindParentVCSRoot(a:path) {{{1
line 23: " Finds the root version control system folder of the given path. If a:path is
line 24: " not part of a repository, return the original path.
line 25: function! s:FindParentVCSRoot(path)
line 38: 
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/ringu/.vim/plugged/emmet-vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim"
line 1: " Version: 0.10.0
line 2: " Webpage: https://github.com/ryanoasis/vim-devicons
line 3: " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
line 4: " License: see LICENSE
line 5: 
line 6: " @todo fix duplicate global variable initialize here:
line 7: if !exists('g:webdevicons_enable')
line 8:   let g:webdevicons_enable = 1
line 9: endif
line 10: 
line 11: if !exists('g:webdevicons_enable_nerdtree')
line 12:   let g:webdevicons_enable_nerdtree = 1
line 13: endif
line 14: 
line 15: if !exists('g:DevIconsEnableFoldersOpenClose')
line 16:   let g:DevIconsEnableFoldersOpenClose = 0
line 17: endif
line 18: 
line 19: if !exists('g:DevIconsEnableFolderPatternMatching')
line 20:   let g:DevIconsEnableFolderPatternMatching = 1
line 21: endif
line 22: 
line 23: if !exists('g:DevIconsEnableFolderExtensionPatternMatching')
line 24:   let g:DevIconsEnableFolderExtensionPatternMatching = 0
line 25: endif
line 26: 
line 27: " end @todo duplicate global variables
line 28: 
line 29: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 30: " actual font patcher)
line 31: if !exists('g:webdevicons_gui_glyph_fix')
line 32:   if has('gui_running')
line 33:     let g:webdevicons_gui_glyph_fix = 1
line 34:   else
line 35:     let g:webdevicons_gui_glyph_fix = 0
line 36:   endif
line 37: endif
line 38: 
line 39: if !exists('g:DevIconsEnableNERDTreeRedraw')
line 40:   if has('gui_running')
line 41:     let g:DevIconsEnableNERDTreeRedraw = 1
line 42:   else
line 43:     let g:DevIconsEnableNERDTreeRedraw = 0
line 44:   endif
line 45: endif
line 46: 
line 47: if g:webdevicons_enable_nerdtree == 1
line 48:   if !exists('g:loaded_nerd_tree')
line 50:      echohl WarningMsg | echomsg 'vim-webdevicons requires NERDTree to be loaded before vim-webdevicons.'
line 50:  echomsg 'vim-webdevicons requires NERDTree to be loaded before vim-webdevicons.'
line 51:   endif
line 52: 
line 53:   if exists('g:loaded_nerd_tree') && g:loaded_nerd_tree == 1 && !exists('g:NERDTreePathNotifier')
line 54:      let g:webdevicons_enable_nerdtree = 0
line 56:      echohl WarningMsg | echomsg 'vim-webdevicons requires a newer version of NERDTree to show glyphs in NERDTree - consider updating NERDTree.'
line 56:  echomsg 'vim-webdevicons requires a newer version of NERDTree to show glyphs in NERDTree - consider updating NERDTree.'
line 57:   endif
line 58: 
line 59:   " @todo I don't even want this to execute UNLESS the user has the
line 60:   " 'nerdtree-git-plugin' INSTALLED (not LOADED)
line 61:   " As it currently functions this warning will display even if the user does
line 62:   " not have nerdtree-git-plugin not just if it isn't loaded yet 
line 63:   " (not what we want)
line 64:   "if !exists('g:loaded_nerdtree_git_status')
line 65:   "   echohl WarningMsg |
line 66:   "     \ echomsg 'vim-webdevicons works better when 'nerdtree-git-plugin' is loaded before vim-webdevicons (small refresh issues otherwise).'
line 67:   "endif
line 68: endif
line 69: 
line 70: if !exists('g:webdevicons_enable_airline_tabline')
line 71:   let g:webdevicons_enable_airline_tabline = 1
line 72: endif
line 73: 
line 74: if !exists('g:webdevicons_enable_airline_statusline')
line 75:   let g:webdevicons_enable_airline_statusline = 1
line 76: endif
line 77: 
line 78: function! s:SetupListeners()
line 83: 
line 84: " util like helpers
line 85: " scope: local
line 86: function! s:Refresh()
line 90: 
line 91: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 92: " actual font patcher)
line 93: 
line 94: " NERDTree-C
line 95: " scope: global
line 96: function! WebDevIconsNERDTreeChangeRootHandler(node)
line 104: 
line 105: " NERDTree-u
line 106: " scope: global
line 107: function! WebDevIconsNERDTreeUpDirCurrentRootClosedHandler()
line 113: 
line 114: function! WebDevIconsNERDTreeDirUpdateFlags(node, glyph)
line 151: 
line 152: function! WebDevIconsNERDTreeDirClose(node)
line 157: 
line 158: function! WebDevIconsNERDTreeDirOpen(node)
line 163: 
line 164: function! WebDevIconsNERDTreeDirOpenRecursively(node)
line 172: 
line 173: function! WebDevIconsNERDTreeDirCloseRecursively(node)
line 181: 
line 182: function! WebDevIconsNERDTreeDirCloseChildren(node)
line 189: 
line 190: " NERDTreeMapActivateNode and <2-LeftMouse>
line 191: " handle the user activating a tree node
line 192: " scope: global
line 193: function! WebDevIconsNERDTreeMapActivateNode(node)
line 209: 
line 210: function! WebDevIconsNERDTreeMapOpenRecursively(node)
line 223: 
line 224: function! WebDevIconsNERDTreeMapCloseChildren(node)
line 236: 
line 237: function! WebDevIconsNERDTreeMapCloseDir(node)
line 262: 
line 263: function! WebDevIconsNERDTreeMapUpdirKeepOpen()
line 273: 
line 274: if g:webdevicons_enable == 1 && g:webdevicons_enable_nerdtree == 1
line 275:   call s:SetupListeners()
calling function <SNR>41_SetupListeners()

line 1:   call g:NERDTreePathNotifier.AddListener('init', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[1]..263('init', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[1]..263[1]..266('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[1]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[1]..263[1]..266[1]..265 returning {}

continuing in function <SNR>41_SetupListeners[1]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[1]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[1]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[1]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[1]..263[3]..265 returning {}

continuing in function <SNR>41_SetupListeners[1]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[1]..263 returning #0

continuing in function <SNR>41_SetupListeners

line 2:   call g:NERDTreePathNotifier.AddListener('refresh', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[2]..263('refresh', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[2]..263[1]..266('refresh')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[2]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[2]..263[1]..266[1]..265 returning {'init': ['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[2]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[2]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[2]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[2]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[2]..263[3]..265 returning {'init': ['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[2]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[2]..263 returning #0

continuing in function <SNR>41_SetupListeners

line 3:   call g:NERDTreePathNotifier.AddListener('refreshFlags', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[3]..263('refreshFlags', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[3]..263[1]..266('refreshFlags')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[3]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[3]..263[1]..266[1]..265 returning {'init': ['NERDTreeWebDevIconsRefreshL...['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[3]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[3]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[3]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[3]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[3]..263[3]..265 returning {'init': ['NERDTreeWebDevIconsRefreshL...['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[3]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[3]..263 returning #0

continuing in function <SNR>41_SetupListeners

function <SNR>41_SetupListeners returning #0

continuing in /home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim

line 276: 
line 277:   if g:DevIconsEnableFoldersOpenClose
line 278: 
line 279:     " These overrides are needed because we cannot
line 280:     " simply use AddListener for reliably updating
line 281:     " the folder open/close glyphs because the event
line 282:     " path has no access to the 'isOpen' property
line 283:     " some of these are a little more brittle/fragile
line 284:     " than others
line 285:     " TODO FIXME better way to reliably update
line 286:     " open/close glyphs in NERDTreeWebDevIconsRefreshListener
line 287: 
line 288:     " NERDTreeMapActivateNode
line 293:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'callback': 'WebDevIconsNERDTreeMapActivateNode', 'override': 1, 'scope': 'DirNode' })
line 294: 
line 295:     " NERDTreeMapOpenRecursively
line 300:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'callback': 'WebDevIconsNERDTreeMapOpenRecursively', 'override': 1, 'scope': 'DirNode' })
line 301: 
line 302:     " NERDTreeMapCloseChildren
line 307:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'callback': 'WebDevIconsNERDTreeMapCloseChildren', 'override': 1, 'scope': 'DirNode' })
line 308: 
line 309:     " NERDTreeMapCloseChildren
line 314:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'callback': 'WebDevIconsNERDTreeMapCloseDir', 'override': 1, 'scope': 'Node' })
line 315: 
line 316:     " <2-LeftMouse>
line 321:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'callback': 'WebDevIconsNERDTreeMapActivateNode', 'override': 1, 'scope': 'DirNode' })
line 322: 
line 323:     " NERDTreeMapUpdirKeepOpen
line 328:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'callback': 'WebDevIconsNERDTreeMapUpdirKeepOpen', 'override': 1, 'scope': 'all' })
line 329: 
line 330:   endif
line 331: 
line 332:   " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 333:   " actual font patcher)
line 334:   if g:webdevicons_gui_glyph_fix ==# 1
line 340:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'callback': 'WebDevIconsNERDTreeChangeRootHandler', 'override': 1, 'quickhelpText': "change tree root to the\n\"    selected dir\n\"    plus devicons redraw\n\"    hack fix", 'scope': 'Node' })
line 341: 
line 347:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'callback': 'WebDevIconsNERDTreeUpDirCurrentRootClosedHandler', 'override': 1, 'quickhelpText': "move tree root up a dir\n\"    plus devicons redraw\n\"    hack fix", 'scope': 'all' })
line 348:   endif
line 349: 
line 350: endif
line 351: 
line 352: " modeline syntax:
line 353: " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:
finished sourcing /home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/ringu/.vim/plugged/fzf.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vim81/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/after/nerdtree_plugin/**/*.vim"
function nerdtree#postSourceActions returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 240: 
line 241: "reset &cpo back to users setting
line 242: let &cpo = s:old_cpo
line 243: 
line 244: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
Searching for "/home/ringu/.vim/plugged/emmet-vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/emmet-vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim"
line 1: "=============================================================================
line 2: " File: emmet.vim
line 3: " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
line 4: " Last Change: 26-Jul-2015.
line 5: " Version: 0.86
line 6: " WebPage: http://github.com/mattn/emmet-vim
line 7: " Description: vim plugins for HTML and CSS hi-speed coding.
line 8: " SeeAlso: http://emmet.io/
line 9: " Usage:
line 10: "
line 11: "   This is vim script support expanding abbreviation like emmet.
line 12: "   ref: http://emmet.io/
line 13: "
line 14: "   Type abbreviation
line 15: "      +-------------------------------------
line 16: "      | html:5_
line 17: "      +-------------------------------------
line 18: "   "_" is a cursor position. and type "<c-y>," (Ctrl+y and Comma)
line 19: "   NOTE: Don't worry about key map. you can change it easily.
line 20: "      +-------------------------------------
line 21: "      | <!DOCTYPE HTML>
line 22: "      | <html lang="en">
line 23: "      | <head>
line 24: "      |     <title></title>
line 25: "      |     <meta charset="UTF-8">
line 26: "      | </head>
line 27: "      | <body>
line 28: "      |      _
line 29: "      | </body>
line 30: "      | </html>
line 31: "      +-------------------------------------
line 32: "   Type following
line 33: "      +-------------------------------------
line 34: "      | div#foo$*2>div.bar
line 35: "      +-------------------------------------
line 36: "   And type "<c-y>,"
line 37: "      +-------------------------------------
line 38: "      |<div id="foo1">
line 39: "      |    <div class="bar">_</div>
line 40: "      |</div>
line 41: "      |<div id="foo2">
line 42: "      |    <div class="bar"></div>
line 43: "      |</div>
line 44: "      +-------------------------------------
line 45: "
line 46: " Tips:
line 47: "
line 48: "   You can customize behavior of expanding with overriding config.
line 49: "   This configuration will be marged at loading plugin.
line 50: "
line 51: "     let g:user_emmet_settings = {
line 52: "     \  'indentation' : '  ',
line 53: "     \  'perl' : {
line 54: "     \    'aliases' : {
line 55: "     \      'req' : 'require '
line 56: "     \    },
line 57: "     \    'snippets' : {
line 58: "     \      'use' : "use strict\nuse warnings\n\n",
line 59: "     \      'warn' : "warn \"|\";",
line 60: "     \    }
line 61: "     \  }
line 62: "     \}
line 63: "
line 64: "   You can set language attribute in html using 'emmet_settings.lang'.
line 65: "
line 66: " GetLatestVimScripts: 2981 1 :AutoInstall: emmet.vim
line 67: " script type: plugin
line 68: 
line 69: if &compatible || v:version < 702 || (exists('g:loaded_emmet_vim') && g:loaded_emmet_vim)
line 70:   finish
line 71: endif
line 72: let g:loaded_emmet_vim = 1
line 73: 
line 74: let s:save_cpo = &cpoptions
line 75: set cpoptions&vim
line 76: 
line 77: if !exists('g:emmet_html5')
line 78:   let g:emmet_html5 = 1
line 79: endif
line 80: 
line 81: if !exists('g:emmet_docroot')
line 82:   let g:emmet_docroot = {}
line 83: endif
line 84: 
line 85: if !exists('g:emmet_debug')
line 86:   let g:emmet_debug = 0
line 87: endif
line 88: 
line 89: if !exists('g:emmet_curl_command')
line 90:   let g:emmet_curl_command = 'curl -s -L -A Mozilla/5.0'
line 91: endif
line 92: 
line 93: if !exists('g:user_emmet_leader_key')
line 94:   let g:user_emmet_leader_key = '<c-y>'
line 95: endif
line 96: 
line 97: function! s:install_plugin(mode, buffer)
line 163: 
line 164: command! -nargs=0 -bar EmmetInstall call <SID>install_plugin(get(g:, 'user_emmet_mode', 'a'), 1)
line 165: 
line 166: if get(g:, 'user_emmet_install_global', 1)
line 167:   call s:install_plugin(get(g:, 'user_emmet_mode', 'a'), 0)
calling function <SNR>42_install_plugin('a', 0)

line 1:   let buffer = a:buffer ? '<buffer>' : ''
line 2:   let items = [ {'mode': 'i', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(3,"")<cr>'}, {'mode': 'v', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(2,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': ':call emmet#expandAbbr(1,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>'}, {'mode': 'n', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '
line 39: 
line 40:   let only_plug = get(g:, 'emmet_install_only_plug', 0)
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-abbr) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(3,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(2,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-word) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-word) :call emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-update-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-update-tag) :call emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-inward) <esc>:call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-outword) <esc>:call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next) <esc>:call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next) :call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev) <esc>:call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev) :call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next-item) <esc>:call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next-item) :call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev-item) <esc>:call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev-item) :call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-image-size) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-image-size) :call emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-toggle-comment) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-toggle-comment) :call emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-split-join-tag) <esc>:call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-split-join-tag) :call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-remove-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-remove-tag) :call emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-url) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-url) :call emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-summary) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-summary) :call emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-merge-lines) :call emmet#mergeLines()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>m <plug>(emmet-merge-lines)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-code-pretty) :call emmet#codePretty()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>c <plug>(emmet-code-pretty)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 57: 
line 58:   if exists('g:user_emmet_complete_tag') && g:user_emmet_complete_tag
line 59:     if get(g:, 'user_emmet_install_global', 1)
line 60:       set omnifunc=emmet#completeTag
line 61:     else
line 62:       setlocal omnifunc=emmet#completeTag
line 63:     endif
line 64:   endif
function <SNR>42_install_plugin returning #0

continuing in /home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim

line 168: endif
line 169: 
line 170: if get(g:, 'user_emmet_install_command', 1)
line 171:   command! -nargs=1 Emmet call emmet#expandAbbr(4, <q-args>)
line 172: endif
line 173: 
line 174: let &cpoptions = s:save_cpo
line 175: unlet s:save_cpo
line 176: 
line 177: " vim:set et:
finished sourcing /home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim
Searching for "/home/ringu/.vim/plugged/vim-devicons/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-devicons/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim"
line 1: " Version: 0.10.0
line 2: " Webpage: https://github.com/ryanoasis/vim-devicons
line 3: " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
line 4: " License: see LICENSE
line 5: 
line 6: let s:version = '0.10.0'
line 7: let s:plugin_home = expand('<sfile>:p:h:h')
line 8: 
line 9: " set scriptencoding after 'encoding' and when using multibyte chars
line 10: scriptencoding utf-8
line 11: 
line 12: " standard fix/safety: line continuation (avoiding side effects) {{{1
line 13: "========================================================================
line 14: let s:save_cpo = &cpo
line 15: set cpo&vim
line 16: 
line 17: " standard loading / not loading {{{1
line 18: "========================================================================
line 19: 
line 20: if exists('g:loaded_webdevicons')
line 21:   finish
line 22: endif
line 23: 
line 24: let g:loaded_webdevicons = 1
line 25: 
line 26: " config enable / disable settings {{{1
line 27: "========================================================================
line 28: 
line 29: if !exists('g:webdevicons_enable')
line 30:   let g:webdevicons_enable = 1
line 31: endif
line 32: 
line 33: if !exists('g:webdevicons_enable_nerdtree')
line 34:   let g:webdevicons_enable_nerdtree = 1
line 35: endif
line 36: 
line 37: if !exists('g:webdevicons_enable_unite')
line 38:   let g:webdevicons_enable_unite = 1
line 39: endif
line 40: 
line 41: if !exists('g:webdevicons_enable_denite')
line 42:   let g:webdevicons_enable_denite = 1
line 43: endif
line 44: 
line 45: if !exists('g:webdevicons_enable_vimfiler')
line 46:   let g:webdevicons_enable_vimfiler = 1
line 47: endif
line 48: 
line 49: if !exists('g:webdevicons_enable_ctrlp')
line 50:   let g:webdevicons_enable_ctrlp = 1
line 51: endif
line 52: 
line 53: if !exists('g:webdevicons_enable_airline_tabline')
line 54:   let g:webdevicons_enable_airline_tabline = 1
line 55: endif
line 56: 
line 57: if !exists('g:webdevicons_enable_airline_statusline')
line 58:   let g:webdevicons_enable_airline_statusline = 1
line 59: endif
line 60: 
line 61: if !exists('g:webdevicons_enable_airline_statusline_fileformat_symbols')
line 62:   let g:webdevicons_enable_airline_statusline_fileformat_symbols = 1
line 63: endif
line 64: 
line 65: if !exists('g:webdevicons_enable_flagship_statusline')
line 66:   let g:webdevicons_enable_flagship_statusline = 1
line 67: endif
line 68: 
line 69: if !exists('g:webdevicons_enable_flagship_statusline_fileformat_symbols')
line 70:   let g:webdevicons_enable_flagship_statusline_fileformat_symbols = 1
line 71: endif
line 72: 
line 73: if !exists('g:webdevicons_conceal_nerdtree_brackets')
line 74:   let g:webdevicons_conceal_nerdtree_brackets = 1
line 75: endif
line 76: 
line 77: if !exists('g:DevIconsAppendArtifactFix')
line 78:   if has('gui_running')
line 79:     let g:DevIconsAppendArtifactFix = 1
line 80:   else
line 81:     let g:DevIconsAppendArtifactFix = 0
line 82:   endif
line 83: endif
line 84: 
line 85: if !exists('g:DevIconsArtifactFixChar')
line 86:   let g:DevIconsArtifactFixChar = " "
line 87: endif
line 88: 
line 89: " config options {{{1
line 90: "========================================================================
line 91: 
line 92: if !exists('g:WebDevIconsUnicodeDecorateFileNodes')
line 93:   let g:WebDevIconsUnicodeDecorateFileNodes = 1
line 94: endif
line 95: 
line 96: " whether to show default folder glyphs on directories:
line 97: if !exists('g:WebDevIconsUnicodeDecorateFolderNodes')
line 98:   let g:WebDevIconsUnicodeDecorateFolderNodes = 0
line 99: endif
line 100: 
line 101: if !exists('g:DevIconsEnableFoldersOpenClose')
line 102:   let g:DevIconsEnableFoldersOpenClose = 0
line 103: endif
line 104: 
line 105: if !exists('g:DevIconsEnableFolderPatternMatching')
line 106:   let g:DevIconsEnableFolderPatternMatching = 1
line 107: endif
line 108: 
line 109: if !exists('g:DevIconsEnableFolderExtensionPatternMatching')
line 110:   let g:DevIconsEnableFolderExtensionPatternMatching = 0
line 111: endif
line 112: 
line 113: " whether to try to match folder notes with any exact file node matches
line 114: " default is to match but requires WebDevIconsUnicodeDecorateFolderNodes set
line 115: " to 1:
line 116: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesExactMatches')
line 117:   let g:WebDevIconsUnicodeDecorateFolderNodesExactMatches = 1
line 118: endif
line 119: 
line 120: if !exists('g:WebDevIconsUnicodeGlyphDoubleWidth')
line 121:   let g:WebDevIconsUnicodeGlyphDoubleWidth = 1
line 122: endif
line 123: 
line 124: if !exists('g:WebDevIconsNerdTreeBeforeGlyphPadding')
line 125:   let g:WebDevIconsNerdTreeBeforeGlyphPadding = ' '
line 126: endif
line 127: 
line 128: if !exists('g:WebDevIconsNerdTreeAfterGlyphPadding')
line 129:   let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
line 130: endif
line 131: 
line 132: if !exists('g:WebDevIconsNerdTreeGitPluginForceVAlign')
line 133:   let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
line 134: endif
line 135: 
line 136: " fix for refreshing NERDTree flags upon creating new files
line 137: if !exists('g:NERDTreeUpdateOnCursorHold')
line 138:   let g:NERDTreeUpdateOnCursorHold = 1
line 139: endif
line 140: 
line 141: " config defaults {{{1
line 142: "========================================================================
line 143: 
line 144: if !exists('g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol')
line 145:   let g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol = ''
line 146: endif
line 147: 
line 148: if !exists('g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol')
line 149:   let g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol = ''
line 150: endif
line 151: 
line 152: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol')
line 153:   if g:DevIconsEnableFoldersOpenClose
line 154:     " use new glyph
line 155:     let g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol = ''
line 156:   else
line 157:     " use older glyph
line 158:     let g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol = ''
line 159:   endif
line 160: endif
line 161: 
line 162: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol')
line 163:   let g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol =  ''
line 164: endif
line 165: 
line 166: if !exists('g:DevIconsDefaultFolderOpenSymbol')
line 167:   let g:DevIconsDefaultFolderOpenSymbol = ''
line 168: endif
line 169: 
line 170: " functions {{{1
line 171: "========================================================================
line 172: 
line 173: " local functions {{{2
line 174: "========================================================================
line 175: 
line 176: " scope: local
line 177: function s:isDarwin()
line 205: 
line 206: " scope: local
line 207: function! s:strip(input)
line 210: 
line 211: " scope: local
line 212: function! s:setDictionaries()
line 389: 
line 390: " scope: local
line 391: function! s:setSyntax()
line 402: 
line 403: " scope: local
line 404: " stole solution/idea from nerdtree-git-plugin :)
line 405: function! s:setCursorHold()
line 412: 
line 413: " scope: local
line 414: " stole solution/idea from nerdtree-git-plugin :)
line 415: function! s:CursorHoldUpdate()
line 441: 
line 442: " scope: local
line 443: function! s:hardRefreshNerdTree()
line 449: 
line 450: " scope: local
line 451: function! s:softRefreshNerdTree()
line 457: 
line 458: " for vim-flagship plugin {{{3
line 459: "========================================================================
line 460: 
line 461: " scope: local
line 462: function! s:initializeFlagship()
line 477: 
line 478: " for unite plugin {{{3
line 479: "========================================================================
line 480: 
line 481: " scope: local
line 482: function! s:initializeUnite()
line 519: 
line 520: " for denite plugin {{{3
line 521: "========================================================================
line 522: 
line 523: " scope: local
line 524: function! s:initializeDenite()
line 529: 
line 530: " for vimfiler plugin {{{3
line 531: "========================================================================
line 532: 
line 533: " scope: local
line 534: function! s:initializeVimfiler()
line 542: 
line 543: " for ctrlp plugin {{{3
line 544: "========================================================================
line 545: 
line 546: " scope: local
line 547: " Initialize for up to date ctrlp fork: ctrlpvim/ctrlp.vim
line 548: " Support for kien/ctrlp.vim deprecated since v0.7.0
line 549: " @TODO implementation for CtrlP buffer and find file mode
line 550: function! s:initializeCtrlP()
line 574: 
line 575: " local initialization {{{2
line 576: "========================================================================
line 577: 
line 578: " scope: local
line 579: function! s:initialize()
line 589: 
line 590: " had some issues with VimEnter, for now using:
line 591: call s:initialize()
calling function <SNR>43_initialize()

line 1:   call s:setDictionaries()
calling function <SNR>43_initialize[1]..<SNR>43_setDictionaries()

line 1: 
line 2:   let s:file_node_extensions = { 'styl'     : '', 'sass'     : '', 'scss'     : '', 'htm'      : '', 'html'     : '', 'slim'     : '', 'ejs'      : '', 'css'      : '', 'less'     : '', 'md'       : '', 'markdown' : '', 'rmd'      : '', 'json'     : '', 'js'       : '', 'jsx'      : '', 'rb'       : '', 'php'      : '', 'py'       : '', 'pyc'      : '', 'pyo'      : '', 'pyd'      : '', 'coffee'   : '', 'mustache' : '', 'hbs'      : '', 'conf'     : '', 'ini'      : '', 'yml'      : '', 'yaml'     : '', 'bat'      : '', 'jpg'      : '', 'jpeg'     : '', 'bmp'      : '', 'png'      : '', 'gif'      : '', 'ico'      : '', 'twig'     : '', 'cpp'      : '', 'c++'      : '', 'cxx'      : '', 'cc'       : '', 'cp'       : '', 'c'        : '', 'h'        : '', 'hpp'      : '', 'hxx'      : '', 'hs'       : '', 'lhs'      : '', 'lua'      : '', 'java'     : '', 'sh
line 100: 
line 101:   let s:file_node_exact_matches = { 'exact-match-case-sensitive-1.txt' : '1', 'exact-match-case-sensitive-2'     : '2', 'gruntfile.coffee'                 : '', 'gruntfile.js'                     : '', 'gruntfile.ls'                     : '', 'gulpfile.coffee'                  : '', 'gulpfile.js'                      : '', 'gulpfile.ls'                      : '', 'dropbox'                          : '', '.ds_store'                        : '', '.gitconfig'                       : '', '.gitignore'                       : '', '.bashrc'                          : '', '.zshrc'                           : '', '.vimrc'                           : '', '.gvimrc'                          : '', '_vimrc'                           : '', '_gvimrc'                          : '', '.bashprofile'                     : '', 'favicon.ico'                      : '', 'license'                          : '', 'node_modules'                     : '', 'react.jsx'   
line 129: 
line 130:   let s:file_node_pattern_matches = { '.*jquery.*\.js$'       : '', '.*angular.*\.js$'      : '', '.*backbone.*\.js$'     : '', '.*require.*\.js$'      : '', '.*materialize.*\.js$'  : '', '.*materialize.*\.css$' : '', '.*mootools.*\.js$'     : '', '.*vimrc.*'             : '', 'Vagrantfile$'          : ''}
line 141: 
line 142:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols')
line 143:     let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = {}
line 144:   endif
line 145: 
line 146:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesExactSymbols')
line 147:     " do not remove: exact-match-case-sensitive-*
line 148:     let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols = {}
line 149:   endif
line 150: 
line 151:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols')
line 152:     let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols = {}
line 153:   endif
line 154: 
line 155:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 161: 
line 162:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 168: 
line 169:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 175: 
function <SNR>43_initialize[1]..<SNR>43_setDictionaries returning #0

continuing in function <SNR>43_initialize

line 2:   call s:setSyntax()
calling function <SNR>43_initialize[2]..<SNR>43_setSyntax()

line 1:   if g:webdevicons_enable_nerdtree == 1 && g:webdevicons_conceal_nerdtree_brackets == 1
line 2:     augroup webdevicons_conceal_nerdtree_brackets
line 3:       au!
line 4:       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=ALL
line 5:       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=ALL
line 6:       autocmd FileType nerdtree setlocal conceallevel=3
line 7:       autocmd FileType nerdtree setlocal concealcursor=nvic
line 8:     augroup END
line 9:   endif
function <SNR>43_initialize[2]..<SNR>43_setSyntax returning #0

continuing in function <SNR>43_initialize

line 3:   call s:setCursorHold()
calling function <SNR>43_initialize[3]..<SNR>43_setCursorHold()

line 1:   if g:webdevicons_enable_nerdtree
line 2:     augroup webdevicons_cursor_hold
line 3:       autocmd CursorHold * silent! call s:CursorHoldUpdate()
line 4:     augroup END
line 5:   endif
function <SNR>43_initialize[3]..<SNR>43_setCursorHold returning #0

continuing in function <SNR>43_initialize

line 4:   call s:initializeFlagship()
calling function <SNR>43_initialize[4]..<SNR>43_initializeFlagship()

line 1:   if exists('g:loaded_flagship')
line 2:     if g:webdevicons_enable_flagship_statusline
line 3:       augroup webdevicons_flagship_filetype
line 4:         autocmd User Flags call Hoist('buffer', 'WebDevIconsGetFileTypeSymbol')
line 5:       augroup END
line 6:     endif
line 7: 
line 8:     if g:webdevicons_enable_flagship_statusline_fileformat_symbols
line 9:       augroup webdevicons_flagship_filesymbol
line 10:         autocmd User Flags call Hoist('buffer', 'WebDevIconsGetFileFormatSymbol')
line 11:       augroup END
line 12:     endif
line 13:   endif
function <SNR>43_initialize[4]..<SNR>43_initializeFlagship returning #0

continuing in function <SNR>43_initialize

line 5:   call s:initializeUnite()
calling function <SNR>43_initialize[5]..<SNR>43_initializeUnite()

line 1:   if exists('g:loaded_unite') && g:webdevicons_enable_unite
line 2:     let s:filters = {   'name' : 'devicons_unite_converter',}
line 5: 
line 6:     function! s:filters.filter(candidates, context)
line 30: 
line 31:     call unite#define_filter(s:filters)
line 32:     unlet s:filters
line 33: 
line 34:     call unite#custom#source('file,file_rec,buffer,file_rec/async,file_rec/neovim,file_rec/neovim2,file_rec/git', 'converters', 'devicons_unite_converter')
line 35:   endif
function <SNR>43_initialize[5]..<SNR>43_initializeUnite returning #0

continuing in function <SNR>43_initialize

line 6:   call s:initializeDenite()
calling function <SNR>43_initialize[6]..<SNR>43_initializeDenite()

line 1:   if exists('g:loaded_denite') && g:webdevicons_enable_denite
line 2:     call denite#custom#source('file_rec,file_mru,file_old,buffer,directory_rec,directory_mru', 'converters', ['devicons_denite_converter'])
line 3:   endif
function <SNR>43_initialize[6]..<SNR>43_initializeDenite returning #0

continuing in function <SNR>43_initialize

line 7:   call s:initializeVimfiler()
calling function <SNR>43_initialize[7]..<SNR>43_initializeVimfiler()

line 1:   if exists('g:loaded_vimfiler') && g:webdevicons_enable_vimfiler
line 2:     call vimfiler#custom#profile('default', 'context', { 'columns' : 'devicons:size:time', 'explorer_columns': 'devicons' })
line 6:   endif
function <SNR>43_initialize[7]..<SNR>43_initializeVimfiler returning #0

continuing in function <SNR>43_initialize

line 8:   call s:initializeCtrlP()
calling function <SNR>43_initialize[8]..<SNR>43_initializeCtrlP()

line 1:   let l:ctrlp_warning_message = 'vim-devicons: https://github.com/kien/ctrlp.vim is deprecated since v0.7.0, please use https://github.com/ctrlpvim/ctrlp.vim'
line 2:   let l:ctrlp_warned_file = s:plugin_home . '/status_warned_ctrlp'
line 3: 
line 4:   if exists('g:loaded_ctrlp') && g:webdevicons_enable_ctrlp
line 5:     let l:forkedCtrlp = exists('g:ctrlp_mruf_map_string')
line 6: 
line 7:     if l:forkedCtrlp
line 8:       if !exists('g:ctrlp_formatline_func')
line 9:         " logic for ctrlpvim/ctrlp.vim:
line 10:         let g:ctrlp_formatline_func = 's:formatline(s:curtype() == "buf" ? v:val : WebDevIconsGetFileTypeSymbol(v:val) . " " . v:val) '
line 11:       endif
line 12:     elseif empty(glob(l:ctrlp_warned_file))
line 13:       " logic for kien/ctrlp.vim:
line 14:       echohl WarningMsg | echomsg l:ctrlp_warning_message
line 14:  echomsg l:ctrlp_warning_message
line 16:       " only warn first time, do not warn again:
line 17:       try
line 18:         execute writefile(['File automatically generated after warning about CtrlP once', l:ctrlp_warning_message], l:ctrlp_warned_file)
line 19:       catch
line 20:       endtry
line 21:     endif
line 22:   endif
function <SNR>43_initialize[8]..<SNR>43_initializeCtrlP returning #0

continuing in function <SNR>43_initialize

function <SNR>43_initialize returning #0

continuing in /home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim

line 592: 
line 593: " public functions {{{2
line 594: "========================================================================
line 595: 
line 596: " scope: public
line 597: function! webdevicons#version()
line 600: 
line 601: " scope: public
line 602: " allow the first version of refresh to now call softRefresh
line 603: function! webdevicons#refresh()
line 606: 
line 607: " scope: public
line 608: function! webdevicons#hardRefresh()
line 612: 
line 613: " scope: public
line 614: function! webdevicons#softRefresh()
line 618: 
line 619: " a:1 (bufferName), a:2 (isDirectory)
line 620: " scope: public
line 621: function! WebDevIconsGetFileTypeSymbol(...)
line 668: 
line 669: " scope: local
line 670: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 671: " actual font patcher)
line 672: function! s:DevIconsGetArtifactFix()
line 681: 
line 682: " scope: public
line 683: function! WebDevIconsGetFileFormatSymbol(...)
line 707: 
line 708: " for airline plugin {{{3
line 709: "========================================================================
line 710: 
line 711: " scope: public
line 712: function! AirlineWebDevIcons(...)
line 721: 
line 722: if g:webdevicons_enable == 1 && exists('g:loaded_airline') && g:loaded_airline == 1 && g:webdevicons_enable_airline_statusline
line 723:   call airline#add_statusline_func('AirlineWebDevIcons')
line 724: endif
line 725: 
line 726: if g:webdevicons_enable == 1 && g:webdevicons_enable_airline_tabline
line 727:   " Store original formatter.
line 728:   if exists('g:airline#extensions#tabline#formatter')
line 729:     let g:_webdevicons_airline_orig_formatter = g:airline#extensions#tabline#formatter
line 730:   else
line 731:     let g:_webdevicons_airline_orig_formatter = 'default'
line 732:   endif
line 733:   let g:airline#extensions#tabline#formatter = 'webdevicons'
line 734: endif
line 735: 
line 736: " for nerdtree plugin {{{3
line 737: "========================================================================
line 738: 
line 739: " scope: public
line 740: function! NERDTreeWebDevIconsRefreshListener(event)
line 821: 
line 822: " standard fix/safety: line continuation (avoiding side effects) {{{1
line 823: "========================================================================
line 824: let &cpo = s:save_cpo
line 825: unlet s:save_cpo
line 826: 
line 827: " modeline syntax:
line 828: " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:
finished sourcing /home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim
Searching for "/home/ringu/.vim/plugged/fzf.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/fzf.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim"
line 1: " Copyright (c) 2015 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: let s:cpo_save = &cpo
line 25: set cpo&vim
line 26: let s:is_win = has('win32') || has('win64')
line 27: 
line 28: function! s:defs(commands)
line 41: 
line 64: call s:defs(['command!      -bang -nargs=? -complete=dir Files       call fzf#vim#files(<q-args>, <bang>0)','command!      -bang -nargs=? GitFiles                  call fzf#vim#gitfiles(<q-args>, <bang>0)','command!      -bang -nargs=? GFiles                    call fzf#vim#gitfiles(<q-args>, <bang>0)','command! -bar -bang -nargs=? -complete=buffer Buffers  call fzf#vim#buffers(<q-args>, <bang>0)','command!      -bang -nargs=* Lines                     call fzf#vim#lines(<q-args>, <bang>0)','command!      -bang -nargs=* BLines                    call fzf#vim#buffer_lines(<q-args>, <bang>0)','command! -bar -bang Colors                             call fzf#vim#colors(<bang>0)','command!      -bang -nargs=+ -complete=dir Locate      call fzf#vim#locate(<q-args>, <bang>0)','command!      -bang -nargs=* Ag                        call fzf#vim#ag(<q-args>, <bang>0)','command!      -bang -nargs=* Rg                        call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case "
calling function <SNR>44_defs(['command!      -bang -nargs=? -comple...    call s:history(<q-args>, <bang>0)'])

line 1:   let prefix = get(g:, 'fzf_command_prefix', '')
line 2:   if prefix =~# '^[^A-Z]'
line 3:     echoerr 'g:fzf_command_prefix must start with an uppercase letter'
line 4:     return
line 5:   endif
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? -complete=dir Files       call fzf#vim#files(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GitFiles                  call fzf#vim#gitfiles(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GFiles                    call fzf#vim#gitfiles(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang -nargs=? -complete=buffer Buffers  call fzf#vim#buffers(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Lines                     call fzf#vim#lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BLines                    call fzf#vim#buffer_lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Colors                             call fzf#vim#colors(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=+ -complete=dir Locate      call fzf#vim#locate(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Ag                        call fzf#vim#ag(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Rg                        call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Tags                      call fzf#vim#tags(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BTags                     call fzf#vim#buffer_tags(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Snippets                           call fzf#vim#snippets(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Commands                           call fzf#vim#commands(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Marks                              call fzf#vim#marks(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Helptags                           call fzf#vim#helptags(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Windows                            call fzf#vim#windows(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Commits                            call fzf#vim#commits(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang BCommits                           call fzf#vim#buffer_commits(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Maps                               call fzf#vim#maps("n", <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Filetypes                          call fzf#vim#filetypes(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* History                   call s:history(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 10:     endif
line 11:   endfor
function <SNR>44_defs returning #0

continuing in /home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim

line 65: 
line 66: function! s:history(arg, bang)
line 76: 
line 77: function! fzf#complete(...)
line 80: 
line 81: if (has('nvim') || has('terminal') && has('patch-8.0.995')) && (get(g:, 'fzf_statusline', 1) || get(g:, 'fzf_nvim_statusline', 1))
line 82:   function! s:fzf_restore_colors()
line 98: 
line 99:   function! s:fzf_vim_term()
line 109: 
line 110:   augroup _fzf_statusline
line 111:     autocmd!
line 112:     autocmd FileType fzf call s:fzf_vim_term()
line 113:   augroup END
line 114: endif
line 115: 
line 116: if !exists('g:fzf#vim#buffers')
line 117:   let g:fzf#vim#buffers = {}
line 118: endif
line 119: 
line 120: augroup fzf_buffers
line 121:   autocmd!
line 122:   if exists('*reltimefloat')
line 123:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
line 124:   else
line 125:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = localtime()
line 126:   endif
line 127:   autocmd BufDelete * silent! call remove(g:fzf#vim#buffers, expand('<abuf>'))
line 128: augroup END
line 129: 
line 130: inoremap <expr> <plug>(fzf-complete-word)        fzf#vim#complete#word()
line 131: if s:is_win
line 132:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path('dir /s/b')
line 133:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path('dir /s/b/a:-d')
line 134: else
line 135:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'")
line 136:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -type f -print -o -type l -print \| sed 's:^..::'")
line 137: endif
line 138: inoremap <expr> <plug>(fzf-complete-file-ag)     fzf#vim#complete#path('ag -l -g ""')
line 139: inoremap <expr> <plug>(fzf-complete-line)        fzf#vim#complete#line()
line 140: inoremap <expr> <plug>(fzf-complete-buffer-line) fzf#vim#complete#buffer_line()
line 141: 
line 142: nnoremap <silent> <plug>(fzf-maps-n) :<c-u>call fzf#vim#maps('n', 0)<cr>
line 143: inoremap <silent> <plug>(fzf-maps-i) <c-o>:call fzf#vim#maps('i', 0)<cr>
line 144: xnoremap <silent> <plug>(fzf-maps-x) :<c-u>call fzf#vim#maps('x', 0)<cr>
line 145: onoremap <silent> <plug>(fzf-maps-o) <c-c>:<c-u>call fzf#vim#maps('o', 0)<cr>
line 146: 
line 147: let &cpo = s:cpo_save
line 148: unlet s:cpo_save
line 149: 
finished sourcing /home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim
Searching for "/home/ringu/.vim/plugged/fugitive.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/fugitive.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.2
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive') || &cp
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: if !exists('g:fugitive_git_executable')
line 12:   let g:fugitive_git_executable = 'git'
line 13: endif
line 14: 
line 15: " Section: Utility
line 16: 
line 17: function! s:function(name) abort
line 20: 
line 21: function! s:sub(str,pat,rep) abort
line 24: 
line 25: function! s:gsub(str,pat,rep) abort
line 28: 
line 29: function! s:winshell() abort
line 32: 
line 33: function! s:shellesc(arg) abort
line 42: 
line 43: function! s:fnameescape(file) abort
line 50: 
line 51: function! s:throw(string) abort
line 55: 
line 56: function! s:warn(str) abort
line 62: 
line 63: function! s:shellslash(path) abort
line 70: 
line 71: let s:git_versions = {}
line 72: 
line 73: function! fugitive#git_version(...) abort
line 79: 
line 80: function! s:recall() abort
line 97: 
line 98: function! s:add_methods(namespace, method_names) abort
line 103: 
line 104: let s:commands = []
line 105: function! s:command(definition) abort
line 108: 
line 109: function! s:define_commands() abort
line 114: 
line 115: augroup fugitive_utility
line 116:   autocmd!
line 117:   autocmd User Fugitive call s:define_commands()
line 118: augroup END
line 119: 
line 120: let s:abstract_prototype = {}
line 121: 
line 122: " Section: Initialization
line 123: 
line 124: function! fugitive#is_git_dir(path) abort
line 128: 
line 129: function! fugitive#extract_git_dir(path) abort
line 176: 
line 177: function! fugitive#detect(path) abort
line 218: 
line 219: augroup fugitive
line 220:   autocmd!
line 221:   autocmd BufNewFile,BufReadPost * call fugitive#detect(expand('<amatch>:p'))
line 222:   autocmd FileType           netrw call fugitive#detect(expand('%:p'))
line 223:   autocmd User NERDTreeInit,NERDTreeNewRoot call fugitive#detect(b:NERDTreeRoot.path.str())
line 224:   autocmd VimEnter * if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 225:   autocmd CmdWinEnter * call fugitive#detect(expand('#:p'))
line 226:   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 227: augroup END
line 228: 
line 229: " Section: Repository
line 230: 
line 231: let s:repo_prototype = {}
line 232: let s:repos = {}
line 233: let s:worktree_for_dir = {}
line 234: let s:dir_for_worktree = {}
line 235: 
line 236: function! s:repo(...) abort
line 249: 
line 250: function! fugitive#repo(...) abort
line 253: 
line 254: function! s:repo_dir(...) dict abort
line 257: 
line 258: function! s:configured_tree(git_dir) abort
line 277: 
line 278: function! s:repo_tree(...) dict abort
line 290: 
line 291: function! s:repo_bare() dict abort
line 298: 
line 299: function! s:repo_translate(spec) dict abort
line 343: 
line 344: function! s:repo_head(...) dict abort
line 359: 
line 360: call s:add_methods('repo',['dir','tree','bare','translate','head'])
calling function <SNR>45_add_methods('repo', ['dir', 'tree', 'bare', 'translate', 'head'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_dir')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_tree')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_bare')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_translate')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_head')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_head')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 361: 
line 362: function! s:repo_git_command(...) dict abort
line 366: 
line 367: function! s:repo_git_chomp(...) dict abort
line 370: 
line 371: function! s:repo_git_chomp_in_tree(...) dict abort
line 381: 
line 382: function! s:repo_rev_parse(rev) dict abort
line 389: 
line 390: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])
calling function <SNR>45_add_methods('repo', ['git_command', 'git_chomp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_command')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_chomp')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_chomp_in_tree')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_rev_parse')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 391: 
line 392: function! s:repo_dirglob(base) dict abort
line 398: 
line 399: function! s:repo_superglob(base) dict abort
line 436: 
line 437: call s:add_methods('repo',['dirglob','superglob'])
calling function <SNR>45_add_methods('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_dirglob')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_superglob')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 438: 
line 439: function! s:repo_config(conf) dict abort
line 442: 
line 443: function! s:repo_user() dict abort
line 448: 
line 449: function! s:repo_aliases() dict abort
line 458: 
line 459: call s:add_methods('repo',['config', 'user', 'aliases'])
calling function <SNR>45_add_methods('repo', ['config', 'user', 'aliases'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_config')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_user')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_aliases')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_aliases')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 460: 
line 461: function! s:repo_keywordprg() dict abort
line 469: 
line 470: call s:add_methods('repo',['keywordprg'])
calling function <SNR>45_add_methods('repo', ['keywordprg'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_keywordprg')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 471: 
line 472: " Section: Buffer
line 473: 
line 474: let s:buffer_prototype = {}
line 475: 
line 476: function! s:buffer(...) abort
line 484: 
line 485: function! fugitive#buffer(...) abort
line 488: 
line 489: function! s:buffer_getvar(var) dict abort
line 492: 
line 493: function! s:buffer_setvar(var,value) dict abort
line 496: 
line 497: function! s:buffer_getline(lnum) dict abort
line 500: 
line 501: function! s:buffer_repo() dict abort
line 504: 
line 505: function! s:buffer_type(...) dict abort
line 529: 
line 530: if has('win32')
line 531: 
line 532:   function! s:buffer_spec() dict abort
line 540: 
line 541: else
line 542: 
line 543:   function! s:buffer_spec() dict abort
line 547: 
line 548: endif
line 549: 
line 550: function! s:buffer_name() dict abort
line 553: 
line 554: function! s:buffer_commit() dict abort
line 557: 
line 558: function! s:buffer_path(...) dict abort
line 569: 
line 570: function! s:buffer_rev() dict abort
line 584: 
line 585: function! s:buffer_sha1() dict abort
line 592: 
line 593: function! s:buffer_expand(rev) dict abort
line 610: 
line 611: function! s:buffer_containing_commit() dict abort
line 620: 
line 621: function! s:buffer_up(...) dict abort
line 644: 
line 645: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit','up'])
calling function <SNR>45_add_methods('buffer', ['getvar', 'setvar', 'getline', 'repo'...', 'expand', 'containing_commit', 'up'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_getvar')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_setvar')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_getline')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_repo')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_type')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_spec')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_name')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_commit')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_path')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_rev')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_sha1')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_expand')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_containing_commit')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_up')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_up')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 646: 
line 647: " Section: Git
line 648: 
line 649: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...e Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 650: 
line 651: function! s:ExecuteInTree(cmd) abort
line 661: 
line 662: function! s:Git(bang, args) abort
line 675: 
line 676: function! fugitive#git_commands() abort
line 682: 
line 683: function! s:GitComplete(A, L, P) abort
line 691: 
line 692: " Section: Gcd, Glcd
line 693: 
line 694: function! s:DirComplete(A,L,P) abort
line 698: 
line 699: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>45_command('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 700: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>45_command('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 701: 
line 702: " Section: Gstatus
line 703: 
line 704: call s:command("-bar Gstatus :execute s:Status()")
calling function <SNR>45_command('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 705: augroup fugitive_status
line 706:   autocmd!
line 707:   if !has('win32')
line 708:     autocmd FocusGained,ShellCmdPost * call fugitive#reload_status()
line 709:   endif
line 710: augroup END
line 711: 
line 712: function! s:Status() abort
line 723: 
line 724: function! fugitive#reload_status() abort
line 756: 
line 757: function! s:stage_info(lnum) abort
line 782: 
line 783: function! s:StageNext(count) abort
line 789: 
line 790: function! s:StagePrevious(count) abort
line 800: 
line 801: function! s:StageReloadSeek(target,lnum1,lnum2) abort
line 812: 
line 813: function! s:StageUndo() abort
line 834: 
line 835: function! s:StageDiff(diff) abort
line 853: 
line 854: function! s:StageDiffEdit() abort
line 876: 
line 877: function! s:StageToggle(lnum1,lnum2) abort
line 941: 
line 942: function! s:StagePatch(lnum1,lnum2) abort
line 987: 
line 988: " Section: Gcommit
line 989: 
line 990: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")
calling function <SNR>45_command('-nargs=? -complete=customlist,s:Commi...te Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 991: 
line 992: function! s:Commit(args, ...) abort
line 1074: 
line 1075: function! s:CommitComplete(A,L,P) abort
line 1083: 
line 1084: function! s:FinishCommit() abort
line 1092: 
line 1093: " Section: Gmerge, Gpull
line 1094: 
line 1096: call s:command("-nargs=? -bang -complete=custom,s:RevisionComplete Gmerge " . "execute s:Merge('merge', <bang>0, <q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rev... s:Merge(''merge'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1098: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpull " . "execute s:Merge('pull --progress', <bang>0, <q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...'pull --progress'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1099: 
line 1100: function! s:RevisionComplete(A, L, P) abort
line 1104: 
line 1105: function! s:RemoteComplete(A, L, P) abort
line 1116: 
line 1117: function! fugitive#cwindow() abort
line 1127: 
line 1134: let s:common_efm = '' . '%+Egit:%.%#,' . '%+Eusage:%.%#,' . '%+Eerror:%.%#,' . '%+Efatal:%.%#,' . '%-G%.%#%\e[K%.%#,' . '%-G%.%#%\r%.%\+'
line 1135: 
line 1136: function! s:Merge(cmd, bang, args) abort
line 1211: 
line 1212: " Section: Ggrep, Glog
line 1213: 
line 1214: if !exists('g:fugitive_summary_format')
line 1215:   let g:fugitive_summary_format = '%s'
line 1216: endif
line 1217: 
line 1218: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...cute s:Grep(''grep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1219: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...ute s:Grep(''lgrep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1220: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1221: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1222: 
line 1223: function! s:Grep(cmd,bang,arg) abort
line 1261: 
line 1262: function! s:Log(cmd, line1, line2, ...) abort
line 1299: 
line 1300: " Section: Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread
line 1301: 
line 1302: function! s:Edit(cmd,bang,...) abort
line 1378: 
line 1379: function! s:EditComplete(A,L,P) abort
line 1382: 
line 1383: function! s:EditRunComplete(A,L,P) abort
line 1390: 
line 1391: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1392: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1393: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ute s:Edit(''pedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1394: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ute s:Edit(''split'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1395: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...te s:Edit(''vsplit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1396: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...e s:Edit(''tabedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1397: call s:command("-bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -count -complete=... : <count>).''read'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1398: 
line 1399: " Section: Gwrite, Gwq
line 1400: 
line 1401: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1402: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl... Gw :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1403: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...te Gwq :execute s:Wq(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1404: 
line 1405: function! s:Write(force,...) abort
line 1541: 
line 1542: function! s:Wq(force,...) abort
line 1554: 
line 1555: augroup fugitive_commit
line 1556:   autocmd!
line 1557:   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')
line 1558: augroup END
line 1559: 
line 1560: " Section: Gpush, Gfetch
line 1561: 
line 1562: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...spatch(''<bang>'', ''push ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1563: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...patch(''<bang>'', ''fetch ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1564: 
line 1565: function! s:Dispatch(bang, args)
line 1588: 
line 1589: " Section: Gdiff
line 1590: 
line 1591: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)")
calling function <SNR>45_command('-bang -bar -nargs=* -complete=customl...e Gdiff :execute s:Diff('''',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1592: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)")
calling function <SNR>45_command('-bar -nargs=* -complete=customlist,s:...ute s:Diff(''keepalt vert '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1593: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)")
calling function <SNR>45_command('-bar -nargs=* -complete=customlist,s:...:execute s:Diff(''keepalt '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1594: 
line 1595: augroup fugitive_diff
line 1596:   autocmd!
line 1600:   autocmd BufWinLeave * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 1604:   autocmd BufWinEnter * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
line 1605: augroup END
line 1606: 
line 1607: function! s:can_diffoff(buf) abort
line 1612: 
line 1613: function! fugitive#can_diffoff(buf) abort
line 1616: 
line 1617: function! s:diff_modifier(count) abort
line 1629: 
line 1630: function! s:diff_window_count() abort
line 1637: 
line 1638: function! s:diff_restore() abort
line 1652: 
line 1653: function! s:diffthis() abort
line 1659: 
line 1660: function! s:diffoff() abort
line 1668: 
line 1669: function! s:diffoff_all(dir) abort
line 1682: 
line 1683: function! s:buffer_compare_age(commit) dict abort
line 1702: 
line 1703: call s:add_methods('buffer',['compare_age'])
calling function <SNR>45_add_methods('buffer', ['compare_age'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_compare_age')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1704: 
line 1705: function! s:Diff(vert,...) abort
line 1769: 
line 1770: " Section: Gmove, Gremove
line 1771: 
line 1772: function! s:Move(force,destination) abort
line 1805: 
line 1806: function! s:MoveComplete(A,L,P) abort
line 1815: 
line 1816: function! s:Remove(force) abort
line 1837: 
line 1838: augroup fugitive_remove
line 1839:   autocmd!
line 1843:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 1844: augroup END
line 1845: 
line 1846: " Section: Gblame
line 1847: 
line 1848: augroup fugitive_blame
line 1849:   autocmd!
line 1850:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame
line 1851:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif
line 1852:   autocmd Syntax fugitiveblame call s:BlameSyntax()
line 1853:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 1854:   autocmd ColorScheme,GUIEnter * call s:RehighlightBlame()
line 1855: augroup END
line 1856: 
line 1857: function! s:linechars(pattern) abort
line 1866: 
line 1867: function! s:Blame(bang,line1,line2,count,args) abort
line 1982: 
line 1983: function! s:BlameCommit(cmd) abort
line 2023: 
line 2024: function! s:BlameJump(suffix) abort
line 2057: 
line 2058: let s:hash_colors = {}
line 2059: 
line 2060: function! s:BlameSyntax() abort
line 2108: 
line 2109: function! s:RehighlightBlame() abort
line 2118: 
line 2119: " Section: Gbrowse
line 2120: 
line 2121: call s:command("-bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -range -nargs=* -complete=...owse(<bang>0,<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2122: 
line 2123: function! s:Browse(bang,line1,count,...) abort
line 2234: 
line 2235: function! s:github_url(opts, ...) abort
line 2296: 
line 2297: function! s:instaweb_url(opts) abort
line 2337: 
line 2338: if !exists('g:fugitive_browse_handlers')
line 2339:   let g:fugitive_browse_handlers = []
line 2340: endif
line 2341: 
line 2343: call extend(g:fugitive_browse_handlers, [s:function('s:github_url'), s:function('s:instaweb_url')])
calling function <SNR>45_function('s:github_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_function returning function('<SNR>45_github_url')

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

calling function <SNR>45_function('s:instaweb_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_function returning function('<SNR>45_instaweb_url')

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2344: 
line 2345: " Section: File access
line 2346: 
line 2347: function! s:ReplaceCmd(cmd,...) abort
line 2386: 
line 2387: function! s:BufReadIndex() abort
line 2462: 
line 2463: function! s:FileRead() abort
line 2479: 
line 2480: function! s:BufReadIndexFile() abort
line 2500: 
line 2501: function! s:BufWriteIndexFile() abort
line 2533: 
line 2534: function! s:BufReadObject() abort
line 2615: 
line 2616: augroup fugitive_files
line 2617:   autocmd!
line 2624:   autocmd BufReadCmd  index{,.lock} if fugitive#is_git_dir(expand('<amatch>:p:h')) |   exe s:BufReadIndex() | elseif filereadable(expand('<amatch>')) |   read <amatch> |   1delete | endif
line 2625:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()
line 2626:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()
line 2627:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()
line 2628:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()
line 2629:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()
line 2633:   autocmd FileType git if exists('b:git_dir') |  call s:JumpInit() | endif
line 2634: augroup END
line 2635: 
line 2636: " Section: Temp files
line 2637: 
line 2638: if !exists('s:temp_files')
line 2639:   let s:temp_files = {}
line 2640: endif
line 2641: 
line 2642: augroup fugitive_temp
line 2643:   autocmd!
line 2652:   autocmd BufNewFile,BufReadPost * if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 2653: augroup END
line 2654: 
line 2655: " Section: Go to file
line 2656: 
line 2657: function! s:JumpInit() abort
line 2675: 
line 2676: function! s:GF(mode) abort
line 2847: 
line 2848: " Section: Statusline
line 2849: 
line 2850: function! s:repo_head_ref() dict abort
line 2856: 
line 2857: call s:add_methods('repo',['head_ref'])
calling function <SNR>45_add_methods('repo', ['head_ref'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_head_ref')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2858: 
line 2859: function! fugitive#statusline(...) abort
line 2874: 
line 2875: function! fugitive#head(...) abort
line 2882: 
line 2883: " Section: Folding
line 2884: 
line 2885: function! fugitive#foldtext() abort
line 2923: 
line 2924: augroup fugitive_foldtext
line 2925:   autocmd!
line 2929:   autocmd User Fugitive if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 2930: augroup END
finished sourcing /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim"
line 1: scriptencoding utf-8
line 2: 
line 3: if exists('g:loaded_gitgutter') || !has('signs') || &cp
line 4:   finish
line 5: endif
line 6: let g:loaded_gitgutter = 1
line 7: 
line 8: " Initialisation {{{
line 9: 
line 10: if v:version < 703 || (v:version == 703 && !has("patch105"))
line 11:   call gitgutter#utility#warn('requires Vim 7.3.105')
line 12:   finish
line 13: endif
line 14: 
line 15: function! s:set(var, default) abort
line 24: 
line 25: call s:set('g:gitgutter_enabled',                     1)
calling function <SNR>46_set('g:gitgutter_enabled', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_enabled = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 26: call s:set('g:gitgutter_max_signs',                 500)
calling function <SNR>46_set('g:gitgutter_max_signs', 500)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_max_signs = 500
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 27: call s:set('g:gitgutter_signs',                       1)
calling function <SNR>46_set('g:gitgutter_signs', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_signs = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 28: call s:set('g:gitgutter_highlight_lines',             0)
calling function <SNR>46_set('g:gitgutter_highlight_lines', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_highlight_lines = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 29: call s:set('g:gitgutter_sign_column_always',          0)
calling function <SNR>46_set('g:gitgutter_sign_column_always', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_sign_column_always = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 30: if g:gitgutter_sign_column_always && exists('&signcolumn')
line 31:   " Vim 7.4.2201.
line 32:   set signcolumn=yes
line 33:   let g:gitgutter_sign_column_always = 0
line 34:   call gitgutter#utility#warn('please replace "let g:gitgutter_sign_column_always=1" with "set signcolumn=yes"')
line 35: endif
line 36: call s:set('g:gitgutter_override_sign_column_highlight', 1)
calling function <SNR>46_set('g:gitgutter_override_sign_column_highlight', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 37: call s:set('g:gitgutter_sign_added',                   '+')
calling function <SNR>46_set('g:gitgutter_sign_added', '+')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_added = '+'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 38: call s:set('g:gitgutter_sign_modified',                '~')
calling function <SNR>46_set('g:gitgutter_sign_modified', '~')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified = '~'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 39: call s:set('g:gitgutter_sign_removed',                 '_')
calling function <SNR>46_set('g:gitgutter_sign_removed', '_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed = '_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 40: 
line 41: if gitgutter#utility#supports_overscore_sign()
Searching for "autoload/gitgutter/utility.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 41: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim"
line 1: function! gitgutter#utility#supports_overscore_sign()
line 8: 
line 9: function! gitgutter#utility#setbufvar(buffer, varname, val)
line 23: 
line 24: function! gitgutter#utility#getbufvar(buffer, varname, ...)
line 34: 
line 35: function! gitgutter#utility#warn(message) abort
line 41: 
line 42: function! gitgutter#utility#warn_once(bufnr, message, key) abort
line 51: 
line 52: " Returns truthy when the buffer's file should be processed; and falsey when it shouldn't.
line 53: " This function does not and should not make any system calls.
line 54: function! gitgutter#utility#is_active(bufnr) abort
line 62: 
line 63: function! s:not_git_dir(bufnr) abort
line 66: 
line 67: function! s:is_file_buffer(bufnr) abort
line 70: 
line 71: " From tpope/vim-fugitive
line 72: function! s:winshell()
line 75: 
line 76: " From tpope/vim-fugitive
line 77: function! gitgutter#utility#shellescape(arg) abort
line 86: 
line 87: function! gitgutter#utility#file(bufnr)
line 90: 
line 91: " Not shellescaped
line 92: function! gitgutter#utility#extension(bufnr) abort
line 95: 
line 96: function! gitgutter#utility#system(cmd, ...) abort
line 105: 
line 106: " Path of file relative to repo root.
line 107: "
line 108: " *     empty string - not set
line 109: " * non-empty string - path
line 110: " *               -1 - pending
line 111: " *               -2 - not tracked by git
line 112: function! gitgutter#utility#repo_path(bufnr, shellesc) abort
line 116: 
line 117: function! gitgutter#utility#set_repo_path(bufnr) abort
line 154: 
line 155: if has('nvim') && !has('nvim-0.2.0')
line 156:   function! s:not_tracked_by_git(bufnr)
line 159: endif
line 160: 
line 161: function! s:set_path(bufnr, path)
line 169: 
line 170: function! gitgutter#utility#cd_cmd(bufnr, cmd) abort
line 174: 
line 175: function! s:unc_path(bufnr)
line 178: 
line 179: function! s:use_known_shell() abort
line 186: 
line 187: function! s:restore_shell() abort
line 192: 
line 193: function! s:abs_path(bufnr, shellesc)
line 197: 
line 198: function! s:dir(bufnr) abort
line 201: 
line 202: " Not shellescaped.
line 203: function! s:filename(bufnr) abort
line 206: 
line 207: function! s:exists_file(bufnr) abort
line 210: 
line 211: " Get rid of any trailing new line or SOH character.
line 212: "
line 213: " git ls-files -z produces output with null line termination.
line 214: " Vim's system() replaces any null characters in the output
line 215: " with SOH (start of header), i.e. ^A.
line 216: function! s:strip_trailing_new_line(line) abort
line 219: 
line 220: function! gitgutter#utility#windows()
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim
continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
calling function gitgutter#utility#supports_overscore_sign()

line 1:   if gitgutter#utility#windows()
calling function gitgutter#utility#supports_overscore_sign[1]..gitgutter#utility#windows()

line 1:   return has('win64') || has('win32') || has('win16')
function gitgutter#utility#supports_overscore_sign[1]..gitgutter#utility#windows returning #0

continuing in function gitgutter#utility#supports_overscore_sign

line 2:     return &encoding ==? 'utf-8'
line 3:   else
line 4:     return &termencoding ==? &encoding || &termencoding == ''
function gitgutter#utility#supports_overscore_sign returning #1

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 42:   call s:set('g:gitgutter_sign_removed_first_line', '')
calling function <SNR>46_set('g:gitgutter_sign_removed_first_line', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed_first_line = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 43: else
line 44:   call s:set('g:gitgutter_sign_removed_first_line', '_^')
line 45: endif
line 46: 
line 47: call s:set('g:gitgutter_sign_removed_above_and_below', '[')
calling function <SNR>46_set('g:gitgutter_sign_removed_above_and_below', '[')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed_above_and_below = '['
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 48: call s:set('g:gitgutter_sign_modified_removed',       '~_')
calling function <SNR>46_set('g:gitgutter_sign_modified_removed', '~_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified_removed = '~_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 49: call s:set('g:gitgutter_git_args',                      '')
calling function <SNR>46_set('g:gitgutter_git_args', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_git_args = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 50: call s:set('g:gitgutter_diff_args',                     '')
calling function <SNR>46_set('g:gitgutter_diff_args', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_diff_args = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 51: call s:set('g:gitgutter_diff_base',                     '')
calling function <SNR>46_set('g:gitgutter_diff_base', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_diff_base = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 52: call s:set('g:gitgutter_map_keys',                       1)
calling function <SNR>46_set('g:gitgutter_map_keys', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_map_keys = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 53: call s:set('g:gitgutter_terminal_reports_focus',         1)
calling function <SNR>46_set('g:gitgutter_terminal_reports_focus', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_terminal_reports_focus = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 54: call s:set('g:gitgutter_async',                          1)
calling function <SNR>46_set('g:gitgutter_async', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_async = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 55: call s:set('g:gitgutter_log',                            0)
calling function <SNR>46_set('g:gitgutter_log', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_log = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 56: 
line 57: call s:set('g:gitgutter_git_executable', 'git')
calling function <SNR>46_set('g:gitgutter_git_executable', 'git')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_git_executable = 'git'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 58: if !executable(g:gitgutter_git_executable)
line 59:   call gitgutter#utility#warn('cannot find git. Please set g:gitgutter_git_executable.')
line 60: endif
line 61: 
line 62: let default_grep = 'grep'
line 63: call s:set('g:gitgutter_grep', default_grep)
calling function <SNR>46_set('g:gitgutter_grep', 'grep')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_grep = 'grep'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 64: if !empty(g:gitgutter_grep)
line 65:   if executable(split(g:gitgutter_grep)[0])
line 66:     if $GREP_OPTIONS =~# '--color=always'
line 67:       let g:gitgutter_grep .= ' --color=never'
line 68:     endif
line 69:   else
line 70:     if g:gitgutter_grep !=# default_grep
line 71:       call gitgutter#utility#warn('cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
line 72:     endif
line 73:     let g:gitgutter_grep = ''
line 74:   endif
line 75: endif
line 76: 
line 77: call gitgutter#highlight#define_sign_column_highlight()
Searching for "autoload/gitgutter/highlight.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 77: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim"
line 1: function! gitgutter#highlight#line_disable() abort
line 12: 
line 13: function! gitgutter#highlight#line_enable() abort
line 25: 
line 26: function! gitgutter#highlight#line_toggle() abort
line 33: 
line 34: 
line 35: function! gitgutter#highlight#define_sign_column_highlight() abort
line 42: 
line 43: function! gitgutter#highlight#define_highlights() abort
line 70: 
line 71: function! gitgutter#highlight#define_signs() abort
line 84: 
line 85: function! s:define_sign_text() abort
line 93: 
line 94: function! gitgutter#highlight#define_sign_text_highlights() abort
line 115: 
line 116: function! s:define_sign_line_highlights() abort
line 133: 
line 134: function! s:get_background_colors(group) abort
line 148: 
line 149: function! s:match_highlight(highlight, pattern) abort
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim
continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
calling function gitgutter#highlight#define_sign_column_highlight()

line 1:   if g:gitgutter_override_sign_column_highlight
line 2:     highlight! link SignColumn LineNr
line 3:   else
line 4:     highlight default link SignColumn LineNr
line 5:   endif
function gitgutter#highlight#define_sign_column_highlight returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 78: call gitgutter#highlight#define_highlights()
calling function gitgutter#highlight#define_highlights()

line 1:   let [guibg, ctermbg] = s:get_background_colors('SignColumn')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors('SignColumn')

line 1:   redir => highlight
line 2:   silent execute 'silent highlight ' . a:group
line 2: silent highlight SignColumn
SignColumn     xxx term=standout ctermbg=237 guibg=#3c3836
	Last set from /usr/share/vim/vimfiles/colors/gruvbox.vim line 417
line 3:   redir END
line 4: 
line 5:   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
line 6:   if len(link_matches) > 0 " follow the link
line 7:     return s:get_background_colors(link_matches[1])
line 8:   endif
line 9: 
line 10:   let ctermbg = s:match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[10]..<SNR>48_match_highlight('
line 2:   silent execute ''silent h...vbox.vim line 417
line 3:   redir END', 'ctermbg=\([0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[10]..<SNR>48_match_highlight returning '237'

continuing in function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors

line 11:   let guibg   = s:match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[11]..<SNR>48_match_highlight('
line 2:   silent execute ''silent h...vbox.vim line 417
line 3:   redir END', 'guibg=\([#0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[11]..<SNR>48_match_highlight returning '#3c3836'

continuing in function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors

line 12:   return [guibg, ctermbg]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors returning ['#3c3836', '237']

continuing in function gitgutter#highlight#define_highlights

line 2: 
line 3:   " Highlights used by the signs.
line 4: 
line 5:   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
line 5: highlight GitGutterAddDefault    guifg=#009900 guibg=#3c3836 ctermfg=2 ctermbg=237
line 6:   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
line 6: highlight GitGutterChangeDefault guifg=#bbbb00 guibg=#3c3836 ctermfg=3 ctermbg=237
line 7:   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
line 7: highlight GitGutterDeleteDefault guifg=#ff2222 guibg=#3c3836 ctermfg=1 ctermbg=237
line 8:   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
line 9: 
line 10:   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 10: highlight GitGutterAddInvisible    guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 11:   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 11: highlight GitGutterChangeInvisible guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 12:   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 12: highlight GitGutterDeleteInvisible guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 13:   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
line 14: 
line 15:   highlight default link GitGutterAdd          GitGutterAddDefault
line 16:   highlight default link GitGutterChange       GitGutterChangeDefault
line 17:   highlight default link GitGutterDelete       GitGutterDeleteDefault
line 18:   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
line 19: 
line 20:   " Highlights used for the whole line.
line 21: 
line 22:   highlight default link GitGutterAddLine          DiffAdd
line 23:   highlight default link GitGutterChangeLine       DiffChange
line 24:   highlight default link GitGutterDeleteLine       DiffDelete
line 25:   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
function gitgutter#highlight#define_highlights returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 79: call gitgutter#highlight#define_signs()
calling function gitgutter#highlight#define_signs()

line 1:   sign define GitGutterLineAdded
line 2:   sign define GitGutterLineModified
line 3:   sign define GitGutterLineRemoved
line 4:   sign define GitGutterLineRemovedFirstLine
line 5:   sign define GitGutterLineRemovedAboveAndBelow
line 6:   sign define GitGutterLineModifiedRemoved
line 7:   sign define GitGutterDummy
line 8: 
line 9:   call s:define_sign_text()
calling function gitgutter#highlight#define_signs[9]..<SNR>48_define_sign_text()

line 1:   execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
line 1: sign define GitGutterLineAdded                 text=+
line 2:   execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
line 2: sign define GitGutterLineModified              text=~
line 3:   execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
line 3: sign define GitGutterLineRemoved               text=_
line 4:   execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
line 4: sign define GitGutterLineRemovedFirstLine      text=
line 5:   execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
line 5: sign define GitGutterLineRemovedAboveAndBelow  text=[
line 6:   execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed
line 6: sign define GitGutterLineModifiedRemoved       text=~_
function gitgutter#highlight#define_signs[9]..<SNR>48_define_sign_text returning #0

continuing in function gitgutter#highlight#define_signs

line 10:   call gitgutter#highlight#define_sign_text_highlights()
calling function gitgutter#highlight#define_signs[10]..gitgutter#highlight#define_sign_text_highlights()

line 1:   " Once a sign's text attribute has been defined, it cannot be undefined or
line 2:   " set to an empty value.  So to make signs' text disappear (when toggling
line 3:   " off or disabling) we make them invisible by setting their foreground colours
line 4:   " to the background's.
line 5:   if g:gitgutter_signs
line 6:     sign define GitGutterLineAdded                 texthl=GitGutterAdd
line 7:     sign define GitGutterLineModified              texthl=GitGutterChange
line 8:     sign define GitGutterLineRemoved               texthl=GitGutterDelete
line 9:     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
line 10:     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
line 11:     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
line 12:   else
line 13:     sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
line 14:     sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
line 15:     sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
line 16:     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
line 17:     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
line 18:     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
line 19:   endif
function gitgutter#highlight#define_signs[10]..gitgutter#highlight#define_sign_text_highlights returning #0

continuing in function gitgutter#highlight#define_signs

line 11:   call s:define_sign_line_highlights()
calling function gitgutter#highlight#define_signs[11]..<SNR>48_define_sign_line_highlights()

line 1:   if g:gitgutter_highlight_lines
line 2:     sign define GitGutterLineAdded                 linehl=GitGutterAddLine
line 3:     sign define GitGutterLineModified              linehl=GitGutterChangeLine
line 4:     sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
line 5:     sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
line 6:     sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
line 7:     sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
line 8:   else
line 9:     sign define GitGutterLineAdded                 linehl=
line 10:     sign define GitGutterLineModified              linehl=
line 11:     sign define GitGutterLineRemoved               linehl=
line 12:     sign define GitGutterLineRemovedFirstLine      linehl=
line 13:     sign define GitGutterLineRemovedAboveAndBelow  linehl=
line 14:     sign define GitGutterLineModifiedRemoved       linehl=
line 15:   endif
function gitgutter#highlight#define_signs[11]..<SNR>48_define_sign_line_highlights returning #0

continuing in function gitgutter#highlight#define_signs

function gitgutter#highlight#define_signs returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 80: 
line 81: " Prevent infinite loop where:
line 82: " - executing a job in the foreground launches a new window which takes the focus;
line 83: " - when the job finishes, focus returns to gvim;
line 84: " - the FocusGained event triggers a new job (see below).
line 85: if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
calling function gitgutter#utility#windows()

line 1:   return has('win64') || has('win32') || has('win16')
function gitgutter#utility#windows returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 86:   set noshelltemp
line 87: endif
line 88: 
line 89: " }}}
line 90: 
line 91: " Primary functions {{{
line 92: 
line 93: command! -bar GitGutterAll call gitgutter#all(1)
line 94: command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
line 95: 
line 96: command! -bar GitGutterDisable call gitgutter#disable()
line 97: command! -bar GitGutterEnable  call gitgutter#enable()
line 98: command! -bar GitGutterToggle  call gitgutter#toggle()
line 99: 
line 100: command! -bar GitGutterBufferDisable call gitgutter#buffer_disable()
line 101: command! -bar GitGutterBufferEnable  call gitgutter#buffer_enable()
line 102: command! -bar GitGutterBufferToggle  call gitgutter#buffer_toggle()
line 103: 
line 104: " }}}
line 105: 
line 106: " Line highlights {{{
line 107: 
line 108: command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
line 109: command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
line 110: command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
line 111: 
line 112: " }}}
line 113: 
line 114: " Signs {{{
line 115: 
line 116: command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
line 117: command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
line 118: command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
line 119: 
line 120: " }}}
line 121: 
line 122: " Hunks {{{
line 123: 
line 124: command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
line 125: command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
line 126: 
line 127: command! -bar GitGutterStageHunk   call gitgutter#hunk#stage()
line 128: command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
line 129: command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
line 130: 
line 131: " Hunk text object
line 132: onoremap <silent> <Plug>GitGutterTextObjectInnerPending :<C-U>call gitgutter#hunk#text_object(1)<CR>
line 133: onoremap <silent> <Plug>GitGutterTextObjectOuterPending :<C-U>call gitgutter#hunk#text_object(0)<CR>
line 134: xnoremap <silent> <Plug>GitGutterTextObjectInnerVisual  :<C-U>call gitgutter#hunk#text_object(1)<CR>
line 135: xnoremap <silent> <Plug>GitGutterTextObjectOuterVisual  :<C-U>call gitgutter#hunk#text_object(0)<CR>
line 136: 
line 137: 
line 138: " Returns the git-diff hunks for the file or an empty list if there
line 139: " aren't any hunks.
line 140: "
line 141: " The return value is a list of lists.  There is one inner list per hunk.
line 142: "
line 143: "   [
line 144: "     [from_line, from_count, to_line, to_count],
line 145: "     [from_line, from_count, to_line, to_count],
line 146: "     ...
line 147: "   ]
line 148: "
line 149: " where:
line 150: "
line 151: " `from`  - refers to the staged file
line 152: " `to`    - refers to the working tree's file
line 153: " `line`  - refers to the line number where the change starts
line 154: " `count` - refers to the number of lines the change covers
line 155: function! GitGutterGetHunks()
line 159: 
line 160: " Returns an array that contains a summary of the hunk status for the current
line 161: " window.  The format is [ added, modified, removed ], where each value
line 162: " represents the number of lines added/modified/removed respectively.
line 163: function! GitGutterGetHunkSummary()
line 166: 
line 167: " }}}
line 168: 
line 169: command! -bar GitGutterDebug call gitgutter#debug#debug()
line 170: 
line 171: " Maps {{{
line 172: 
line 173: nnoremap <silent> <expr> <Plug>GitGutterNextHunk &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
line 174: nnoremap <silent> <expr> <Plug>GitGutterPrevHunk &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
line 175: 
line 176: nnoremap <silent> <Plug>GitGutterStageHunk   :GitGutterStageHunk<CR>
line 177: nnoremap <silent> <Plug>GitGutterUndoHunk    :GitGutterUndoHunk<CR>
line 178: nnoremap <silent> <Plug>GitGutterPreviewHunk :GitGutterPreviewHunk<CR>
line 179: 
line 180: " }}}
line 181: 
line 182: function! s:on_bufenter()
line 191: 
line 192: " Autocommands {{{
line 193: 
line 194: augroup gitgutter
line 195:   autocmd!
line 196: 
line 197:   autocmd TabEnter * let t:gitgutter_didtabenter = 1
line 198: 
line 199:   autocmd BufEnter * call s:on_bufenter()
line 200: 
line 201:   autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
line 202:   autocmd FileChangedShellPost   * call gitgutter#process_buffer(bufnr(''), 1)
line 203: 
line 204:   " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
line 205:   "
line 206:   "   vim -o file1 file2
line 207:   autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
line 208: 
line 209:   autocmd FocusGained,ShellCmdPost * call gitgutter#all(1)
line 210:   autocmd WinLeave * if bufname('') =~ '^term://' | call gitgutter#all(1) | endif
line 211: 
line 212:   if exists('##VimResume')
line 213:     autocmd VimResume * call gitgutter#all(1)
line 214:   endif
line 215: 
line 216:   autocmd ColorScheme * call gitgutter#highlight#define_sign_column_highlight() | call gitgutter#highlight#define_highlights()
line 217: 
line 218:   " Disable during :vimgrep
line 219:   autocmd QuickFixCmdPre  *vimgrep* let g:gitgutter_enabled = 0
line 220:   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = 1
line 221: augroup END
line 222: 
line 223: " }}}
line 224: 
line 225: " vim:set et sw=2 fdm=marker:
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
Searching for "/home/ringu/.vim/plugged/indentLine/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/asyncomplete.vim/plugin/asyncomplete.vim"
line 1: if exists('g:asyncomplete_loaded')
line 2:     finish
line 3: endif
line 4: let g:asyncomplete_loaded = 1
line 5: 
line 6: let s:has_lua = has('lua') || has('nvim-0.2.2')
line 7: 
line 8: if get(g:, 'asyncomplete_enable_for_all', 1)
line 9:     augroup asyncomplete_enable
line 10:         au!
line 11:         au BufEnter * if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif
line 12:     augroup END
line 13: endif
line 14: 
line 15: let g:asyncomplete_auto_popup = get(g:, 'asyncomplete_auto_popup', 1)
line 16: let g:asyncomplete_completion_delay = get(g:, 'asyncomplete_completion_delay', 100)
line 17: let g:asyncomplete_default_refresh_pattern = get(g:, 'asyncomplete_default_refresh_pattern', '\(\k\+$\|\.$\|>$\|:$\)')
line 18: let g:asyncomplete_log_file = get(g:, 'asyncomplete_log_file', '')
line 19: let g:asyncomplete_smart_completion = get(g:, 'asyncomplete_smart_completion', s:has_lua && exists('##TextChangedP'))
line 20: let g:asyncomplete_remove_duplicates = get(g:, 'asyncomplete_remove_duplicates', 0)
line 21: 
line 22: " Setting it to true may slow/hang vim especially on slow are sources such as asyncomplete-lsp.vim
line 23: " use asyncomplete_force_refersh to retrive the latest autocomplete results instead.
line 24: let g:asyncomplete_force_refresh_on_context_changed = get(g:, 'asyncomplete_force_refresh_on_context_changed', 0)
line 25: 
line 26: " imap <c-space> <Plug>(asyncomplete_force_refresh)
line 27: inoremap <silent> <expr> <Plug>(asyncomplete_force_refresh) asyncomplete#force_refresh()
finished sourcing /home/ringu/.vim/plugged/asyncomplete.vim/plugin/asyncomplete.vim
Searching for "/home/ringu/.vim/plugged/async.vim/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-lsp/plugin/lsp.vim"
line 1: if exists('g:lsp_loaded')
line 2:     finish
line 3: endif
line 4: let g:lsp_loaded = 1
line 5: 
line 6: let g:lsp_auto_enable = get(g:, 'lsp_auto_enable', 1)
line 7: let g:lsp_async_completion = get(g:, 'lsp_async_completion', 0)
line 8: let g:lsp_log_file = get(g:, 'lsp_log_file', '')
line 9: let g:lsp_log_verbose = get(g:, 'lsp_log_verbose', 1)
line 10: let g:lsp_debug_servers = get(g:, 'lsp_debug_servers', [])
line 11: let g:lsp_signs_enabled = get(g:, 'lsp_signs_enabled', 0)
line 12: let g:lsp_signs_error = get(g:, 'lsp_signs_error', {})
line 13: let g:lsp_signs_warning = get(g:, 'lsp_signs_warning', {})
line 14: let g:lsp_signs_information = get(g:, 'lsp_signs_information', {})
line 15: let g:lsp_signs_hint = get(g:, 'lsp_signs_hint', {})
line 16: let g:lsp_diagnostics_enabled = get(g:, 'lsp_diagnostics_enabled', 1)
line 17: let g:lsp_diagnostics_echo_cursor = get(g:, 'lsp_diagnostics_echo_cursor', 0)
line 18: let g:lsp_diagnostics_echo_delay = get(g:, 'lsp_diagnostics_echo_delay', 500)
line 19: let g:lsp_next_sign_id = get(g:, 'lsp_next_sign_id', 6999)
line 20: let g:lsp_preview_keep_focus = get(g:, 'lsp_preview_keep_focus', 1)
line 21: 
line 22: if g:lsp_auto_enable
line 23:     augroup lsp_auto_enable
line 24:         autocmd!
line 25:         autocmd VimEnter * call lsp#enable()
line 26:     augroup END
line 27: endif
line 28: 
line 29: command! LspCodeAction call lsp#ui#vim#code_action()
line 30: command! LspDefinition call lsp#ui#vim#definition()
line 31: command! LspDocumentSymbol call lsp#ui#vim#document_symbol()
line 32: command! LspDocumentDiagnostics call lsp#ui#vim#diagnostics#document_diagnostics()
line 33: command! -nargs=? -complete=customlist,lsp#utils#empty_complete LspHover call lsp#ui#vim#hover#get_hover_under_cursor()
line 34: command! LspNextError call lsp#ui#vim#signs#next_error()
line 35: command! LspPreviousError call lsp#ui#vim#signs#previous_error()
line 36: command! LspReferences call lsp#ui#vim#references()
line 37: command! LspRename call lsp#ui#vim#rename()
line 38: command! LspWorkspaceSymbol call lsp#ui#vim#workspace_symbol()
line 39: command! LspDocumentFormat call lsp#ui#vim#document_format()
line 40: command! LspDocumentFormatSync call lsp#ui#vim#document_format_sync()
line 41: command! -range LspDocumentRangeFormat call lsp#ui#vim#document_range_format()
line 42: command! LspImplementation call lsp#ui#vim#implementation()
line 43: command! LspTypeDefinition call lsp#ui#vim#type_definition()
line 44: command! -nargs=0 LspStatus echo lsp#get_server_status()
line 45: 
line 46: nnoremap <expr> <plug>(lsp-code-action) [lsp#ui#vim#code_action(),''][1]
line 47: nnoremap <expr> <plug>(lsp-definition) [lsp#ui#vim#definition(), ''][1]
line 48: nnoremap <expr> <plug>(lsp-document-symbol) [lsp#ui#vim#document_symbol(),''][1]
line 49: nnoremap <expr> <plug>(lsp-document-diagnostics) [lsp#ui#vim#diagnostics#document_diagnostics(),''][1]
line 50: nnoremap <expr> <plug>(lsp-hover) [lsp#ui#vim#hover#get_hover_under_cursor(),''][1]
line 51: nnoremap <expr> <plug>(lsp-next-error) [lsp#ui#vim#signs#next_error(),''][1]
line 52: nnoremap <expr> <plug>(lsp-previous-error) [lsp#ui#vim#signs#previous_error(),''][1]
line 53: nnoremap <expr> <plug>(lsp-references) [lsp#ui#vim#references(),''][1]
line 54: nnoremap <expr> <plug>(lsp-rename) [lsp#ui#vim#rename(),''][1]
line 55: nnoremap <expr> <plug>(lsp-workspace-symbol) [lsp#ui#vim#workspace_symbol(),''][1]
line 56: nnoremap <expr> <plug>(lsp-document-format) [lsp#ui#vim#document_format(),''][1]
line 57: vnoremap <expr> <plug>(lsp-document-format) [lsp#ui#vim#document_range_format(),''][1]
line 58: nnoremap <expr> <plug>(lsp-implementation) [lsp#ui#vim#implementation(),''][1]
line 59: nnoremap <expr> <plug>(lsp-type-definition) [lsp#ui#vim#type_definition(),''][1]
line 60: nnoremap <expr> <plug>(lsp-status) [execute("echo lsp#get_server_status()",1),''][1]
finished sourcing /home/ringu/.vim/plugged/vim-lsp/plugin/lsp.vim
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/asyncomplete-lsp.vim"
line 1: if exists('g:asyncomplete_lsp_loaded')
line 2:     finish
line 3: endif
line 4: let g:asyncomplete_lsp_loaded = 1
line 5: 
line 6: let s:servers = {} " { server_name: 1 }
line 7: 
line 8: au User lsp_server_init call s:server_initialized()
line 9: au User lsp_server_exit call s:server_exited()
line 10: 
line 11: function! s:server_initialized() abort
line 42: 
line 43: function! s:server_exited() abort
line 55: 
line 56: function! s:generate_asyncomplete_name(server_name) abort
line 59: 
line 60: function! s:completor(server_name, opt, ctx) abort
line 70: 
line 71: function! s:handle_completion(server_name, opt, ctx, data) abort
finished sourcing /home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/asyncomplete-lsp.vim
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
chdir(/usr/share/vim/vimfiles/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vimfiles/plugin/fzf.vim"
line 1: " Copyright (c) 2017 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf')
line 25:   finish
line 26: endif
line 27: let g:loaded_fzf = 1
line 28: 
line 29: let s:is_win = has('win32') || has('win64')
line 30: if s:is_win && &shellslash
line 31:   set noshellslash
line 32:   let s:base_dir = expand('<sfile>:h:h')
line 33:   set shellslash
line 34: else
line 35:   let s:base_dir = expand('<sfile>:h:h')
line 36: endif
line 37: if s:is_win
line 38:   let s:term_marker = '&::FZF'
line 39: 
line 40:   function! s:fzf_call(fn, ...)
line 49: 
line 50:   " Use utf-8 for fzf.vim commands
line 51:   " Return array of shell commands for cmd.exe
line 52:   function! s:wrap_cmds(cmds)
line 57: else
line 58:   let s:term_marker = ";#FZF"
line 59: 
line 60:   function! s:fzf_call(fn, ...)
line 63: 
line 64:   function! s:wrap_cmds(cmds)
line 67: endif
line 68: 
line 69: function! s:shellesc_cmd(arg)
line 76: 
line 77: function! fzf#shellescape(arg, ...)
line 84: 
line 85: function! s:fzf_getcwd()
line 88: 
line 89: function! s:fzf_fnamemodify(fname, mods)
line 92: 
line 93: function! s:fzf_expand(fmt)
line 96: 
line 97: function! s:fzf_tempname()
line 100: 
line 101: let s:default_layout = { 'down': '~40%' }
line 102: let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
line 103: let s:fzf_go = s:base_dir.'/bin/fzf'
line 104: let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
line 105: let s:install = s:base_dir.'/install'
line 106: let s:installed = 0
line 107: 
line 108: let s:cpo_save = &cpo
line 109: set cpo&vim
line 110: 
line 111: function! s:fzf_exec()
line 137: 
line 138: function! s:tmux_enabled()
line 154: 
line 155: function! s:escape(path)
line 159: 
line 160: " Upgrade legacy options
line 161: function! s:upgrade(dict)
line 174: 
line 175: function! s:error(msg)
line 180: 
line 181: function! s:warn(msg)
line 186: 
line 187: function! s:has_any(dict, keys)
line 195: 
line 196: function! s:open(cmd, target)
line 202: 
line 203: function! s:common_sink(action, lines) abort
line 240: 
line 241: function! s:get_color(attr, ...)
line 253: 
line 254: function! s:defaults()
line 259: 
line 260: function! s:validate_layout(layout)
line 269: 
line 270: function! s:evaluate_opts(options)
line 274: 
line 275: " [name string,] [opts dict,] [fullscreen boolean]
line 276: function! fzf#wrap(...)
line 335: 
line 336: function! s:use_sh()
line 346: 
line 347: function! fzf#run(...) abort
line 422: 
line 423: function! s:present(dict, ...)
line 431: 
line 432: function! s:fzf_tmux(dict)
line 449: 
line 450: function! s:splittable(dict)
line 454: 
line 455: function! s:pushd(dict)
line 470: 
line 471: augroup fzf_popd
line 472:   autocmd!
line 473:   autocmd WinEnter * call s:dopopd()
line 474: augroup END
line 475: 
line 476: function! s:dopopd()
line 501: 
line 502: function! s:xterm_launcher()
line 511: unlet! s:launcher
line 512: if s:is_win || has('win32unix')
line 513:   let s:launcher = '%s'
line 514: else
line 515:   let s:launcher = function('s:xterm_launcher')
line 516: endif
line 517: 
line 518: function! s:exit_handler(code, command, ...)
line 530: 
line 531: function! s:execute(dict, command, use_height, temps) abort
line 581: 
line 582: function! s:execute_tmux(dict, command, temps) abort
line 595: 
line 596: function! s:calc_size(max, val, dict)
line 614: 
line 615: function! s:getpos()
line 618: 
line 619: function! s:split(dict)
line 652: 
line 653: function! s:execute_term(dict, command, temps) abort
line 733: 
line 734: function! s:collect(temps) abort
line 743: 
line 744: function! s:callback(dict, lines) abort
line 775: 
line 779: let s:default_action = { 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }
line 780: 
line 781: function! s:shortpath()
line 789: 
line 790: function! s:cmd(bang, ...) abort
line 807: 
line 808: command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
line 809: 
line 810: let &cpo = s:cpo_save
line 811: unlet s:cpo_save
finished sourcing /usr/share/vim/vimfiles/plugin/fzf.vim
Searching for "/usr/share/vim/vim81/plugin/**/*.vim"
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim81/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 52: augroup END
finished sourcing /usr/share/vim/vim81/plugin/gzip.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/logiPat.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2018 Feb 04
line 4: 
line 5: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
line 6: 
line 7: function! s:ManPager()
finished sourcing /usr/share/vim/vim81/plugin/manpager.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2018 Jul 3
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 197: 
line 198: " Define commands that will disable and enable the plugin.
line 199: command! DoMatchParen call s:DoMatchParen()
line 200: command! NoMatchParen call s:NoMatchParen()
line 201: 
line 202: func! s:NoMatchParen()
line 209: 
line 210: func! s:DoMatchParen()
line 216: 
line 217: let &cpo = s:cpo_save
line 218: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/plugin/matchparen.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v156"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try                                                       
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
line 86:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 152: "             them, which checks if they're directories and will create a directory
line 153: "             listing when appropriate.
line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 155: "             has already been called.
line 156: fun! s:VimEnter(dirname)
line 164: 
line 165: " ---------------------------------------------------------------------
line 166: " NetrwStatusLine: {{{1
line 167: fun! NetrwStatusLine()
line 178: 
line 179: " ------------------------------------------------------------------------
line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 184: fun! NetUserPass(...)
line 208: 
line 209: " ------------------------------------------------------------------------
line 210: " Modelines And Restoration: {{{1
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /usr/share/vim/vim81/plugin/rrhelper.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim81/plugin/spellfile.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47: augroup END
line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 49: 
line 50: " ---------------------------------------------------------------------
line 51: " Restoration And Modelines: {{{1
line 52: " vim: fdm=marker
line 53: let &cpo= s:keepcpo
line 54: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2018 Nov 11
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim8.1_v1'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   8.1_v1  (this version): Fix Bitbucket issue #6: Don't generate empty script
line 16: "                           tag.
line 17: "                           Fix Bitbucket issue #5: javascript should
line 18: "                           declare variables with "var".
line 19: "                           Fix Bitbucket issue #13: errors thrown sourcing
line 20: "                           2html.vim directly when plugins not loaded.
line 21: "                           Fix Bitbucket issue #16: support 'vartabstop'.
line 22: "
line 23: "   7.4 updates: {{{
line 24: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 25: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 26: "                           take a list so it is easier to specfiy fallback
line 27: "                           fonts in the generated CSS.
line 28: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 29: "^I^I^I    also for version-specific modelines like "vim>703:".
line 30: "}}}
line 31: "
line 32: "   7.3 updates: {{{
line 33: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 34: "^I^I^I    g:html_line_ids=0. Allow customizing
line 35: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 36: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 37: "^I^I^I    is started.
line 38: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 39: "^I^I^I    insert modeline to set it to manual.
line 40: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 41: "^I^I^I    duplicate of one buffer instead of including both.
line 42: "^I^I^I    Add anchors to each line so you can put '#L123'
line 43: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 44: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 45: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 46: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 47: "^I^I^I    Allow TOhtml to chain together with other commands
line 48: "^I^I^I    using |.
line 49: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 50: "^I^I^I    highlight groups make up the start-of-modeline text.
line 51: "^I^I^I    Improve render time of page with uncopyable regions
line 52: "^I^I^I    by not using one-input-per-char. Change name of
line 53: "^I^I^I    uncopyable option from html_unselectable to
line 54: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 55: "^I^I^I    default to inserting invalid markup for uncopyable
line 56: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 57: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 58: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 59: "^I^I^I    eliminate post-processing substitute commands in
line 60: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 61: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 62: "^I^I^I    speed improvements. Fix modeline mangling in
line 63: "^I^I^I    generated output so it works for text in the first
line 64: "^I^I^I    column. Fix missing line number and fold column in
line 65: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 66: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 67: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 68: "^I^I^I    the new default foldtext added in v11, as the patch
line 69: "^I^I^I    adding it has not yet been included in Vim.
line 70: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 71: "^I^I^I    Brabandt in
line 72: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 73: "^I^I^I    This patch has not yet been included in Vim, thus
line 74: "^I^I^I    these changes are removed in the next version.
line 75: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 76: "^I^I^I    multiple nested folds with dynamic folding on.
line 77: "^I^I^I    Also fix problem with foldtext in this situation.
line 78: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 79: "^I^I^I    and without html_no_pre, default value same as
line 80: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 81: "^I^I^I    'fileencoding' for converted document encoding if
line 82: "^I^I^I    'buftype' indicates a special buffer which isn't
line 83: "^I^I^I    written.
line 84: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 85: "^I^I^I    characters in generated output (Andy Spencer).
line 86: "^I^I^I    Escape text that looks like a modeline so Vim
line 87: "^I^I^I    doesn't use anything in the converted HTML as a
line 88: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 89: "^I^I^I    before the conversion range. Remove fold column when
line 90: "^I^I^I    there are no folds.
line 91: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 92: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 93: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 94: "^I^I^I    supported by all major browsers according to
line 95: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 96: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 97: "^I^I^I    HTML encoding to Vim encoding detection be
line 98: "^I^I^I    case-insensitive for built-in pairs.
line 99: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 100: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 101: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 102: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 103: "^I^I^I    file matches its indicated charset. Add charsets for
line 104: "^I^I^I    all of Vim's natively supported encodings.
line 105: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 106: "^I^I^I    user settings interfering with diff mode generation,
line 107: "^I^I^I    trailing whitespace (e.g. line number column) when
line 108: "^I^I^I    using html_no_pre, and bugs when using
line 109: "^I^I^I    html_hover_unfold.
line 110: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 111: "^I^I^I    folds in diff mode when first line was folded.
line 112: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 113: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 114: "^I^I^I    default to true when not set to anything. Use strict
line 115: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 116: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 117: "^I^I^I    when using this option. Add meta tag for settings.
line 118: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 119: "^I^I^I    diff colors and the normal syntax colors
line 120: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 121: "}}}
line 122: "}}}
line 123: 
line 124: " TODO: {{{
line 125: "   * Check the issue tracker:
line 126: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
line 127: "   * Options for generating the CSS in external style sheets. New :TOcss
line 128: "     command to convert the current color scheme into a (mostly) generic CSS
line 129: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 130: "     by Erik Falor
line 131: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 132: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 133: "     term) to use for the styling. Suggestion by "nacitar".
line 134: "   * Add way to override or specify which RGB colors map to the color numbers
line 135: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 136: "   * Disable filetype detection until after all processing is done.
line 137: "   * Add option for not generating the hyperlink on stuff that looks like a
line 138: "     URL? Or just color the link to fit with the colorscheme (and only special
line 139: "     when hovering)?
line 140: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 141: "     regions is turned on. Possible solution: Add normal text line numbers with
line 142: "     display:none, set to display:inline for print style sheets, and hide
line 143: "     <input> elements for print, to allow Opera printing multiple pages (and
line 144: "     other uncopyable areas?). May need to make the new text invisible to IE
line 145: "     with conditional comments to prevent copying it, IE for some reason likes
line 146: "     to copy hidden text. Other browsers too?
line 147: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 148: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 149: "     on Windows). Perhaps it is font related?
line 150: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 151: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 152: "     on diff lines though.
line 153: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 154: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 155: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 156: "     accepted to modify it.
line 157: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 158: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 159: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 160: "     does not show the whole diff filler as it is supposed to?
line 161: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 162: "     invalid content. Can/should anything be done about this? Maybe a separate
line 163: "     plugin to correct 'isprint' based on encoding?
line 164: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 165: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 166: "   * Font auto-detection similar to
line 167: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 168: "     platforms.
line 169: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 170: "^I- listchars support
line 171: "^I- full-line background highlight
line 172: "^I- other?
line 173: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 174: "     free with full-line background highlight above).
line 175: "   * Restore open/closed folds and cursor position after processing each file
line 176: "     with option not to restore for speed increase.
line 177: "   * Add extra meta info (generation time, etc.)?
line 178: "   * Tidy up so we can use strict doctype in even more situations
line 179: "   * Implementation detail: add threshold for writing the lines to the html
line 180: "     buffer before we're done (5000 or so lines should do it)
line 181: "   * TODO comments for code cleanup scattered throughout
line 182: "}}}
line 183: 
line 184: " Define the :TOhtml command when:
line 185: " - 'compatible' is not set
line 186: " - this plugin or user override was not already loaded
line 187: " - user commands are available. {{{
line 188: if !&cp && !exists(":TOhtml") && has("user_commands")
line 189:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 190: endif "}}}
line 191: 
line 192: " Make sure any patches will probably use consistent indent
line 193: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/tohtml.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37: augroup END
line 38: 
line 39: " =====================================================================
line 40: " Restoration And Modelines: {{{1
line 41: " vim: fdm=marker
line 42: let &cpo= s:keepcpo
line 43: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^ISep 13, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v28"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/ringu/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/indentLine/after/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/indentLine/after/plugin/indentLine.vim"
line 1: " Script Name: indentLine.vim
line 2: " Author:      Yggdroot <archofortune@gmail.com>
line 3: "
line 4: " Description: To show the indention levels with thin vertical lines
line 5: 
line 6: scriptencoding utf-8
line 7: 
line 8: if !has("conceal") || exists("g:indentLine_loaded")
line 9:     finish
line 10: endif
line 11: let g:indentLine_loaded = 1
line 12: 
line 13: let g:indentLine_newVersion = get(g:,'indentLine_newVersion',v:version > 704 || v:version == 704 && has("patch792"))
line 14: 
line 15: let g:indentLine_char = get(g:, 'indentLine_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '|'))
line 16: let g:indentLine_first_char = get(g:, 'indentLine_first_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '|'))
line 17: let g:indentLine_indentLevel = get(g:, 'indentLine_indentLevel', 20)
line 18: let g:indentLine_enabled = get(g:, 'indentLine_enabled', 1)
line 19: let g:indentLine_fileType = get(g:, 'indentLine_fileType', [])
line 20: let g:indentLine_fileTypeExclude = get(g:, 'indentLine_fileTypeExclude', [])
line 21: let g:indentLine_bufNameExclude = get(g:, 'indentLine_bufNameExclude', [])
line 22: let g:indentLine_bufTypeExclude = get(g:, 'indentLine_bufTypeExclude', [])
line 23: let g:indentLine_showFirstIndentLevel = get(g:, 'indentLine_showFirstIndentLevel', 0)
line 24: let g:indentLine_maxLines = get(g:, 'indentLine_maxLines', 3000)
line 25: let g:indentLine_setColors = get(g:, 'indentLine_setColors', 1)
line 26: let g:indentLine_setConceal = get(g:, 'indentLine_setConceal', 1)
line 27: let g:indentLine_defaultGroup = get(g:, 'indentLine_defaultGroup', "")
line 28: let g:indentLine_faster = get(g:, 'indentLine_faster', 0)
line 29: let g:indentLine_leadingSpaceChar = get(g:, 'indentLine_leadingSpaceChar', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '.'))
line 30: let g:indentLine_leadingSpaceEnabled = get(g:, 'indentLine_leadingSpaceEnabled', 0)
line 31: let g:indentLine_mysyntaxfile = fnamemodify(expand("<sfile>"), ":p:h:h")."/syntax/indentLine.vim"
line 32: 
line 33: "{{{1 function! s:InitColor()
line 34: function! s:InitColor()
line 93: 
line 94: "{{{1 function! s:SetConcealOption()
line 95: function! s:SetConcealOption()
line 107: 
line 108: function! s:ResetConcealOption()
line 119: 
line 120: "{{{1 function! s:IndentLinesEnable()
line 121: function! s:IndentLinesEnable()
line 176: 
line 177: "{{{1 function! s:IndentLinesDisable()
line 178: function! s:IndentLinesDisable()
line 201: 
line 202: "{{{1 function! s:IndentLinesToggle()
line 203: function! s:IndentLinesToggle()
line 222: 
line 223: "{{{1 function! s:ResetWidth(...)
line 224: function! s:ResetWidth(...)
line 233: 
line 234: "{{{1 function! s:Filter()
line 235: function! s:Filter()
line 256: 
line 257: "{{{1 function! s:Disable()
line 258: function! s:Disable()
line 268: 
line 269: "{{{1 function! s:Setup()
line 270: function! s:Setup()
line 283: 
line 284: "{{{1 function! s:LeadingSpaceEnable()
line 285: function! s:LeadingSpaceEnable()
line 319: 
line 320: "{{{1 function! s:LeadingSpaceDisable()
line 321: function! s:LeadingSpaceDisable()
line 342: 
line 343: "{{{1 function! s:LeadingSpaceToggle()
line 344: function! s:LeadingSpaceToggle()
line 363: 
line 364: "{{{1 augroup indentLine
line 365: augroup indentLine
line 366:     autocmd!
line 367:     if g:indentLine_newVersion
line 368:         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
line 369:         if exists("##WinNew")
line 370:             autocmd WinNew * call <SID>Setup()
line 371:         endif
line 372:         autocmd BufWinEnter * call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()
line 373:         autocmd FileType * call <SID>Disable()
line 374:     else
line 375:         autocmd BufWinEnter * call <SID>Setup()
line 377:         autocmd User * if exists("b:indentLine_enabled") || exists("b:indentLine_leadingSpaceEnabled") | call <SID>Setup() | endif
line 378:         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
line 379:         autocmd BufUnload * let b:indentLine_enabled = 0 | let b:indentLine_leadingSpaceEnabled = 0
line 380:         autocmd SourcePre $VIMRUNTIME/syntax/nosyntax.vim doautocmd indentLine BufUnload
line 381:         autocmd FileChangedShellPost * doautocmd indentLine BufUnload | call <SID>Setup()
line 382:     endif
line 383: augroup END
line 384: 
line 385: "{{{1 commands
line 386: command! -nargs=? IndentLinesReset call <SID>ResetWidth(<f-args>)
line 387: command! IndentLinesToggle call <SID>IndentLinesToggle()
line 388: if g:indentLine_newVersion
line 389:     command! IndentLinesEnable let b:indentLine_enabled = 1 | call <SID>IndentLinesEnable()
line 390:     command! IndentLinesDisable let b:indentLine_enabled = 0 | call <SID>IndentLinesDisable()
line 391:     command! LeadingSpaceEnable let b:indentLine_leadingSpaceEnabled = 1 | call <SID>LeadingSpaceEnable()
line 392:     command! LeadingSpaceDisable let b:indentLine_leadingSpaceEnabled = 0 | call <SID>LeadingSpaceDisable()
line 393: else
line 394:     command! IndentLinesEnable call <SID>IndentLinesEnable()
line 395:     command! IndentLinesDisable call <SID>IndentLinesDisable()
line 396:     command! LeadingSpaceEnable call <SID>LeadingSpaceEnable()
line 397:     command! LeadingSpaceDisable call <SID>LeadingSpaceDisable()
line 398: endif
line 399: command! LeadingSpaceToggle call <SID>LeadingSpaceToggle()
line 400: 
line 401: " vim:et:ts=4:sw=4:fdm=marker:fmr={{{,}}}
line 402: 
finished sourcing /home/ringu/.vim/plugged/indentLine/after/plugin/indentLine.vim
Searching for "/home/ringu/.vim/after/plugin/**/*.vim"
Opening the X display took 0 msec
Reading viminfo file "/home/ringu/.viminfo" info oldfiles
Opening the X display took 0 msec
Executing BufWinEnter Autocommands for "*"
autocommand call lightline#update()

line 0: call lightline#update()
Searching for "autoload/lightline.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/11/24 12:00:00.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: let s:_ = 1 " 1: uninitialized, 2: disabled
line 12: 
line 13: function! lightline#update() abort
line 29: 
line 30: function! lightline#update_once() abort
line 35: 
line 36: function! lightline#update_disable() abort
line 42: 
line 43: function! lightline#enable() abort
line 59: 
line 60: function! lightline#disable() abort
line 77: 
line 78: function! lightline#toggle() abort
line 85: 
line 145: let s:_lightline = {   'active': {     'left': [['mode', 'paste'], ['readonly', 'filename', 'modified']],     'right': [['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']]   },   'inactive': {     'left': [['filename']],     'right': [['lineinfo'], ['percent']]   },   'tabline': {     'left': [['tabs']],     'right': [['close']]   },   'tab': {     'active': ['tabnum', 'filename', 'modified'],     'inactive': ['tabnum', 'filename', 'modified']   },   'component': {     'mode': '%{lightline#mode()}',     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X ', 'winnr': '%{winnr()}'   
line 146: function! lightline#init() abort
line 187: 
line 188: function! lightline#colorscheme() abort
line 211: 
line 212: function! lightline#palette() abort
line 215: 
line 216: function! lightline#mode() abort
line 219: 
line 220: let s:mode = ''
line 221: function! lightline#link(...) abort
line 246: 
line 247: function! s:term(p) abort
line 250: 
line 251: if exists('*uniq')
line 252:   let s:uniq = function('uniq')
line 253: else
line 254:   function! s:uniq(xs) abort
line 264: endif
line 265: 
line 266: function! lightline#highlight(...) abort
line 297: 
line 298: function! s:subseparator(components, subseparator, expanded) abort
line 305: 
line 306: function! lightline#concatenate(xs, right) abort
line 310: 
line 311: function! lightline#statusline(inactive) abort
line 317: 
line 318: function! s:normalize(result) abort
line 327: 
line 328: function! s:evaluate_expand(component) abort
line 339: 
line 340: function! s:convert(name, index) abort
line 350: 
line 351: function! s:flatten_twice(xss) abort
line 360: 
line 361: if v:version > 702 || v:version == 702 && has('patch295')
line 362:   let s:map = function('map')
line 363: else
line 364:   function! s:map(xs, f) abort
line 371: endif
line 372: 
line 373: function! s:expand(components) abort
line 404: 
line 405: function! s:line(tabline, inactive) abort
line 445: 
line 446: let s:tabnr = -1
line 447: let s:tabcnt = -1
line 448: let s:tabline = ''
line 449: function! lightline#tabline() abort
line 460: 
line 461: function! lightline#tabs() abort
line 482: 
line 483: function! lightline#onetab(n, active) abort
line 494: 
line 495: function! lightline#error(msg) abort
line 500: 
line 501: let &cpo = s:save_cpo
line 502: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim
continuing in BufWinEnter Autocommands for "*"
calling function lightline#update()

line 1:   if s:_
line 2:     if s:_ == 2 | return | endif
line 2:  return | endif
line 2:  endif
line 3:     call lightline#init()
calling function lightline#update[3]..lightline#init()

line 1:   let s:lightline = deepcopy(get(g:, 'lightline', {}))
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 13:   call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
line 14:   call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
line 15:   let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
line 16:   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
line 17:     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
line 18:       let s:lightline.tabline_configured = 1
line 19:       break
line 20:     endif
line 21:   endfor
line 22:   if !exists('s:_statusline')
line 23:     let s:_statusline = &statusline
line 24:   endif
line 25:   if !exists('s:_tabline')
line 26:     let s:_tabline = &tabline
line 27:   endif
line 28:   if s:lightline.enable.tabline
line 29:     set tabline=%!lightline#tabline()
line 30:   else
line 31:     let &tabline = get(s:, '_tabline', '')
line 32:   endif
line 33:   for f in values(s:lightline.component_function)
line 34:     silent! call call(f, [])
calling function lightline#update[3]..lightline#init[34]..fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
function lightline#update[3]..lightline#init[34]..fugitive#head returning ''

continuing in function lightline#update[3]..lightline#init

line 35:   endfor
line 33:   for f in values(s:lightline.component_function)
line 34:     silent! call call(f, [])
line 35:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
Searching for "autoload/lightline/tab.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/tab.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 37: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/tab.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2016/05/07 22:31:02.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: function! lightline#tab#filename(n) abort
line 17: 
line 18: function! lightline#tab#modified(n) abort
line 22: 
line 23: function! lightline#tab#readonly(n) abort
line 27: 
line 28: function! lightline#tab#tabnum(n) abort
line 31: 
line 32: let &cpo = s:save_cpo
line 33: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim
continuing in function lightline#update[3]..lightline#init
calling function lightline#update[3]..lightline#init[37]..lightline#tab#tabnum(1)

line 1:   return a:n
function lightline#update[3]..lightline#init[37]..lightline#tab#tabnum returning #1

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#filename(1)

line 1:   let buflist = tabpagebuflist(a:n)
line 2:   let winnr = tabpagewinnr(a:n)
line 3:   let _ = expand('#'.buflist[winnr - 1].':t')
line 4:   return _ !=# '' ? _ : '[No Name]'
function lightline#update[3]..lightline#init[37]..lightline#tab#filename returning '[No Name]'

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#readonly(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
function lightline#update[3]..lightline#init[37]..lightline#tab#readonly returning ''

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#modified(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
function lightline#update[3]..lightline#init[37]..lightline#tab#modified returning ''

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
line 38:   endfor
line 39:   let s:mode = ''
function lightline#update[3]..lightline#init returning #0

continuing in function lightline#update

line 4:     call lightline#colorscheme()
calling function lightline#update[4]..lightline#colorscheme()

line 1:   try
line 2:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
Searching for "autoload/lightline/colorscheme/one.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/colorscheme/one.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme/one.vim
line 3: " Author: Zoltan Dalmadi
line 4: " License: MIT License
line 5: " Last Change: 2017/11/28 21:53:01.
line 6: " =============================================================================
line 7: 
line 8: " Common colors
line 9: let s:fg     = [ '#abb2bf', 145 ]
line 10: let s:blue   = [ '#61afef', 75 ]
line 11: let s:green  = [ '#98c379', 76 ]
line 12: let s:purple = [ '#c678dd', 176 ]
line 13: let s:red1   = [ '#e06c75', 168 ]
line 14: let s:red2   = [ '#be5046', 168 ]
line 15: let s:yellow = [ '#e5c07b', 180 ]
line 16: 
line 17: let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
line 18: 
line 19: if lightline#colorscheme#background() ==# 'light'
Searching for "autoload/lightline/colorscheme.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/colorscheme.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 19: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/09/01 22:48:24.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 59: let s:cuicolor = { 'black'          : 16, 'white'          : 231, 'darkestgreen'   : 22, 'darkgreen'      : 28, 'mediumgreen'    : 70, 'brightgreen'    : 148, 'darkestcyan'    : 23, 'mediumcyan'     : 117, 'darkestblue'    : 24, 'darkblue'       : 31, 'darkestred'     : 52, 'darkred'        : 88, 'mediumred'      : 124, 'brightred'      : 160, 'brightestred'   : 196, 'darkestpurple'  : 55, 'mediumpurple'   : 98, 'brightpurple'   : 189, 'brightorange'   : 208, 'brightestorange': 214, 'gray0'          : 233, 'gray1'          : 235, 'gray2'          : 236, 'gray3'          : 239, 'gray4'          : 240, 'gray5'          : 241, 'gray6'          : 244, 'gray7'          : 245, 'gray8'          : 247, 'gray9'          : 250, 'gray10'         : 252, 'yellow'         : 136, 'orange'         : 166, 'red'            : 160, 'magenta'        : 125, 'violet'         : 61, 'blue'           : 33, 'cyan'           : 37, 'green'          : 64, }
line 60: 
line 109: let s:guicolor = { 'black'          : '#000000', 'white'          : '#ffffff', 'darkestgreen'   : '#005f00', 'darkgreen'      : '#008700', 'mediumgreen'    : '#5faf00', 'brightgreen'    : '#afdf00', 'darkestcyan'    : '#005f5f', 'mediumcyan'     : '#87dfff', 'darkestblue'    : '#005f87', 'darkblue'       : '#0087af', 'darkestred'     : '#5f0000', 'darkred'        : '#870000', 'mediumred'      : '#af0000', 'brightred'      : '#df0000', 'brightestred'   : '#ff0000', 'darkestpurple'  : '#5f00af', 'mediumpurple'   : '#875fdf', 'brightpurple'   : '#dfdfff', 'brightorange'   : '#ff8700', 'brightestorange': '#ffaf00', 'gray0'          : '#121212', 'gray1'          : '#262626', 'gray2'          : '#303030', 'gray3'          : '#4e4e4e', 'gray4'          : '#585858', 'gray5'          : '#606060', 'gray6'          : '#808080', 'gray7'          : '#8a8a8a', 'gray8'          : '#9e9e9e', 'gray9'          : '#bcbcbc', 'gray10'         : '#d0d0d0', 'yellow'         : '#b58900', 'orange'         : '#cb4b16', 'red'
line 110: 
line 111: function! s:convert(rgb) abort
line 128: 
line 129: function! s:black(x) abort
line 141: 
line 142: function! s:nr(x) abort
line 145: 
line 146: function! s:rgb(r, g, b) abort
line 149: 
line 150: function! s:upconvert(nr) abort
line 182: 
line 183: function! lightline#colorscheme#fill(p) abort
line 208: 
line 209: function! lightline#colorscheme#flatten(p) abort
line 226: 
line 227: if has('gui_running') || (has('termguicolors') && &termguicolors)
line 228:   function! lightline#colorscheme#background() abort
line 231: else
line 232:   " &background is set inappropriately when the colorscheme sets ctermbg of the Normal group
line 233:   function! lightline#colorscheme#background() abort
line 254: endif
line 255: 
line 256: let &cpo = s:save_cpo
line 257: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim
continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim
calling function lightline#colorscheme#background()

line 1:     let bg_color = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
line 2:     if bg_color !=# ''
line 3:       if bg_color < 16
line 4:         return &background
line 5:       elseif 232 <= bg_color && bg_color < 244
line 6:         return 'dark'
function lightline#colorscheme#background returning 'dark'

continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim

line 20:   " Light variant
line 21:   let s:bg     = [ '#fafafa', 255 ]
line 22:   let s:gray1  = [ '#494b53', 238 ]
line 23:   let s:gray2  = [ '#f0f0f0', 255 ]
line 24:   let s:gray3  = [ '#d0d0d0', 250 ]
line 25:   let s:green  = [ '#98c379', 35 ]
line 26: 
line 27:   let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:gray1, s:gray3 ] ]
line 28:   let s:p.normal.middle   = [ [ s:gray1, s:gray2 ] ]
line 29:   let s:p.inactive.left   = [ [ s:bg,  s:gray3 ], [ s:bg, s:gray3 ] ]
line 30:   let s:p.inactive.middle = [ [ s:gray3, s:gray2 ] ]
line 31:   let s:p.inactive.right  = [ [ s:bg, s:gray3 ], [ s:bg, s:gray3 ] ]
line 32:   let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:gray1, s:gray3 ] ]
line 33:   let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:gray1, s:gray3 ] ]
line 34:   let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:gray1, s:gray3 ] ]
line 35: else
line 36:   " Dark variant
line 37:   let s:bg     = [ '#282c34', 235 ]
line 38:   let s:gray1  = [ '#5c6370', 241 ]
line 39:   let s:gray2  = [ '#2c323d', 235 ]
line 40:   let s:gray3  = [ '#3e4452', 240 ]
line 41: 
line 42:   let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
line 43:   let s:p.normal.middle   = [ [ s:fg, s:gray2 ] ]
line 44:   let s:p.inactive.left   = [ [ s:gray1,  s:bg ], [ s:gray1, s:bg ] ]
line 45:   let s:p.inactive.middle = [ [ s:gray1, s:gray2 ] ]
line 46:   let s:p.inactive.right  = [ [ s:gray1, s:bg ], [ s:gray1, s:bg ] ]
line 47:   let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
line 48:   let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
line 49:   let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
line 50: endif
line 51: 
line 52: " Common
line 53: let s:p.normal.right   = [ [ s:bg, s:green, 'bold' ], [ s:bg, s:green, 'bold' ] ]
line 54: let s:p.normal.error   = [ [ s:red2,   s:bg ] ]
line 55: let s:p.normal.warning = [ [ s:yellow, s:bg ] ]
line 56: let s:p.insert.right   = [ [ s:bg, s:blue, 'bold' ], [ s:bg, s:blue, 'bold' ] ]
line 57: let s:p.replace.right  = [ [ s:bg, s:red1, 'bold' ], [ s:bg, s:red1, 'bold' ] ]
line 58: let s:p.visual.right   = [ [ s:bg, s:purple, 'bold' ], [ s:bg, s:purple, 'bold' ] ]
line 59: let s:p.tabline.left   = [ [ s:bg, s:gray3 ] ]
line 60: let s:p.tabline.tabsel = [ [ s:bg, s:purple, 'bold' ] ]
line 61: let s:p.tabline.middle = [ [ s:gray3, s:gray2 ] ]
line 62: let s:p.tabline.right  = copy(s:p.normal.right)
line 63: 
line 64: let g:lightline#colorscheme#one#palette = lightline#colorscheme#flatten(s:p)
calling function lightline#colorscheme#flatten({'inactive': {'right': [[['#5c6370', 2...[['#abb2bf', 145], ['#3e4452', 240]]]}})

line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 15:   return a:p
function lightline#colorscheme#flatten returning {'inactive': {'right': [['#5c6370', '#...'], ['#abb2bf', '#3e4452', 145, 240]]}}

continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim

finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim
continuing in function lightline#update[4]..lightline#colorscheme
line 3:   catch
line 4:     call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
line 5:     let s:lightline.colorscheme = 'default'
line 6:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
line 7:   finally
line 8:     if has('win32') && !has('gui_running') && &t_Co < 256
line 9:       for u in values(s:lightline.palette)
line 10:         for v in values(u)
line 11:           for _  in v
line 12:             let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
line 13:           endfor
line 14:         endfor
line 15:       endfor
line 16:     endif
line 17:     let s:highlight = {}
line 18:     call lightline#highlight('normal')
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight('normal')

line 1:   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
line 2:   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
line 3:   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
line 4:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 5:   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_1 guifg=#98c379 guibg=#3e4452 ctermfg=76 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#abb2bf', '#3e4452', 145, 240])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_1 guifg=#abb2bf guibg=#3e4452 ctermfg=145 ctermbg=240 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_2 guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_tabsel guifg=#3e4452 guibg=#c678dd ctermfg=240 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_1 guifg=#c678dd guibg=#3e4452 ctermfg=176 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_2 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_1 guifg=#98c379 guibg=#98c379 ctermfg=76 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_1 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_2 guifg=#98c379 guibg=#2c323d ctermfg=76 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#abb2bf', '#2c323d', 145, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_2 guifg=#abb2bf guibg=#2c323d ctermfg=145 ctermbg=235 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_3 guifg=#2c323d guibg=#2c323d ctermfg=235 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_tabsel guifg=#2c323d guibg=#c678dd ctermfg=235 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_1 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_2 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_3 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[28]..<SNR>66_term(['#abb2bf', '#2c323d', 145, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[28]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 28: hi LightlineMiddle_normal guifg=#abb2bf guibg=#2c323d ctermfg=145 ctermbg=235 
line 29:   endfor
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
line 29:   endfor
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight returning #0

continuing in function lightline#update[4]..lightline#colorscheme

line 19:     call lightline#link()
calling function lightline#update[4]..lightline#colorscheme[19]..lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
line 4:   endif
line 5:   let s:mode = mode
line 6:   if !has_key(s:highlight, mode)
line 7:     call lightline#highlight(mode)
line 8:   endif
line 9:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_0 LightlineLeft_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_1 LightlineLeft_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_tabsel LightlineLeft_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_1 LightlineLeft_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_2 LightlineLeft_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_tabsel LightlineLeft_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_tabsel LightlineLeft_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_0 LightlineLeft_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_1 LightlineLeft_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_2 LightlineLeft_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_tabsel LightlineLeft_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_0 LightlineRight_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_1 LightlineRight_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_tabsel LightlineRight_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_1 LightlineRight_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_2 LightlineRight_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_tabsel LightlineRight_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_2 LightlineRight_normal_2
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_3 LightlineRight_normal_2_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_tabsel LightlineRight_normal_2_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_tabsel LightlineRight_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_0 LightlineRight_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_1 LightlineRight_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_2 LightlineRight_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_3 LightlineRight_normal_tabsel_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_tabsel LightlineRight_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 22:   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
line 22: hi link LightlineMiddle_active LightlineMiddle_normal
line 23:   return ''
function lightline#update[4]..lightline#colorscheme[19]..lightline#link returning ''

continuing in function lightline#update[4]..lightline#colorscheme

line 20:     let s:_ = 0
line 21:   endtry
function lightline#update[4]..lightline#colorscheme returning #0

continuing in function lightline#update

line 5:   endif
line 6:   if !s:lightline.enable.statusline
line 7:     return
line 8:   endif
line 9:   let w = winnr()
line 10:   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
calling function lightline#update[10]..lightline#statusline(0)

line 1:   if a:inactive && !has_key(s:highlight, 'inactive')
line 2:     call lightline#highlight('inactive')
line 3:   endif
line 4:   return s:line(0, a:inactive)
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line(0, 0)

line 1:   let _ = a:tabline ? '' : '%{lightline#link()}'
line 2:   if s:lightline.palette == {}
line 3:     call lightline#colorscheme()
line 4:   endif
line 5:   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
line 6:   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
line 7:   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
line 8:   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
line 9:   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
line 10:   let [lt, lc, ll] = s:expand(copy(l_))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand([['mode', 'paste'], ['gitbranch', 'readonly']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('mode', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['mode'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('paste', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['paste'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('gitbranch', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['gitbranch'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('readonly', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['readonly'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['mode'], 0, '0', '0']], [[['paste... '1']], [[['readonly'], 0, '1', '1']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['mode'], 0, '0', '0'], [['paste'], ...'1', '1'], [['readonly'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand returning [[['mode', 'paste'], ['gitbranch', 're...']], [[0, 0], [0, 0]], ['0', '1', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 11:   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
line 12:   let [rt, rc, rl] = s:expand(copy(r_))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand([['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('lineinfo', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['lineinfo'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('percent', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['percent'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('fileformat', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['fileformat'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('fileencoding', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['fileencoding'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('filetype', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['filetype'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['lineinfo'], 0, '0', '0']]], [[[[... '2']], [[['filetype'], 0, '2', '2']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['lineinfo'], 0, '0', '0'], [['perce...'2', '2'], [['filetype'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand returning [[['lineinfo'], ['percent'], ['filefor... [0], [0, 0, 0]], ['0', '1', '2', '3']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator(['mode', 'paste'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator returning '%{(&paste)?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator(['gitbranch', 'readonly'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator returning '%{fugitive#head()!=#""&&((&readonly))?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 25:   let _ .= '%#LightlineMiddle_' . mode . '#%='
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator(['fileformat', 'fileencoding', 'filetype'], '', [0, 0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator returning '%{1||1?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator(['fileencoding', 'filetype'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator returning '%{1?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 38:   return _
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2v %)'

continuing in function lightline#update[10]..lightline#statusline

function lightline#update[10]..lightline#statusline returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2v %)'

continuing in function lightline#update

line 11:   for n in range(1, winnr('$'))
line 12:     call setwinvar(n, '&statusline', s[n!=w])
line 13:     call setwinvar(n, 'lightline', n!=w)
line 14:   endfor
line 11:   for n in range(1, winnr('$'))
line 12:     call setwinvar(n, '&statusline', s[n!=w])
line 13:     call setwinvar(n, 'lightline', n!=w)
line 14:   endfor
function lightline#update returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call ale#events#LintOnEnter(str2nr(expand('<abuf>')))

line 0: call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
calling function ale#events#LintOnEnter(1)

line 1:     " Unmark a file as being changed outside of Vim after we try to check it.
line 2:     call setbufvar(a:buffer, 'ale_file_changed', 0)
line 3: 
line 4:     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
Searching for "autoload/ale.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/ale.vim"
chdir(/home/ringu/.vim/plugged/ale/autoload)
fchdir() to previous dir
line 4: sourcing "/home/ringu/.vim/plugged/ale/autoload/ale.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
line 2: " Description: Primary code path for the plugin
line 3: "   Manages execution of linters when requested by autocommands
line 4: 
line 5: " Strings used for severity in the echoed message
line 6: let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
line 7: let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
line 8: let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
line 9: " Ignoring linters, for disabling some, or ignoring LSP diagnostics.
line 10: let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
line 11: 
line 12: let s:lint_timer = -1
line 13: let s:getcmdwintype_exists = exists('*getcmdwintype')
line 14: 
line 15: " Return 1 if a file is too large for ALE to handle.
line 16: function! ale#FileTooLarge(buffer) abort
line 21: 
line 22: " A function for checking various conditions whereby ALE just shouldn't
line 23: " attempt to do anything, say if particular buffer types are open in Vim.
line 24: function! ale#ShouldDoNothing(buffer) abort
line 85: 
line 86: function! s:Lint(buffer, should_lint_file, timer_id) abort
line 113: 
line 114: " (delay, [linting_flag, buffer_number])
line 115: function! ale#Queue(delay, ...) abort
line 151: 
line 152: let g:ale_has_override = get(g:, 'ale_has_override', {})
line 153: 
line 154: " Call has(), but check a global Dictionary so we can force flags on or off
line 155: " for testing purposes.
line 156: function! ale#Has(feature) abort
line 159: 
line 160: " Given a buffer number and a variable name, look for that variable in the
line 161: " buffer scope, then in global scope. If the name does not exist in the global
line 162: " scope, an exception will be thrown.
line 163: "
line 164: " Every variable name will be prefixed with 'ale_'.
line 165: function! ale#Var(buffer, variable_name) abort
line 171: 
line 172: " As above, but curry the arguments so only the buffer number is required.
line 173: function! ale#VarFunc(variable_name) abort
line 176: 
line 177: " Initialize a variable with a default value, if it isn't already set.
line 178: "
line 179: " Every variable name will be prefixed with 'ale_'.
line 180: function! ale#Set(variable_name, default) abort
line 187: 
line 188: " Given a string for adding to a command, return the string padded with a
line 189: " space on the left if it is not empty. Otherwise return an empty string.
line 190: "
line 191: " This can be used for making command strings cleaner and easier to test.
line 192: function! ale#Pad(string) abort
line 195: 
line 196: " Given a environment variable name and a value, produce part of a command for
line 197: " setting an environment variable before running a command. The syntax will be
line 198: " valid for cmd on Windows, or most shells on Unix.
line 199: function! ale#Env(variable_name, value) abort
line 206: 
line 207: " Escape a string suitably for each platform.
line 208: " shellescape does not work on Windows.
line 209: function! ale#Escape(str) abort
line 225: 
line 226: " Get the loclist item message according to a given format string.
line 227: "
line 228: " See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
line 229: function! ale#GetLocItemMessage(item, format_string) abort
finished sourcing /home/ringu/.vim/plugged/ale/autoload/ale.vim
continuing in function ale#events#LintOnEnter
calling function ale#events#LintOnEnter[4]..ale#Var(1, 'enabled')

line 1:     let l:full_name = 'ale_' . a:variable_name
line 2:     let l:vars = getbufvar(str2nr(a:buffer), '', {})
line 3: 
line 4:     return get(l:vars, l:full_name, g:[l:full_name])
function ale#events#LintOnEnter[4]..ale#Var returning #1

continuing in function ale#events#LintOnEnter

line 5:         call ale#Queue(0, 'lint_file', a:buffer)
calling function ale#events#LintOnEnter[5]..ale#Queue(0, 'lint_file', 1)

line 1:     if a:0 > 2
line 2:         throw 'too many arguments!'
line 3:     endif
line 4: 
line 5:     let l:buffer = get(a:000, 1, v:null)
line 6: 
line 7:     if l:buffer is v:null
line 8:         let l:buffer = bufnr('')
line 9:     endif
line 10: 
line 11:     if type(l:buffer) isnot v:t_number
line 12:         throw 'buffer_number must be a Number'
line 13:     endif
line 14: 
line 15:     if ale#ShouldDoNothing(l:buffer)
calling function ale#events#LintOnEnter[5]..ale#Queue[15]..ale#ShouldDoNothing(1)

line 1:     " The checks are split into separate if statements to make it possible to
line 2:     " profile each check individually with Vim's profiling tools.
line 3:     "
line 4:     " Do nothing if ALE is disabled.
line 5:     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
line 6:         return 1
line 7:     endif
line 8: 
line 9:     " Don't perform any checks when newer NeoVim versions are exiting.
line 10:     if get(v:, 'exiting', v:null) isnot v:null
line 11:         return 1
line 12:     endif
line 13: 
line 14:     let l:filetype = getbufvar(a:buffer, '&filetype')
line 15: 
line 16:     " Do nothing when there's no filetype.
line 17:     if l:filetype is# ''
line 18:         return 1
function ale#events#LintOnEnter[5]..ale#Queue[15]..ale#ShouldDoNothing returning #1

continuing in function ale#events#LintOnEnter[5]..ale#Queue

line 16:         return
function ale#events#LintOnEnter[5]..ale#Queue returning #0

continuing in function ale#events#LintOnEnter

line 6:     endif
function ale#events#LintOnEnter returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())

line 0: let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
Executing BufWinEnter Autocommands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
calling function <SNR>45_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>45_can_diffoff returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:    call s:diffoff() | endif
line 0:  endif
Executing BufWinEnter Autocommands for "*"
autocommand call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()

line 0: call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()
calling function <SNR>65_IndentLinesDisable()

line 1:     if g:indentLine_newVersion
line 2:         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
line 3:             for id in w:indentLine_indentLineId
line 4:                 try
line 5:                     call matchdelete(id)
line 6:                 catch /^Vim\%((\a\+)\)\=:E80[23]/
line 7:                 endtry
line 8:             endfor
line 9:             let w:indentLine_indentLineId = []
line 10:         endif
line 11: 
line 12:         call s:ResetConcealOption()
calling function <SNR>65_IndentLinesDisable[12]..<SNR>65_ResetConcealOption()

line 1:     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
line 2:         if exists("b:indentLine_original_concealcursor")
line 3:             let &l:concealcursor = b:indentLine_original_concealcursor
line 4:         endif
line 5:         if exists("b:indentLine_original_conceallevel")
line 6:             let &l:conceallevel = b:indentLine_original_conceallevel
line 7:         endif
line 8:         let b:indentLine_ConcealOptionSet = 0
line 9:     endif
function <SNR>65_IndentLinesDisable[12]..<SNR>65_ResetConcealOption returning #0

continuing in function <SNR>65_IndentLinesDisable

line 13:         return
function <SNR>65_IndentLinesDisable returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:  call <SID>LeadingSpaceDisable() | call <SID>Setup()
calling function <SNR>65_LeadingSpaceDisable()

line 1:     if g:indentLine_newVersion
line 2:         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
line 3:             for id in w:indentLine_leadingSpaceId
line 4:                 try
line 5:                     call matchdelete(id)
line 6:                 catch /^Vim\%((\a\+)\)\=:E80[23]/
line 7:                 endtry
line 8:             endfor
line 9:             let w:indentLine_leadingSpaceId = []
line 10:         endif
line 11: 
line 12:         return
function <SNR>65_LeadingSpaceDisable returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:  call <SID>Setup()
calling function <SNR>65_Setup()

line 1:     if &filetype ==# ""
line 2:         call s:InitColor()
calling function <SNR>65_Setup[2]..<SNR>65_InitColor()

line 1:     if !g:indentLine_setColors
line 2:         return
line 3:     endif
line 4: 
line 5:     let default_term_bg = "NONE"
line 6:     let default_gui_bg  = "NONE"
line 7:     if &background ==# "light"
line 8:         let default_term_fg = 249
line 9:         let default_gui_fg = "Grey70"
line 10:     else
line 11:         let default_term_fg = 239
line 12:         let default_gui_fg = "Grey30"
line 13:     endif
line 14: 
line 15:     if g:indentLine_defaultGroup != ""
line 16:         let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
line 17:         let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
line 18:         let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
line 19:         let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
line 20:         let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
line 21:     endif
line 22: 
line 23:     if !exists("g:indentLine_color_term")
line 24:         let term_color = default_term_fg
line 25:     else
line 26:         let term_color = g:indentLine_color_term
line 27:     endif
line 28: 
line 29:     if !exists("g:indentLine_bgcolor_term")
line 30:         let term_bgcolor = default_term_bg
line 31:     else
line 32:         let term_bgcolor = g:indentLine_bgcolor_term
line 33:     endif
line 34: 
line 35:     if !exists("g:indentLine_color_gui")
line 36:         let gui_color = default_gui_fg
line 37:     else
line 38:         let gui_color = g:indentLine_color_gui
line 39:     endif
line 40: 
line 41:     if !exists("g:indentLine_bgcolor_gui")
line 42:         let gui_bgcolor = default_gui_bg
line 43:     else
line 44:         let gui_bgcolor = g:indentLine_bgcolor_gui
line 45:     endif
line 46: 
line 47:     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
line 47: highlight Conceal cterm=NONE ctermfg=239 ctermbg=NONE
line 48:     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
line 48: highlight Conceal gui=NONE guifg=#504945 guibg=NONE
line 49: 
line 50:     if &term ==# "linux"
line 51:         if &background ==# "light"
line 52:             let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
line 53:         else
line 54:             let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
line 55:         endif
line 56:         execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
line 57:     endif
function <SNR>65_Setup[2]..<SNR>65_InitColor returning #0

continuing in function <SNR>65_Setup

line 3:     endif
line 4: 
line 5:     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
calling function <SNR>65_Setup[5]..<SNR>65_Filter()

line 1:     if index(g:indentLine_fileTypeExclude, &filetype) != -1
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if index(g:indentLine_bufTypeExclude, &buftype) != -1
line 6:         return 0
line 7:     endif
line 8: 
line 9:     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
line 10:         return 0
line 11:     endif
line 12: 
line 13:     for name in g:indentLine_bufNameExclude
line 14:         if matchstr(bufname(''), name) == bufname('')
line 15:             return 0
line 16:         endif
line 17:     endfor
line 18: 
line 19:     return 1
function <SNR>65_Setup[5]..<SNR>65_Filter returning #1

continuing in function <SNR>65_Setup

line 6:         call s:IndentLinesEnable()
calling function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable()

line 1:     if g:indentLine_newVersion
line 2:         if &diff
line 3:             return
line 4:         endif
line 5: 
line 6:         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
line 7:             return
line 8:         endif
line 9: 
line 10:         if !exists("w:indentLine_indentLineId")
line 11:             let w:indentLine_indentLineId = []
line 12:         endif
line 13: 
line 14:         call s:SetConcealOption()
calling function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable[14]..<SNR>65_SetConcealOption()

line 1:     if !g:indentLine_setConceal
line 2:         return
line 3:     endif
line 4:     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
line 5:         let b:indentLine_ConcealOptionSet = 1
line 6:         let b:indentLine_original_concealcursor = &l:concealcursor
line 7:         let b:indentLine_original_conceallevel = &l:conceallevel
line 8:         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
line 9:         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
line 10:     endif
function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable[14]..<SNR>65_SetConcealOption returning #0

continuing in function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable

line 15: 
line 16:         if g:indentLine_showFirstIndentLevel
line 17:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
line 18:         endif
line 19: 
line 20:         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 24: 
line 25:         return
function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable returning #0

continuing in function <SNR>65_Setup

line 7:     endif
line 8: 
line 9:     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
calling function <SNR>65_Setup[9]..<SNR>65_Filter()

line 1:     if index(g:indentLine_fileTypeExclude, &filetype) != -1
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if index(g:indentLine_bufTypeExclude, &buftype) != -1
line 6:         return 0
line 7:     endif
line 8: 
line 9:     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
line 10:         return 0
line 11:     endif
line 12: 
line 13:     for name in g:indentLine_bufNameExclude
line 14:         if matchstr(bufname(''), name) == bufname('')
line 15:             return 0
line 16:         endif
line 17:     endfor
line 18: 
line 19:     return 1
function <SNR>65_Setup[9]..<SNR>65_Filter returning #1

continuing in function <SNR>65_Setup

line 10:         call s:LeadingSpaceEnable()
line 11:     endif
function <SNR>65_Setup returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand :call AutoPairsTryInit()

line 0: :call AutoPairsTryInit()
calling function AutoPairsTryInit()

line 1:   if exists('b:autopairs_loaded')
line 2:     return
line 3:   end
line 4: 
line 5:   " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
line 6:   "
line 7:   " vim-endwise doesn't support <Plug>AutoPairsReturn
line 8:   " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
line 9:   "
line 10:   " supertab doesn't support <SID>AutoPairsReturn
line 11:   " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
line 12:   "
line 13:   " and when load after vim-endwise will cause unexpected endwise inserted.
line 14:   " so always load AutoPairs at last
line 15: 
line 16:   " Buffer level keys mapping
line 17:   " comptible with other plugin
line 18:   if g:AutoPairsMapCR
line 19:     if v:version == 703 && has('patch32') || v:version > 703
line 20:       " VIM 7.3 supports advancer maparg which could get <expr> info
line 21:       " then auto-pairs could remap <CR> in any case.
line 22:       let info = maparg('<CR>', 'i', 0, 1)
line 23:       if empty(info)
line 24:         let old_cr = '<CR>'
line 25:         let is_expr = 0
line 26:       else
line 27:         let old_cr = info['rhs']
line 28:         let old_cr = s:ExpandMap(old_cr)
line 29:         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
line 30:         let is_expr = info['expr']
line 31:         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
line 32:       endif
line 33:     else
line 34:       " VIM version less than 7.3
line 35:       " the mapping's <expr> info is lost, so guess it is expr or not, it's
line 36:       " not accurate.
line 37:       let old_cr = maparg('<CR>', 'i')
line 38:       if old_cr == ''
line 39:         let old_cr = '<CR>'
line 40:         let is_expr = 0
line 41:       else
line 42:         let old_cr = s:ExpandMap(old_cr)
line 43:         " old_cr contain (, I guess the old cr is in expr mode
line 44:         let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
line 45: 
line 46:         " The old_cr start with " it must be in expr mode
line 47:         let is_expr = is_expr || old_cr =~ '\v^"'
line 48:         let wrapper_name = '<SID>AutoPairsOldCRWrapper'
line 49:       end
line 50:     end
line 51: 
line 52:     if old_cr !~ 'AutoPairsReturn'
line 53:       if is_expr
line 54:         " remap <expr> to `name` to avoid mix expr and non-expr mode
line 55:         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
line 56:         let old_cr = wrapper_name
line 57:       end
line 58:       " Always silent mapping
line 59:       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
line 59: inoremap <script> <buffer> <silent> <CR> <CR><SID>AutoPairsReturn
line 60:     end
line 61:   endif
line 62:   call AutoPairsInit()
calling function AutoPairsTryInit[62]..AutoPairsInit()

line 1:   let b:autopairs_loaded  = 1
line 2:   if !exists('b:autopairs_enabled')
line 3:     let b:autopairs_enabled = 1
line 4:   end
line 5:   let b:AutoPairsClosedPairs = {}
line 6: 
line 7:   if !exists('b:AutoPairs')
line 8:     let b:AutoPairs = g:AutoPairs
line 9:   end
line 10: 
line 11:   if !exists('b:AutoPairsMoveCharacter')
line 12:     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
line 13:   end
line 14: 
line 15:   " buffer level map pairs keys
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('`')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ` <C-R>=AutoPairsInsert('`')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('"')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> " <C-R>=AutoPairsInsert('"')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('{')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> { <C-R>=AutoPairsInsert('{')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap('}')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> } <C-R>=AutoPairsInsert('}')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('''')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ' <C-R>=AutoPairsInsert('''')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('(')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ( <C-R>=AutoPairsInsert('(')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap(')')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ) <C-R>=AutoPairsInsert(')')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('[')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> [ <C-R>=AutoPairsInsert('[')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap(']')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ] <C-R>=AutoPairsInsert(']')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 23: 
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-(> <C-R>=AutoPairsMoveCharacter('(')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-)> <C-R>=AutoPairsMoveCharacter(')')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-[> <C-R>=AutoPairsMoveCharacter('[')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-]> <C-R>=AutoPairsMoveCharacter(']')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-{> <C-R>=AutoPairsMoveCharacter('{')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-}> <C-R>=AutoPairsMoveCharacter('}')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-"> <C-R>=AutoPairsMoveCharacter('"')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-'> <C-R>=AutoPairsMoveCharacter('''')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 27:   endfor
line 28: 
line 29:   " Still use <buffer> level mapping for <BS> <SPACE>
line 30:   if g:AutoPairsMapBS
line 31:     " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
line 32:     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
line 32: inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>
line 33:   end
line 34: 
line 35:   if g:AutoPairsMapCh
line 36:     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
line 36: inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>
line 37:   endif
line 38: 
line 39:   if g:AutoPairsMapSpace
line 40:     " Try to respect abbreviations on a <SPACE>
line 41:     let do_abbrev = ""
line 42:     if v:version == 703 && has("patch489") || v:version > 703
line 43:       let do_abbrev = "<C-]>"
line 44:     endif
line 45:     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
line 45: inoremap <buffer> <silent> <SPACE> <C-]><C-R>=AutoPairsSpace()<CR>
line 46:   end
line 47: 
line 48:   if g:AutoPairsShortcutFastWrap != ''
line 49:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
line 49: inoremap <buffer> <silent> <M-e> <C-R>=AutoPairsFastWrap()<CR>
line 50:   end
line 51: 
line 52:   if g:AutoPairsShortcutBackInsert != ''
line 53:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
line 53: inoremap <buffer> <silent> <M-b> <C-R>=AutoPairsBackInsert()<CR>
line 54:   end
line 55: 
line 56:   if g:AutoPairsShortcutToggle != ''
line 57:     " use <expr> to ensure showing the status when toggle
line 58:     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
line 58: inoremap <buffer> <silent> <expr> <M-p> AutoPairsToggle()
line 59:     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
line 59: noremap <buffer> <silent> <M-p> :call AutoPairsToggle()<CR>
line 60:   end
line 61: 
line 62:   if g:AutoPairsShortcutJump != ''
line 63:     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
line 63: inoremap <buffer> <silent> <M-n> <ESC>:call AutoPairsJump()<CR>a
line 64:     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
line 64: noremap <buffer> <silent> <M-n> :call AutoPairsJump()<CR>
line 65:   end
line 66: 
function AutoPairsTryInit[62]..AutoPairsInit returning #0

continuing in function AutoPairsTryInit

function AutoPairsTryInit returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))

line 0: call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
calling function ale#events#ReadOrEnterEvent(1)

line 1:     " Apply pattern options if the variable is set.
line 2:     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
line 4:         call ale#pattern_options#SetOptions(a:buffer)
line 5:     endif
line 6: 
line 7:     " When entering a buffer, we are no longer quitting it.
line 8:     call setbufvar(a:buffer, 'ale_quitting', 0)
line 9:     let l:filetype = getbufvar(a:buffer, '&filetype')
line 10:     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
line 11: 
line 12:     " If the file changed outside of Vim, check it on BufEnter,BufRead
line 13:     if getbufvar(a:buffer, 'ale_file_changed')
line 14:         call ale#events#LintOnEnter(a:buffer)
line 15:     endif
function ale#events#ReadOrEnterEvent returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call s:on_bufenter()

line 0: call s:on_bufenter()
calling function <SNR>46_on_bufenter()

line 1:   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
line 2:     let t:gitgutter_didtabenter = 0
line 3:     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
line 4:   else
line 5:     call gitgutter#init_buffer(bufnr(''))
Searching for "autoload/gitgutter.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim"
line 1: let s:t_string = type('')
line 2: 
line 3: " Primary functions {{{
line 4: 
line 5: function! gitgutter#all(force) abort
line 22: 
line 23: 
line 24: " Finds the file's path relative to the repo root.
line 25: function! gitgutter#init_buffer(bufnr)
line 34: 
line 35: 
line 36: function! gitgutter#process_buffer(bufnr, force) abort
line 59: 
line 60: 
line 61: function! gitgutter#disable() abort
line 74: 
line 75: function! gitgutter#enable() abort
line 79: 
line 80: function! gitgutter#toggle() abort
line 87: 
line 88: 
line 89: function! gitgutter#buffer_disable() abort
line 94: 
line 95: function! gitgutter#buffer_enable() abort
line 100: 
line 101: function! gitgutter#buffer_toggle() abort
line 108: 
line 109: " }}}
line 110: 
line 111: function! s:setup_maps()
line 146: 
line 147: function! s:has_fresh_changes(bufnr) abort
line 150: 
line 151: function! s:reset_tick(bufnr) abort
line 154: 
line 155: function! s:clear(bufnr)
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim
continuing in function <SNR>46_on_bufenter
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer(1)

line 1:   if gitgutter#utility#is_active(a:bufnr)
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active(1)

line 1:   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar(1, 'enabled', 1)

line 1:   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
line 2:   if has_key(dict, a:varname)
line 3:     return dict[a:varname]
line 4:   else
line 5:     if a:0
line 6:       return a:1
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar returning #1

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer(1)

line 1:   return empty(getbufvar(a:bufnr, '&buftype'))
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer returning #1

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file(1)

line 1:   return filereadable(s:abs_path(a:bufnr, 0))
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path(1, 0)

line 1:   let p = resolve(expand('#'.a:bufnr.':p'))
line 2:   return a:shellesc ? gitgutter#utility#shellescape(p) : p
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path returning ''

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file

function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file returning #0

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active returning #0

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer

line 2:     let p = gitgutter#utility#repo_path(a:bufnr, 0)
line 3:     if type(p) != s:t_string || empty(p)
line 4:       call gitgutter#utility#set_repo_path(a:bufnr)
line 5:       call s:setup_maps()
line 6:     endif
line 7:   endif
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer returning #0

continuing in function <SNR>46_on_bufenter

line 6:     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer(1, 0)

line 1:   " NOTE a:bufnr is not necessarily the current buffer.
line 2: 
line 3:   if gitgutter#utility#is_active(a:bufnr)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active(1)

line 1:   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar(1, 'enabled', 1)

line 1:   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
line 2:   if has_key(dict, a:varname)
line 3:     return dict[a:varname]
line 4:   else
line 5:     if a:0
line 6:       return a:1
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar returning #1

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer(1)

line 1:   return empty(getbufvar(a:bufnr, '&buftype'))
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer returning #1

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file(1)

line 1:   return filereadable(s:abs_path(a:bufnr, 0))
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path(1, 0)

line 1:   let p = resolve(expand('#'.a:bufnr.':p'))
line 2:   return a:shellesc ? gitgutter#utility#shellescape(p) : p
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path returning ''

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file

function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file returning #0

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active returning #0

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer

line 4:     if a:force || s:has_fresh_changes(a:bufnr)
line 5: 
line 6:       let diff = ''
line 7:       try
line 8:         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
line 9:       catch /gitgutter not tracked/
line 10:         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
line 11:       catch /gitgutter diff failed/
line 12:         call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
line 13:         call gitgutter#hunk#reset(a:bufnr)
line 14:       endtry
line 15: 
line 16:       if diff != 'async'
line 17:         call gitgutter#diff#handler(a:bufnr, diff)
line 18:       endif
line 19: 
line 20:     endif
line 21:   endif
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer returning #0

continuing in function <SNR>46_on_bufenter

line 7:   endif
function <SNR>46_on_bufenter returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif

line 0: if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif
line 0:  call asyncomplete#enable_for_buffer() | endif
Searching for "autoload/asyncomplete.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim"
line 1: if !has('timers')
line 2:     echohl ErrorMsg
line 3:     echomsg 'Vim/Neovim compiled with timers required for asyncomplete.vim.'
line 4:     echohl NONE
line 5:     if has('nvim')
line 6:         call asyncomplete#log('neovim compiled with timers required.')
line 7:     else
line 8:         call asyncomplete#log('vim compiled with timers required.')
line 9:     endif
line 10:     finish
line 11: endif
line 12: 
line 13: let s:sources = {}
line 14: let s:change_timer = -1
line 15: let s:on_changed_p = 0
line 16: let s:last_tick = []
line 17: let s:has_popped_up = 0
line 18: let s:complete_timer_ctx = {}
line 19: let s:already_setup = 0
line 20: let s:next_tick_single_exec_metadata = {}
line 21: let s:has_lua = has('lua') || has('nvim-0.2.2')
line 22: let s:supports_getbufinfo = exists('*getbufinfo')
line 23: let s:supports_smart_completion = exists('##TextChangedP')
line 24: let s:asyncomplete_folder = fnamemodify(expand('<sfile>:p:h') . '/../', ':p:h:gs?\\?/?')
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/autoload/..)
fchdir() to previous dir
line 25: 
line 26: function! s:init_lua() abort
line 30: 
line 31: function! asyncomplete#log(...) abort
line 36: 
line 37: " do nothing, place it here only to avoid the message
line 38: augroup asyncomplete_silence_messages
line 39:     au!
line 40:     autocmd User asyncomplete_setup silent
line 41: augroup END
line 42: 
line 43: function! asyncomplete#enable_for_buffer() abort
line 78: 
line 79: function! asyncomplete#register_source(info) abort
line 101: 
line 102: function! asyncomplete#unregister_source(name) abort
line 112: 
line 113: function! s:clear_active_sources() abort
line 123: 
line 124: function! asyncomplete#complete(name, ctx, startcol, matches, ...) abort
line 137: 
line 138: function! asyncomplete#force_refresh() abort
line 141: 
line 142: function! asyncomplete#_force_refresh() abort
line 148: 
line 149: function! asyncomplete#context() abort
line 158: 
line 159: function! asyncomplete#context_changed(ctx) abort
line 165: 
line 166: function! s:change_tick_start() abort
line 175: 
line 176: function! s:change_tick_stop() abort
line 184: 
line 185: function! s:check_changes(...) abort
line 192: 
line 193: function! s:change_tick() abort
line 196: 
line 197: function! s:on_changed_common() abort
line 211: 
line 212: function! s:on_changed() abort
line 216: 
line 217: function! s:on_changed_p() abort
line 226: 
line 227: function! s:should_skip() abort
line 230: 
line 231: function! s:remote_insert_enter() abort
line 235: 
line 236: function! s:remote_insert_leave() abort
line 240: 
line 241: function! s:file_type_changed() abort
line 244: 
line 245: function! s:get_refresh_pattern(source) abort
line 254: 
line 255: function! s:remote_refresh(ctx, force) abort
line 290: 
line 291: function! s:python_cm_complete(name, ctx, startcol, matches, refresh, outdated) abort
line 313: 
line 314: function! s:python_cm_complete_timeout(srcs, ctx) abort
line 320: 
line 321: function! s:get_active_sources_for_buffer() abort
line 357: 
line 358: if exists('*matchstrpos')
line 359:     function! s:matchstrpos(expr, pattern) abort
line 362: else
line 363:     function! s:matchstrpos(expr, pattern) abort
line 366: endif
line 367: 
line 368: function! s:notify_sources_to_refresh(sources, ctx) abort
line 387: 
line 388: function! s:sort_sources_by_priority(source1, source2) abort
line 393: 
line 394: function! s:python_refresh_completions(ctx) abort
line 451: 
line 452: function! s:filter_completion_items(prefix, matches) abort
line 461: 
line 462: function! s:python_cm_event(name, event, ctx) abort
line 469: 
line 470: function! s:core_complete(ctx, startcol, matches, allmatches) abort
line 497: 
line 498: function! s:supports_smart_completion() abort
line 501: 
line 502: function! s:custom_filter_completion_items(prefix, matches) abort
line 505: 
line 506: function! s:complete_timeout(timer) abort
line 514: 
line 515: " helper function to queue the function at the end of the event loop.
line 516: " last function wins
line 517: function! s:next_tick_single_exec(id, func) abort
line 525: 
line 526: function s:next_tick_single_exec_callback(func, ...) abort
line 529: 
line 530: function! asyncomplete#menu_selected() abort
finished sourcing /home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim
continuing in BufEnter Autocommands for "*"
calling function asyncomplete#enable_for_buffer()

line 1:     if !s:already_setup
line 2:         if s:has_lua
line 3:             call s:init_lua()
calling function asyncomplete#enable_for_buffer[3]..<SNR>72_init_lua()

line 1:     exec 'lua asyncomplete_folder="' . s:asyncomplete_folder . '"'
line 1: lua asyncomplete_folder="/home/ringu/.vim/plugged/asyncomplete.vim"
line 2:     exec 'luafile ' . s:asyncomplete_folder . '/lua/asyncomplete.lua'
line 2: luafile /home/ringu/.vim/plugged/asyncomplete.vim/lua/asyncomplete.lua
function asyncomplete#enable_for_buffer[3]..<SNR>72_init_lua returning #0

continuing in function asyncomplete#enable_for_buffer

line 4:         endif
line 5:         doautocmd User asyncomplete_setup
Executing User Autocommands for "asyncomplete_setup"
autocommand silent

line 0: silent
line 6:         let s:already_setup = 1
line 7:     endif
line 8: 
line 9:     let b:asyncomplete_enable = 1
line 10:     if exists('##TextChangedP')
line 11:         augroup asyncomplete
line 12:             autocmd! * <buffer>
line 13:             autocmd InsertEnter <buffer> call s:remote_insert_enter()
line 14:             autocmd InsertLeave <buffer> call s:remote_insert_leave()
line 15:             autocmd TextChangedI <buffer> call s:on_changed()
line 16:             autocmd TextChangedP <buffer> call s:on_changed_p()
line 17:             autocmd FileType <buffer> call s:file_type_changed()
line 18:         augroup END
line 19:     else
line 20:         augroup asyncomplete
line 21:             autocmd! * <buffer>
line 22:             autocmd InsertEnter <buffer> call s:remote_insert_enter()
line 23:             autocmd InsertLeave <buffer> call s:remote_insert_leave()
line 24:             autocmd InsertEnter <buffer> call s:change_tick_start()
line 25:             autocmd InsertLeave <buffer> call s:change_tick_stop()
line 26:             autocmd FileType <buffer> call s:file_type_changed()
line 27:             " working together with timer, the timer is for detecting changes
line 28:             " popup menu is visible. TextChangedI will not be triggered when popup
line 29:             " menu is visible, but TextChangedI is more efficient and faster than
line 30:             " timer when popup menu is not visible.
line 31:             autocmd TextChangedI <buffer> call s:check_changes()
line 32:         augroup END
line 33:     endif
function asyncomplete#enable_for_buffer returning #0

continuing in BufEnter Autocommands for "*"

line 0:  endif
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

line 0: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>58_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
function <SNR>58_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand silent! autocmd! FileExplorer

line 0: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif

line 0: if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 0: call fugitive#detect(getcwd())|endif
Searching for "autoload/fugitive.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/autoload/fugitive.vim"
Searching for "/usr/share/vim/vim81/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/after/autoload/fugitive.vim"
not found in 'runtimepath': "autoload/fugitive.vim"
calling function fugitive#detect('/home/ringu/sites/travel-site/app')

line 1:   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
line 2:     unlet b:git_dir
line 3:   endif
line 4:   if !exists('b:git_dir')
line 5:     let dir = fugitive#extract_git_dir(a:path)
calling function fugitive#detect[5]..fugitive#extract_git_dir('/home/ringu/sites/travel-site/app')

line 1:   if s:shellslash(a:path) =~# '^fugitive://.*//'
calling function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash('/home/ringu/sites/travel-site/app')

line 1:   if s:winshell()
calling function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 2:     return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
line 3:   endif
line 4:   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
calling function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash('/home/ringu/sites/travel-site/app')

line 1:   if s:winshell()
calling function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 5:   let previous = ""
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     if fugitive#is_git_dir($GIT_DIR)
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir('')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub('', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub returning ''

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 20:       " Ensure that we've cached the worktree
line 21:       call s:configured_tree($GIT_DIR)
line 22:       if has_key(s:dir_for_worktree, root)
line 23:         return s:dir_for_worktree[root]
line 24:       endif
line 25:     endif
line 26:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub('/home/ringu/sites/travel-site/app', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 27:     let type = getftype(dir)
line 28:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 29:       return dir
line 30:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 31:       return resolve(dir)
line 32:     elseif type !=# '' && filereadable(dir)
line 33:       let line = get(readfile(dir, '', 1), 0, '')
line 34:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 35:         return simplify(root.'/'.line[8:-1])
line 36:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 37:         return line[8:-1]
line 38:       endif
line 39:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir('/home/ringu/sites/travel-site/app')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir[1]..<SNR>45_sub('/home/ringu/sites/travel-site/app', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir[1]..<SNR>45_sub returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 40:       return root
line 41:     endif
line 42:     let previous = root
line 43:     let root = fnamemodify(root, ':h')
line 44:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     if fugitive#is_git_dir($GIT_DIR)
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir('')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub('', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub returning ''

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 20:       " Ensure that we've cached the worktree
line 21:       call s:configured_tree($GIT_DIR)
line 22:       if has_key(s:dir_for_worktree, root)
line 23:         return s:dir_for_worktree[root]
line 24:       endif
line 25:     endif
line 26:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub('/home/ringu/sites/travel-site', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub returning '/home/ringu/sites/travel-site'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 27:     let type = getftype(dir)
line 28:     if type ==# 'dir' && fugitive#is_git_dir(dir)
calling function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir('/home/ringu/sites/travel-site/.git')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir[1]..<SNR>45_sub('/home/ringu/sites/travel-site/.git', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir[1]..<SNR>45_sub returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir returning #1

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 29:       return dir
function fugitive#detect[5]..fugitive#extract_git_dir returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect

line 6:     if dir !=# ''
line 7:       let b:git_dir = dir
line 8:     endif
line 9:   endif
line 10:   if exists('b:git_dir')
line 11:     if exists('#User#FugitiveBoot')
line 12:       try
line 13:         let [save_mls, &modelines] = [&mls, 0]
line 14:         doautocmd User FugitiveBoot
line 15:       finally
line 16:         let &mls = save_mls
line 17:       endtry
line 18:     endif
line 19:     cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
line 20:     nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
line 21:     let buffer = fugitive#buffer()
calling function fugitive#detect[21]..fugitive#buffer()

line 1:   return s:buffer(a:0 ? a:1 : '%')
calling function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer('%')

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer

line 4:     return buffer
function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in function fugitive#detect[21]..fugitive#buffer

function fugitive#detect[21]..fugitive#buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in function fugitive#detect

line 22:     if expand('%:p') =~# '//'
line 23:       call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
line 24:     endif
line 25:     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
calling function fugitive#detect[25]..<SNR>45_buffer_getvar('&tags')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect[25]..<SNR>45_buffer_getvar returning './tags,./TAGS,tags,TAGS'

continuing in function fugitive#detect

line 26:       if filereadable(b:git_dir.'/tags')
line 27:         call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
line 28:       endif
line 29:       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
line 30:         call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
line 31:       endif
line 32:     endif
line 33:     try
line 34:       let [save_mls, &modelines] = [&mls, 0]
line 35:       doautocmd User Fugitive
Executing User Autocommands for "Fugitive"
autocommand call s:define_commands()

line 0: call s:define_commands()
calling function <SNR>45_define_commands()

line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar Gstatus :execute s:Status()
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RevisionComplete Gmerge execute s:Merge('merge', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpull execute s:Merge('pull --progress', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 3:   endfor
function <SNR>45_define_commands returning #0

continuing in User Autocommands for "Fugitive"

Executing User Autocommands for "Fugitive"
autocommand if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif

line 0: if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
calling function <SNR>45_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function <SNR>45_buffer

line 4:     return buffer
function <SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in User Autocommands for "Fugitive"

calling function <SNR>45_buffer_commit()

line 1:   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec

function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_commit

function <SNR>45_buffer_commit returning ''

continuing in User Autocommands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)
line 0:  exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)
line 0:  endif
Executing User Autocommands for "Fugitive"
autocommand if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif

line 0: if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
calling function <SNR>45_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function <SNR>45_buffer

line 4:     return buffer
function <SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in User Autocommands for "Fugitive"

calling function <SNR>45_buffer_type('file', 'blob')

line 1:   if self.getvar('fugitive_type') != ''
calling function <SNR>45_buffer_type[1]..<SNR>45_buffer_getvar('fugitive_type')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer_type[1]..<SNR>45_buffer_getvar returning ''

continuing in function <SNR>45_buffer_type

line 2:     let type = self.getvar('fugitive_type')
line 3:   elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 4:     let type = 'head'
line 5:   elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
calling function <SNR>45_buffer_type[5]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[5]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 6:     let type = 'tree'
line 7:   elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
calling function <SNR>45_buffer_type[7]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[7]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 8:     let type = 'tree'
line 9:   elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
calling function <SNR>45_buffer_type[9]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[9]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 10:     let type = 'index'
line 11:   elseif isdirectory(self.spec())
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 12:     let type = 'directory'
line 13:   elseif self.spec() == ''
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 14:     let type = 'null'
line 15:   else
line 16:     let type = 'file'
line 17:   endif
line 18:   if a:0
line 19:     return !empty(filter(copy(a:000),'v:val ==# type'))
function <SNR>45_buffer_type returning #0

continuing in User Autocommands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 0:  endif
Executing User Autocommands for "Fugitive"
autocommand if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif

line 0: if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 0:     set foldtext=fugitive#foldtext() | endif
line 0:  endif
line 36:     finally
line 37:       let &mls = save_mls
line 38:     endtry
line 39:   endif
function fugitive#detect returning #0

continuing in VimEnter Autocommands for "*"

line 0: endif
Executing VimEnter Autocommands for "*"
autocommand if winnr() != winnr('$') | call gitgutter#all(0) | endif

line 0: if winnr() != winnr('$') | call gitgutter#all(0) | endif
line 0:  call gitgutter#all(0) | endif
line 0:  endif
Executing VimEnter Autocommands for "*"
autocommand call lsp#enable()

line 0: call lsp#enable()
Searching for "autoload/lsp.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim"
line 1: let s:enabled = 0
line 2: let s:already_setup = 0
line 3: let s:servers = {} " { lsp_id, server_info, init_callbacks, init_result, buffers: { path: { changed_tick } }
line 4: 
line 5: let s:notification_callbacks = [] " { name, callback }
line 6: 
line 7: " do nothing, place it here only to avoid the message
line 8: augroup _lsp_silent_
line 9:     autocmd!
line 10:     autocmd User lsp_setup silent
line 11:     autocmd User lsp_register_server silent
line 12:     autocmd User lsp_unregister_server silent
line 13:     autocmd User lsp_server_init silent
line 14:     autocmd User lsp_server_exit silent
line 15: augroup END
line 16: 
line 17: function! lsp#log_verbose(...) abort
line 22: 
line 23: function! lsp#log(...) abort
line 28: 
line 29: function! lsp#enable() abort
line 43: 
line 44: function! lsp#disable() abort
line 52: 
line 53: function! lsp#get_server_names() abort
line 56: 
line 57: function! lsp#get_server_info(server_name) abort
line 60: 
line 61: function! lsp#get_server_capabilities(server_name) abort
line 65: 
line 66: function! s:server_status(server_name) abort
line 85: 
line 86: " Returns the current status of all servers (if called with no arguments) or
line 87: " the given server (if given an argument). Can be one of "unknown server",
line 88: " "exited", "starting", "failed", "running", "not running"
line 89: function! lsp#get_server_status(...) abort
line 97: 
line 98: " @params {server_info} = {
line 99: "   'name': 'go-langserver',        " requried, must be unique
line 100: "   'whitelist': ['go'],            " optional, array of filetypes to whitelist, * for all filetypes
line 101: "   'blacklist': [],                " optional, array of filetypes to blacklist, * for all filetypes,
line 102: "   'cmd': {server_info->['go-langserver]} " function that takes server_info and returns array of cmd and args, return empty if you don't want to start the server
line 103: " }
line 104: function! lsp#register_server(server_info) abort
line 117: 
line 118: function! lsp#register_notifications(name, callback) abort
line 121: 
line 122: function! lsp#unregister_notifications(name) abort
line 125: 
line 126: function! lsp#stop_server(server_name) abort
line 131: 
line 132: function! s:register_events() abort
line 143: 
line 144: function! s:unregister_events() abort
line 150: 
line 151: function! s:on_text_document_did_open() abort
line 158: 
line 159: function! s:on_text_document_did_save() abort
line 166: 
line 167: function! s:on_text_document_did_change() abort
line 174: 
line 175: function! s:on_cursor_moved() abort
line 178: 
line 179: function! s:call_did_save(buf, server_name, result, cb) abort
line 215: 
line 216: function! s:on_text_document_did_close() abort
line 219: 
line 220: function! s:ensure_flush_all(buf, server_names) abort
line 225: 
line 226: function! s:Noop(...) abort
line 228: 
line 229: function! s:is_step_error(s) abort
line 232: 
line 233: function! s:throw_step_error(s) abort
line 236: 
line 237: function! s:new_rpc_success(message, data) abort
line 245: 
line 246: function! s:new_rpc_error(message, data) abort
line 257: 
line 258: function! s:ensure_flush(buf, server_name, cb) abort
line 268: 
line 269: function! s:ensure_start(buf, server_name, cb) abort
line 320: 
line 321: function! s:ensure_init(buf, server_name, cb) abort
line 384: 
line 385: function! s:ensure_conf(buf, server_name, cb) abort
line 401: 
line 402: function! s:ensure_changed(buf, server_name, cb) abort
line 437: 
line 438: function! s:ensure_open(buf, server_name, cb) abort
line 471: 
line 472: function! s:send_request(server_name, data) abort
line 481: 
line 482: function! s:send_notification(server_name, data) abort
line 491: 
line 492: function! s:on_stderr(server_name, id, data, event) abort
line 495: 
line 496: function! s:on_exit(server_name, id, data, event) abort
line 509: 
line 510: function! s:on_notification(server_name, id, data, event) abort
line 533: 
line 534: function! s:handle_initialize(server_name, data) abort
line 554: 
line 555: " call lsp#get_whitelisted_servers()
line 556: " call lsp#get_whitelisted_servers(bufnr('%))
line 557: " call lsp#get_whitelisted_servers('typescript')
line 558: function! lsp#get_whitelisted_servers(...) abort
line 601: 
line 602: function! s:requires_eol_at_eof(buf) abort
line 608: 
line 609: function! s:get_text_document_text(buf) abort
line 614: 
line 615: function! s:get_text_document(buf, buffer_info) abort
line 623: 
line 624: function! lsp#get_text_document_identifier(...) abort
line 628: 
line 629: function! lsp#get_position(...) abort
line 632: 
line 633: function! s:get_text_document_identifier(buf, buffer_info) abort
line 639: 
line 640: function! lsp#send_request(server_name, request) abort
line 649: 
line 650: " omnicompletion
line 651: function! lsp#complete(...) abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim
continuing in VimEnter Autocommands for "*"
calling function lsp#enable()

line 1:     if s:enabled
line 2:         return
line 3:     endif
line 4:     if !s:already_setup
line 5:         doautocmd User lsp_setup
Executing User Autocommands for "lsp_setup"
autocommand call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })

line 0: call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })
calling function lsp#register_server({'cmd': function('<lambda>1'), 'root_u...ist': ['javascript', 'javascript.jsx']})

line 1:     let l:server_name = a:server_info['name']
line 2:     if has_key(s:servers, l:server_name)
line 3:         call lsp#log('lsp#register_server', 'server already registered', l:server_name)
line 4:     endif
line 5:     let s:servers[l:server_name] = { 'server_info': a:server_info, 'lsp_id': 0, 'buffers': {}, }
line 10:     call lsp#log('lsp#register_server', 'server registered', l:server_name)
calling function lsp#register_server[10]..lsp#log('lsp#register_server', 'server registered', 'flow')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#register_server[10]..lsp#log returning #0

continuing in function lsp#register_server

line 11:     doautocmd User lsp_register_server
Executing User Autocommands for "lsp_register_server"
autocommand silent

line 0: silent
function lsp#register_server returning #0

continuing in User Autocommands for "lsp_setup"

autocommand call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })

line 0: call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })
calling function lsp#register_server({'cmd': function('<lambda>3'), 'name':..., 'whitelist': ['css', 'less', 'sass']})

line 1:     let l:server_name = a:server_info['name']
line 2:     if has_key(s:servers, l:server_name)
line 3:         call lsp#log('lsp#register_server', 'server already registered', l:server_name)
line 4:     endif
line 5:     let s:servers[l:server_name] = { 'server_info': a:server_info, 'lsp_id': 0, 'buffers': {}, }
line 10:     call lsp#log('lsp#register_server', 'server registered', l:server_name)
calling function lsp#register_server[10]..lsp#log('lsp#register_server', 'server registered', 'css-languageserver')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#register_server[10]..lsp#log returning #0

continuing in function lsp#register_server

line 11:     doautocmd User lsp_register_server
Executing User Autocommands for "lsp_register_server"
autocommand silent

line 0: silent
function lsp#register_server returning #0

continuing in User Autocommands for "lsp_setup"

Executing User Autocommands for "lsp_setup"
autocommand silent

line 0: silent
line 6:         let s:already_setup = 1
line 7:     endif
line 8:     let s:enabled = 1
line 9:     if g:lsp_diagnostics_enabled && g:lsp_signs_enabled
line 10:         call lsp#ui#vim#signs#enable()
line 11:     endif
line 12:     call s:register_events()
calling function lsp#enable[12]..<SNR>73_register_events()

line 1:     augroup lsp
line 2:         autocmd!
line 3:         autocmd BufReadPost * call s:on_text_document_did_open()
line 4:         autocmd BufWritePost * call s:on_text_document_did_save()
line 5:         autocmd BufWinLeave * call s:on_text_document_did_close()
line 6:         autocmd InsertLeave * call s:on_text_document_did_change()
line 7:         autocmd CursorMoved * call s:on_cursor_moved()
line 8:     augroup END
line 9:     call s:on_text_document_did_open()
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open()

line 1:     let l:buf = bufnr('%')
line 2:     call lsp#log('s:on_text_document_did_open()', l:buf, &filetype, getcwd(), lsp#utils#get_buffer_uri(l:buf))
Searching for "autoload/lsp/utils.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload/lsp)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim"
line 1: function! lsp#utils#is_remote_uri(uri) abort
line 4: 
line 5: " Decode uri function is taken from vital framework: https://github.com/vim-jp/vital.vim
line 6: " For it's license (NYSL), see http://www.kmonos.net/nysl/index.en.html
line 7: function! s:decode_uri(uri) abort
line 11: 
line 12: function! s:urlencode_char(c) abort
line 15: 
line 16: function! s:get_prefix(path) abort
line 19: 
line 20: function! s:encode_uri(path, start_pos_encode, default_prefix) abort
line 40: 
line 41: if has('win32') || has('win64')
line 42:     function! lsp#utils#path_to_uri(path) abort
line 57: else
line 58:     function! lsp#utils#path_to_uri(path) abort
line 65: endif
line 66: 
line 67: if has('win32') || has('win64')
line 68:     function! lsp#utils#uri_to_path(uri) abort
line 71: else
line 72:     function! lsp#utils#uri_to_path(uri) abort
line 75: endif
line 76: 
line 77: function! lsp#utils#get_default_root_uri() abort
line 80: 
line 81: function! lsp#utils#get_buffer_path(...) abort
line 84: 
line 85: function! lsp#utils#get_buffer_uri(...) abort
line 88: 
line 89: " Find a nearest to a `path` parent directory `directoryname` by traversing the filesystem upwards
line 90: function! lsp#utils#find_nearest_parent_directory(path, directoryname) abort
line 99: 
line 100: " Find a nearest to a `path` parent filename `filename` by traversing the filesystem upwards
line 101: function! lsp#utils#find_nearest_parent_file(path, filename) abort
line 110: 
line 111: " Find a nearest to a `path` parent filename `filename` by traversing the filesystem upwards
line 112: function! lsp#utils#find_nearest_parent_file_directory(path, filename) abort
line 121: 
line 122: if exists('*matchstrpos')
line 123:     function! lsp#utils#matchstrpos(expr, pattern) abort
line 126: else
line 127:     function! lsp#utils#matchstrpos(expr, pattern) abort
line 130: endif
line 131: 
line 132: function! lsp#utils#empty_complete(...) abort
line 135: 
line 136: function! lsp#utils#error(msg) abort
line 141: 
line 142: function! lsp#utils#echo_with_truncation(msg) abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim
continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri(1)

line 1:     return lsp#utils#path_to_uri(expand((a:0 > 0 ? '#' . a:1 : '%') . ':p'))
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri[1]..lsp#utils#path_to_uri('')

line 1:         if empty(a:path)
line 2:             return a:path
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri[1]..lsp#utils#path_to_uri returning ''

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri

function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri returning ''

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#log('s:on_text_document_did_open()', 1, '', '/home/ringu/sites/travel-site/app', '')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#log returning #0

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

line 3:     for l:server_name in lsp#get_whitelisted_servers()
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[3]..lsp#get_whitelisted_servers()

line 1:     if a:0 == 0
line 2:         let l:buffer_filetype = &filetype
line 3:     else
line 4:         if type(a:1) == type('')
line 5:             let l:buffer_filetype = a:1
line 6:         else
line 7:             let l:buffer_filetype = getbufvar(a:1, '&filetype')
line 8:         endif
line 9:     endif
line 10: 
line 11:     " TODO: cache active servers per buffer
line 12:     let l:active_servers = []
line 13: 
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 40: 
line 41:     return l:active_servers
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[3]..lsp#get_whitelisted_servers returning []

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

line 4:         call s:ensure_flush(l:buf, l:server_name, function('s:Noop'))
line 5:     endfor
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open returning #0

continuing in function lsp#enable[12]..<SNR>73_register_events

function lsp#enable[12]..<SNR>73_register_events returning #0

continuing in function lsp#enable

function lsp#enable returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call lightline#update_once()

line 0: call lightline#update_once()
calling function lightline#update_once()

line 1:   if !exists('w:lightline') || w:lightline
line 2:     call lightline#update()
line 3:   endif
function lightline#update_once returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif

line 0: if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
line 0:  call ale#cursor#EchoCursorWarningWithDelay() | endif
line 0:  endif
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>57_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>57_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:on_cursor_moved()

line 0: call s:on_cursor_moved()
calling function <SNR>73_on_cursor_moved()

line 1:     call lsp#ui#vim#diagnostics#echo#cursor_moved()
Searching for "autoload/lsp/ui/vim/diagnostics/echo.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim"
line 1: function! lsp#ui#vim#diagnostics#echo#cursor_moved() abort
line 21: 
line 22: function! s:echo_diagnostics_under_cursor(...) abort
line 28: 
line 29: function! s:stop_cursor_moved_timer() abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim
continuing in function <SNR>73_on_cursor_moved
calling function <SNR>73_on_cursor_moved[1]..lsp#ui#vim#diagnostics#echo#cursor_moved()

line 1:     if !g:lsp_diagnostics_echo_cursor
line 2:         return
function <SNR>73_on_cursor_moved[1]..lsp#ui#vim#diagnostics#echo#cursor_moved returning #0

continuing in function <SNR>73_on_cursor_moved

function <SNR>73_on_cursor_moved returning #0

continuing in CursorMoved Autocommands for "*"

calling function lightline#tabline()

line 1:   if !has_key(s:highlight, 'tabline')
line 2:     call lightline#highlight('tabline')
calling function lightline#tabline[2]..lightline#highlight('tabline')

line 1:   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
line 2:   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
line 3:   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
line 4:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 5:   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#3e4452', 235, 240])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineLeft_tabline_0 guifg=#282c34 guibg=#3e4452 ctermfg=235 ctermbg=240 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_0_1 guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_0_tabsel guifg=#3e4452 guibg=#c678dd ctermfg=240 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineLeft_tabline_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_0 guifg=#c678dd guibg=#3e4452 ctermfg=176 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_1 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineRight_tabline_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_0_1 guifg=#98c379 guibg=#2c323d ctermfg=76 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineRight_tabline_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_1 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
calling function lightline#tabline[2]..lightline#highlight[28]..<SNR>66_term(['#3e4452', '#2c323d', 240, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[28]..<SNR>66_term returning ''

continuing in function lightline#tabline[2]..lightline#highlight

line 28: hi LightlineMiddle_tabline guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235 
line 29:   endfor
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
line 29:   endfor
function lightline#tabline[2]..lightline#highlight returning #0

continuing in function lightline#tabline

line 3:   endif
line 4:   if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
line 5:     let s:tabnr = tabpagenr()
line 6:     let s:tabcnt = tabpagenr('$')
line 7:     let s:tabline = s:line(1, 0)
calling function lightline#tabline[7]..<SNR>66_line(1, 0)

line 1:   let _ = a:tabline ? '' : '%{lightline#link()}'
line 2:   if s:lightline.palette == {}
line 3:     call lightline#colorscheme()
line 4:   endif
line 5:   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
line 6:   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
line 7:   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
line 8:   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
line 9:   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
line 10:   let [lt, lc, ll] = s:expand(copy(l_))
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand([['tabs', 'filename']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('tabs', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand('lightline#tabs')

line 1:   try
line 2:     let result = eval(a:component . '()')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[2]..lightline#tabs()

line 1:   let [x, y, z] = [[], [], []]
line 2:   let nr = tabpagenr()
line 3:   let cnt = tabpagenr('$')
line 4:   for i in range(1, cnt)
line 5:     call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
line 6:   endfor
line 4:   for i in range(1, cnt)
line 5:     call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
line 6:   endfor
line 7:   let abbr = '...'
line 8:   let n = min([max([s:lightline.winwidth / 40, 2]), 8])
line 9:   if len(x) > n && len(z) > n
line 10:     let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
line 11:     let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
line 12:   elseif len(x) + len(z) > 2 * n
line 13:     if len(x) > n
line 14:       let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
line 15:     elseif len(z) > n
line 16:       let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
line 17:     endif
line 18:   endif
line 19:   return [x, y, z]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[2]..lightline#tabs returning [[], ['%1T%{lightline#onetab(1,1)}%T'], []]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

line 3:     if type(result) == 1 && result ==# ''
line 4:       return []
line 5:     endif
line 6:   catch
line 7:     return []
line 8:   endtry
line 9:   return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize([])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning []

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize(['%1T%{lightline#onetab(1,1)}%T'])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning ['%1T%{lightline#onetab(1,1)}%T']

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize([])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning []

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand returning [[], ['%1T%{lightline#onetab(1,1)}%T'], []]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert

function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['%1T%{lightline#onetab(1,1)}%T'], 1, 'tabsel', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('filename', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['filename'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['%1T%{lightline#onetab(1,1)}%T'],... '0']], [[['filename'], 0, '0', '0']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['%1T%{lightline#onetab(1,1)}%T'], 1...el', '0'], [['filename'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand returning [[['%1T%{lightline#onetab(1,1)}%T'], [...e']], [[1], [0]], ['tabsel', '0', '1']]

continuing in function lightline#tabline[7]..<SNR>66_line

line 11:   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
line 12:   let [rt, rc, rl] = s:expand(copy(r_))
calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand([['close']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('close', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['close'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['close'], 0, '0', '0']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['close'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand returning [[['close']], [[0]], ['0', '1']]

continuing in function lightline#tabline[7]..<SNR>66_line

line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 25:   let _ .= '%#LightlineMiddle_' . mode . '#%='
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 38:   return _
function lightline#tabline[7]..<SNR>66_line returning '%#LightlineLeft_tabline_tabsel#%( %1T...1#%#LightlineRight_tabline_0#%999X X '

continuing in function lightline#tabline

line 8:   endif
line 9:   return s:tabline
function lightline#tabline returning '%#LightlineLeft_tabline_tabsel#%( %1T...1#%#LightlineRight_tabline_0#%999X X '

calling function lightline#onetab(1, 1)

line 1:   let _ = []
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#tabnum(1)

line 1:   return a:n
function lightline#onetab[4]..lightline#tab#tabnum returning #1

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#filename(1)

line 1:   let buflist = tabpagebuflist(a:n)
line 2:   let winnr = tabpagewinnr(a:n)
line 3:   let _ = expand('#'.buflist[winnr - 1].':t')
line 4:   return _ !=# '' ? _ : '[No Name]'
function lightline#onetab[4]..lightline#tab#filename returning '[No Name]'

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#modified(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
function lightline#onetab[4]..lightline#tab#modified returning ''

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 9:   return join(filter(_, 'v:val !=# ""'), ' ')
function lightline#onetab returning '1 [No Name]'

calling function lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
function lightline#link returning ''

calling function lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
function lightline#mode returning 'NORMAL'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
function lightline#link returning ''

calling function lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
function lightline#mode returning 'NORMAL'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'


Executing QuitPre Autocommands for "*"
autocommand call ale#events#QuitEvent(str2nr(expand('<abuf>')))

line 0: call ale#events#QuitEvent(str2nr(expand('<abuf>')))
calling function ale#events#QuitEvent(1)

line 1:     " Remember when ALE is quitting for BufWrite, etc.
line 2:     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())
calling function ale#events#QuitEvent[2]..ale#events#ClockMilliseconds()

line 1:     return float2nr(reltimefloat(reltime()) * 1000)
function ale#events#QuitEvent[2]..ale#events#ClockMilliseconds returning #1547284950924

continuing in function ale#events#QuitEvent

function ale#events#QuitEvent returning #0

continuing in QuitPre Autocommands for "*"

Executing BufWinLeave Autocommands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')

line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: 
Executing BufWinLeave Autocommands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
calling function <SNR>45_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>45_can_diffoff returning #0

continuing in BufWinLeave Autocommands for "*"

line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing BufWinLeave Autocommands for "*"
autocommand call s:on_text_document_did_close()

line 0: call s:on_text_document_did_close()
calling function <SNR>73_on_text_document_did_close()

line 1:     call lsp#log('s:on_text_document_did_close()', bufnr('%'))
calling function <SNR>73_on_text_document_did_close[1]..lsp#log('s:on_text_document_did_close()', 1)

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function <SNR>73_on_text_document_did_close[1]..lsp#log returning #0

continuing in function <SNR>73_on_text_document_did_close

function <SNR>73_on_text_document_did_close returning #0

continuing in BufWinLeave Autocommands for "*"

Executing BufUnload Autocommands for "*"
autocommand call lightline#update_once()

line 0: call lightline#update_once()
calling function lightline#update_once()

line 1:   if !exists('w:lightline') || w:lightline
line 2:     call lightline#update()
line 3:   endif
function lightline#update_once returning #0

continuing in BufUnload Autocommands for "*"

Writing viminfo file "/home/ringu/.viminfo"
chdir(/etc)
fchdir() to previous dir
sourcing "/etc/vimrc"
line 1: " All system-wide defaults are set in $VIMRUNTIME/archlinux.vim (usually just
line 2: " /usr/share/vim/vimfiles/archlinux.vim) and sourced by the call to :runtime
line 3: " you can find below.  If you wish to change any of those settings, you should
line 4: " do it in this file (/etc/vimrc), since archlinux.vim will be overwritten
line 5: " everytime an upgrade of the vim packages is performed.  It is recommended to
line 6: " make changes after sourcing archlinux.vim since it alters the value of the
line 7: " 'compatible' option.
line 8: 
line 9: " This line should not be removed as it ensures that various options are
line 10: " properly set to work with the Vim-related packages.
line 11: runtime! archlinux.vim
Searching for "archlinux.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/archlinux.vim"
chdir(/usr/share/vim/vimfiles)
fchdir() to previous dir
line 11: sourcing "/usr/share/vim/vimfiles/archlinux.vim"
line 1: " The Arch Linux global vimrc - setting only a few sane defaults
line 2: "
line 3: " DO NOT EDIT THIS FILE. IT'S OVERWRITTEN UPON UPGRADES.
line 4: "
line 5: " Use /etc/vimrc for system-wide and $HOME/.vimrc for personal configuration
line 6: " (for details see ':help initialization').
line 7: "
line 8: " Use :help '<option>' to see the documentation for the given option.
line 9: 
line 10: " Use Vim defaults instead of 100% vi compatibility
line 11: " Avoid side-effects when nocompatible has already been set.
line 12: if &compatible
line 13:   set nocompatible
line 14: endif
line 15: 
line 16: set backspace=indent,eol,start
line 17: set ruler
line 18: set suffixes+=.aux,.bbl,.blg,.brf,.cb,.dvi,.idx,.ilg,.ind,.inx,.jpg,.log,.out,.png,.toc
line 19: set suffixes-=.h
line 20: set suffixes-=.obj
line 21: 
line 22: " Move temporary files to a secure location to protect against CVE-2017-1000382
line 23: if exists('$XDG_CACHE_HOME')
line 24:   let &g:directory=$XDG_CACHE_HOME
line 25: else
line 26:   let &g:directory=$HOME . '/.cache'
line 27: endif
line 28: let &g:undodir=&g:directory . '/vim/undo//'
line 29: let &g:backupdir=&g:directory . '/vim/backup//'
line 30: let &g:directory.='/vim/swap//'
line 31: " Create directories if they doesn't exist
line 32: if ! isdirectory(expand(&g:directory))
line 33:   silent! call mkdir(expand(&g:directory), 'p', 0700)
line 34: endif
line 35: if ! isdirectory(expand(&g:backupdir))
line 36:   silent! call mkdir(expand(&g:backupdir), 'p', 0700)
line 37: endif
line 38: if ! isdirectory(expand(&g:undodir))
line 39:   silent! call mkdir(expand(&g:undodir), 'p', 0700)
line 40: endif
line 41: 
line 42: " Make shift-insert work like in Xterm
line 43: if has('gui_running')
line 44:   map <S-Insert> <MiddleMouse>
line 45:   map! <S-Insert> <MiddleMouse>
line 46: endif
finished sourcing /usr/share/vim/vimfiles/archlinux.vim
continuing in /etc/vimrc
Searching for "/usr/share/vim/vim81/archlinux.vim"
Searching for "/usr/share/vim/vimfiles/after/archlinux.vim"
Searching for "/home/ringu/.vim/after/archlinux.vim"
line 12: 
line 13: " If you prefer the old-style vim functionalty, add 'runtime! vimrc_example.vim'
line 14: " Or better yet, read /usr/share/vim/vim80/vimrc_example.vim or the vim manual
line 15: " and configure vim to your own liking!
line 16: 
line 17: " do not load defaults if ~/.vimrc is missing
line 18: "let skip_defaults_vim=1
finished sourcing /etc/vimrc
chdir(/home/ringu)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: call plug#begin()
Searching for "autoload/plug.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/plug.vim"
chdir(/home/ringu/.vim/autoload)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/autoload/plug.vim"
line 1: " vim-plug: Vim plugin manager
line 2: " ============================
line 3: "
line 4: " Download plug.vim and put it in ~/.vim/autoload
line 5: "
line 6: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
line 7: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
line 8: "
line 9: " Edit your .vimrc
line 10: "
line 11: "   call plug#begin('~/.vim/plugged')
line 12: "
line 13: "   " Make sure you use single quotes
line 14: "
line 15: "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
line 16: "   Plug 'junegunn/vim-easy-align'
line 17: "
line 18: "   " Any valid git URL is allowed
line 19: "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'
line 20: "
line 21: "   " Group dependencies, vim-snippets depends on ultisnips
line 22: "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
line 23: "
line 24: "   " On-demand loading
line 25: "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
line 26: "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
line 27: "
line 28: "   " Using a non-master branch
line 29: "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
line 30: "
line 31: "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
line 32: "   Plug 'fatih/vim-go', { 'tag': '*' }
line 33: "
line 34: "   " Plugin options
line 35: "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
line 36: "
line 37: "   " Plugin outside ~/.vim/plugged with post-update hook
line 38: "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
line 39: "
line 40: "   " Unmanaged plugin (manually installed and updated)
line 41: "   Plug '~/my-prototype-plugin'
line 42: "
line 43: "   " Add plugins to &runtimepath
line 44: "   call plug#end()
line 45: "
line 46: " Then reload .vimrc and :PlugInstall to install plugins.
line 47: "
line 48: " Plug options:
line 49: "
line 50: "| Option                  | Description                                      |
line 51: "| ----------------------- | ------------------------------------------------ |
line 52: "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
line 53: "| `rtp`                   | Subdirectory that contains Vim plugin            |
line 54: "| `dir`                   | Custom directory for the plugin                  |
line 55: "| `as`                    | Use different name for the plugin                |
line 56: "| `do`                    | Post-update hook (string or funcref)             |
line 57: "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
line 58: "| `for`                   | On-demand loading: File types                    |
line 59: "| `frozen`                | Do not update unless explicitly specified        |
line 60: "
line 61: " More information: https://github.com/junegunn/vim-plug
line 62: "
line 63: "
line 64: " Copyright (c) 2016 Junegunn Choi
line 65: "
line 66: " MIT License
line 67: "
line 68: " Permission is hereby granted, free of charge, to any person obtaining
line 69: " a copy of this software and associated documentation files (the
line 70: " "Software"), to deal in the Software without restriction, including
line 71: " without limitation the rights to use, copy, modify, merge, publish,
line 72: " distribute, sublicense, and/or sell copies of the Software, and to
line 73: " permit persons to whom the Software is furnished to do so, subject to
line 74: " the following conditions:
line 75: "
line 76: " The above copyright notice and this permission notice shall be
line 77: " included in all copies or substantial portions of the Software.
line 78: "
line 79: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 80: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 81: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 82: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 83: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 84: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 85: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 86: 
line 87: if exists('g:loaded_plug')
line 88:   finish
line 89: endif
line 90: let g:loaded_plug = 1
line 91: 
line 92: let s:cpo_save = &cpo
line 93: set cpo&vim
line 94: 
line 95: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
line 96: let s:plug_tab = get(s:, 'plug_tab', -1)
line 97: let s:plug_buf = get(s:, 'plug_buf', -1)
line 98: let s:mac_gui = has('gui_macvim') && has('gui_running')
line 99: let s:is_win = has('win32') || has('win64')
line 100: let s:nvim = has('nvim') && exists('*jobwait') && !s:is_win
line 101: let s:me = resolve(expand('<sfile>:p'))
line 102: let s:base_spec = { 'branch': 'master', 'frozen': 0 }
line 108: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }
line 109: let s:loaded = get(s:, 'loaded', {})
line 110: let s:triggers = get(s:, 'triggers', {})
line 111: 
line 112: function! plug#begin(...)
line 132: 
line 133: function! s:define_commands()
line 146: 
line 147: function! s:to_a(v)
line 150: 
line 151: function! s:to_s(v)
line 154: 
line 155: function! s:glob(from, pattern)
line 158: 
line 159: function! s:source(from, ...)
line 169: 
line 170: function! s:assoc(dict, key, val)
line 173: 
line 174: function! s:ask(message, ...)
line 183: 
line 184: function! s:ask_no_interrupt(...)
line 191: 
line 192: function! plug#end()
line 281: 
line 282: function! s:loaded_names()
line 285: 
line 286: function! s:load_plugin(spec)
line 289: 
line 290: function! s:reload_plugins()
line 295: 
line 296: function! s:trim(str)
line 299: 
line 300: function! s:version_requirement(val, min)
line 309: 
line 310: function! s:git_version_requirement(...)
line 316: 
line 317: function! s:progress_opt(base)
line 321: 
line 322: if s:is_win
line 323:   function! s:rtp(spec)
line 326: 
line 327:   function! s:path(path)
line 330: 
line 331:   function! s:dirpath(path)
line 334: 
line 335:   function! s:is_local_plug(repo)
line 338: else
line 339:   function! s:rtp(spec)
line 342: 
line 343:   function! s:path(path)
line 346: 
line 347:   function! s:dirpath(path)
line 350: 
line 351:   function! s:is_local_plug(repo)
line 354: endif
line 355: 
line 356: function! s:err(msg)
line 361: 
line 362: function! s:warn(cmd, msg)
line 367: 
line 368: function! s:esc(path)
line 371: 
line 372: function! s:escrtp(path)
line 375: 
line 376: function! s:remove_rtp()
line 386: 
line 387: function! s:reorg_rtp()
line 413: 
line 414: function! s:doautocmd(...)
line 419: 
line 420: function! s:dobufread(names)
line 430: 
line 431: function! plug#load(...)
line 449: 
line 450: function! s:remove_triggers(name)
line 463: 
line 464: function! s:lod(names, types, ...)
line 485: 
line 486: function! s:lod_ft(pat, names)
line 493: 
line 494: function! s:lod_cmd(cmd, bang, l1, l2, args, names)
line 499: 
line 500: function! s:lod_map(map, names, prefix)
line 520: 
line 521: function! plug#(repo, ...)
line 540: 
line 541: function! s:parse_options(arg)
line 556: 
line 557: function! s:infer_properties(name, repo)
line 575: 
line 576: function! s:install(force, names)
line 579: 
line 580: function! s:update(force, names)
line 583: 
line 584: function! plug#helptags()
line 596: 
line 597: function! s:syntax()
line 648: 
line 649: function! s:lpad(str, len)
line 652: 
line 653: function! s:lines(msg)
line 656: 
line 657: function! s:lastline(msg)
line 660: 
line 661: function! s:new_window()
line 664: 
line 665: function! s:plug_window_exists()
line 669: 
line 670: function! s:switch_in()
line 688: 
line 689: function! s:switch_out(...)
line 702: 
line 703: function! s:finish_bindings()
line 712: 
line 713: function! s:prepare(...)
line 748: 
line 749: function! s:assign_name()
line 760: 
line 761: function! s:chsh(swap)
line 768: 
line 769: function! s:bang(cmd, ...)
line 783: 
line 784: function! s:regress_bar()
line 788: 
line 789: function! s:is_updated(dir)
line 792: 
line 793: function! s:do(pull, force, todo)
line 834: 
line 835: function! s:hash_match(a, b)
line 838: 
line 839: function! s:checkout(spec)
line 848: 
line 849: function! s:finish(pull)
line 872: 
line 873: function! s:retry()
line 881: 
line 882: function! s:is_managed(name)
line 885: 
line 886: function! s:names(...)
line 889: 
line 890: function! s:check_ruby()
line 900: 
line 901: function! s:update_impl(pull, force, args) abort
line 1004: 
line 1005: function! s:log4(name, msg)
line 1009: 
line 1010: function! s:update_finish()
line 1065: 
line 1066: function! s:job_abort()
line 1079: 
line 1080: " When a:event == 'stdout', data = list of strings
line 1081: " When a:event == 'exit', data = returncode
line 1082: function! s:job_handler(job_id, data, event) abort
line 1109: 
line 1110: function! s:spawn(name, cmd, opts)
line 1137: 
line 1138: function! s:reap(name)
line 1152: 
line 1153: function! s:bar()
line 1162: 
line 1163: function! s:logpos(name)
line 1170: 
line 1171: function! s:log(bullet, name, lines)
line 1186: 
line 1187: function! s:update_vim()
line 1193: 
line 1194: function! s:tick()
line 1243: 
line 1244: function! s:update_python()
line 1630: 
line 1631: function! s:update_ruby()
line 1845: 
line 1846: function! s:shellesc(arg)
line 1849: 
line 1850: function! s:glob_dir(path)
line 1853: 
line 1854: function! s:progress_bar(line, bar, total)
line 1857: 
line 1858: function! s:compare_git_uri(a, b)
line 1863: 
line 1864: function! s:format_message(bullet, name, message)
line 1872: 
line 1873: function! s:with_cd(cmd, dir)
line 1876: 
line 1877: function! s:system(cmd, ...)
line 1886: 
line 1887: function! s:system_chomp(...)
line 1891: 
line 1892: function! s:git_validate(spec, check_branch)
line 1940: 
line 1941: function! s:rm_rf(dir)
line 1946: 
line 1947: function! s:clean(force)
line 2017: 
line 2018: function! s:delete_op(type, ...)
line 2021: 
line 2022: function! s:delete(range, force)
line 2044: 
line 2045: function! s:upgrade()
line 2071: 
line 2072: function! s:upgrade_specs()
line 2077: 
line 2078: function! s:status()
line 2122: 
line 2123: function! s:extract_name(str, prefix, suffix)
line 2126: 
line 2127: function! s:status_load(lnum)
line 2137: 
line 2138: function! s:status_update() range
line 2146: 
line 2147: function! s:is_preview_window_open()
line 2154: 
line 2155: function! s:find_name(lnum)
line 2168: 
line 2169: function! s:preview_commit()
line 2197: 
line 2198: function! s:section(flags)
line 2201: 
line 2202: function! s:format_git_log(line)
line 2213: 
line 2214: function! s:append_ul(lnum, text)
line 2217: 
line 2218: function! s:diff()
line 2262: 
line 2263: function! s:revert()
line 2280: 
line 2281: function! s:snapshot(force, ...) abort
line 2312: 
line 2313: function! s:split_rtp()
line 2316: 
line 2317: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
calling function <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
function <SNR>4_split_rtp returning ['/home/ringu/.vim', '/usr/share/vim/v...files/after', '/home/ringu/.vim/after']

continuing in /home/ringu/.vim/autoload/plug.vim

calling function <SNR>4_escrtp('/home/ringu/.vim')

line 1:   return escape(a:path, ' ,')
function <SNR>4_escrtp returning '/home/ringu/.vim'

continuing in /home/ringu/.vim/autoload/plug.vim

line 2318: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
calling function <SNR>4_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')
function <SNR>4_split_rtp returning ['/home/ringu/.vim', '/usr/share/vim/v...files/after', '/home/ringu/.vim/after']

continuing in /home/ringu/.vim/autoload/plug.vim

calling function <SNR>4_escrtp('/home/ringu/.vim/after')

line 1:   return escape(a:path, ' ,')
function <SNR>4_escrtp returning '/home/ringu/.vim/after'

continuing in /home/ringu/.vim/autoload/plug.vim

line 2319: 
line 2320: if exists('g:plugs')
line 2321:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
line 2322:   call s:upgrade_specs()
line 2323:   call s:define_commands()
line 2324: endif
line 2325: 
line 2326: let &cpo = s:cpo_save
line 2327: unlet s:cpo_save
finished sourcing /home/ringu/.vim/autoload/plug.vim
continuing in /home/ringu/.vimrc
calling function plug#begin()

line 1:   if a:0 > 0
line 2:     let s:plug_home_org = a:1
line 3:     let home = s:path(fnamemodify(expand(a:1), ':p'))
line 4:   elseif exists('g:plug_home')
line 5:     let home = s:path(g:plug_home)
line 6:   elseif !empty(&rtp)
line 7:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'
calling function plug#begin[7]..<SNR>4_path('/home/ringu/.vim')

line 1:     return s:trim(a:path)
calling function plug#begin[7]..<SNR>4_path[1]..<SNR>4_trim('/home/ringu/.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#begin[7]..<SNR>4_path[1]..<SNR>4_trim returning '/home/ringu/.vim'

continuing in function plug#begin[7]..<SNR>4_path

function plug#begin[7]..<SNR>4_path returning '/home/ringu/.vim'

continuing in function plug#begin

line 8:   else
line 9:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
line 10:   endif
line 11: 
line 12:   let g:plug_home = home
line 13:   let g:plugs = {}
line 14:   let g:plugs_order = []
line 15:   let s:triggers = {}
line 16: 
line 17:   call s:define_commands()
calling function plug#begin[17]..<SNR>4_define_commands()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)
line 2:   if !executable('git')
line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
line 4:   endif
line 5:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
line 6:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
line 7:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
line 8:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
line 9:   command! -nargs=0 -bar PlugStatus  call s:status()
line 10:   command! -nargs=0 -bar PlugDiff    call s:diff()
line 11:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
function plug#begin[17]..<SNR>4_define_commands returning #0

continuing in function plug#begin

line 18:   return 1
function plug#begin returning #1

continuing in /home/ringu/.vimrc

line 2: 
line 3: Plug 'itchyny/lightline.vim'
line 3: call plug#('itchyny/lightline.vim')
calling function plug#('itchyny/lightline.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('itchyny/lightline.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'itchyny/lightline.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('lightline.vim', 'itchyny/lightline.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('itchyny/lightline.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/lightline.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/itch...ome/ringu/.vim/plugged/lightline.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 4: Plug 'tpope/vim-surround'
line 4: call plug#('tpope/vim-surround')
calling function plug#('tpope/vim-surround')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('tpope/vim-surround')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'tpope/vim-surround'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-surround', 'tpope/vim-surround')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('tpope/vim-surround')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-surround/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/tpop...home/ringu/.vim/plugged/vim-surround/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 5: Plug 'jiangmiao/auto-pairs'
line 5: call plug#('jiangmiao/auto-pairs')
calling function plug#('jiangmiao/auto-pairs')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('jiangmiao/auto-pairs')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'jiangmiao/auto-pairs'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('auto-pairs', 'jiangmiao/auto-pairs')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('jiangmiao/auto-pairs')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/auto-pairs/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/jian...'/home/ringu/.vim/plugged/auto-pairs/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 6: Plug 'w0rp/ale'
line 6: call plug#('w0rp/ale')
calling function plug#('w0rp/ale')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('w0rp/ale')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'w0rp/ale'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('ale', 'w0rp/ale')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('w0rp/ale')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/ale/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/w0rp...'dir': '/home/ringu/.vim/plugged/ale/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 7: Plug 'scrooloose/nerdtree'
line 7: call plug#('scrooloose/nerdtree')
calling function plug#('scrooloose/nerdtree')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('scrooloose/nerdtree')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'scrooloose/nerdtree'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('nerdtree', 'scrooloose/nerdtree')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('scrooloose/nerdtree')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/nerdtree/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/scro...: '/home/ringu/.vim/plugged/nerdtree/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 8: Plug 'mattn/emmet-vim'
line 8: call plug#('mattn/emmet-vim')
calling function plug#('mattn/emmet-vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('mattn/emmet-vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'mattn/emmet-vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('emmet-vim', 'mattn/emmet-vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('mattn/emmet-vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/emmet-vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/matt... '/home/ringu/.vim/plugged/emmet-vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 9: Plug 'ryanoasis/vim-devicons'
line 9: call plug#('ryanoasis/vim-devicons')
calling function plug#('ryanoasis/vim-devicons')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('ryanoasis/vim-devicons')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'ryanoasis/vim-devicons'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-devicons', 'ryanoasis/vim-devicons')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('ryanoasis/vim-devicons')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-devicons/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/ryan...home/ringu/.vim/plugged/vim-devicons/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 10: Plug 'junegunn/fzf.vim'
line 10: call plug#('junegunn/fzf.vim')
calling function plug#('junegunn/fzf.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('junegunn/fzf.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'junegunn/fzf.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('fzf.vim', 'junegunn/fzf.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('junegunn/fzf.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fzf.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/june...': '/home/ringu/.vim/plugged/fzf.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 11: Plug 'fugitive.vim'
line 11: call plug#('fugitive.vim')
calling function plug#('fugitive.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('fugitive.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'fugitive.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('fugitive.vim', 'fugitive.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('fugitive.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fugitive.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/vim-...home/ringu/.vim/plugged/fugitive.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 12: Plug 'airblade/vim-gitgutter'
line 12: call plug#('airblade/vim-gitgutter')
calling function plug#('airblade/vim-gitgutter')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('airblade/vim-gitgutter')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'airblade/vim-gitgutter'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-gitgutter', 'airblade/vim-gitgutter')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('airblade/vim-gitgutter')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-gitgutter/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/airb...ome/ringu/.vim/plugged/vim-gitgutter/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 13: Plug 'Yggdroot/indentLine'
line 13: call plug#('Yggdroot/indentLine')
calling function plug#('Yggdroot/indentLine')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('Yggdroot/indentLine')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'Yggdroot/indentLine'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('indentLine', 'Yggdroot/indentLine')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('Yggdroot/indentLine')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/indentLine/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/Yggd...'/home/ringu/.vim/plugged/indentLine/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 14: Plug 'prabirshrestha/asyncomplete.vim'
line 14: call plug#('prabirshrestha/asyncomplete.vim')
calling function plug#('prabirshrestha/asyncomplete.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/asyncomplete.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/asyncomplete.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('asyncomplete.vim', 'prabirshrestha/asyncomplete.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/asyncomplete.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab.../ringu/.vim/plugged/asyncomplete.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 15: Plug 'prabirshrestha/async.vim'
line 15: call plug#('prabirshrestha/async.vim')
calling function plug#('prabirshrestha/async.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/async.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/async.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('async.vim', 'prabirshrestha/async.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/async.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/async.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab... '/home/ringu/.vim/plugged/async.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 16: Plug 'prabirshrestha/vim-lsp'
line 16: call plug#('prabirshrestha/vim-lsp')
calling function plug#('prabirshrestha/vim-lsp')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/vim-lsp')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/vim-lsp'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('vim-lsp', 'prabirshrestha/vim-lsp')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/vim-lsp')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-lsp/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab...': '/home/ringu/.vim/plugged/vim-lsp/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 17: Plug 'prabirshrestha/asyncomplete-lsp.vim'
line 17: call plug#('prabirshrestha/asyncomplete-lsp.vim')
calling function plug#('prabirshrestha/asyncomplete-lsp.vim')

line 1:   if a:0 > 1
line 2:     return s:err('Invalid number of arguments (1..2)')
line 3:   endif
line 4: 
line 5:   try
line 6:     let repo = s:trim(a:repo)
calling function plug#[6]..<SNR>4_trim('prabirshrestha/asyncomplete-lsp.vim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')
function plug#[6]..<SNR>4_trim returning 'prabirshrestha/asyncomplete-lsp.vim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))
line 9:     let spec = extend(s:infer_properties(name, repo), opts)
calling function plug#[9]..<SNR>4_infer_properties('asyncomplete-lsp.vim', 'prabirshrestha/asyncomplete-lsp.vim')

line 1:   let repo = a:repo
line 2:   if s:is_local_plug(repo)
calling function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug('prabirshrestha/asyncomplete-lsp.vim')

line 1:     return a:repo[0] =~ '[/$~]'
function plug#[9]..<SNR>4_infer_properties[2]..<SNR>4_is_local_plug returning #0

continuing in function plug#[9]..<SNR>4_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }
line 4:   else
line 5:     if repo =~ ':'
line 6:       let uri = repo
line 7:     else
line 8:       if repo !~ '/'
line 9:         let repo = 'vim-scripts/'. repo
line 10:       endif
line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
line 12:       let uri = printf(fmt, repo)
line 13:     endif
line 14:     let dir = s:dirpath( fnamemodify(join([g:plug_home, a:name], '/'), ':p') )
calling function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete-lsp.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#[9]..<SNR>4_infer_properties[14]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#[9]..<SNR>4_infer_properties

line 15:     return { 'dir': dir, 'uri': uri }
function plug#[9]..<SNR>4_infer_properties returning {'uri': 'https://git::@github.com/prab...gu/.vim/plugged/asyncomplete-lsp.vim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)
line 11:       call add(g:plugs_order, name)
line 12:     endif
line 13:     let g:plugs[name] = spec
line 14:     let s:loaded[name] = get(s:loaded, name, 0)
line 15:   catch
line 16:     return s:err(v:exception)
line 17:   endtry
function plug# returning #0

continuing in /home/ringu/.vimrc

line 18: 
line 19: call plug#end()
calling function plug#end()

line 1:   if !exists('g:plugs')
line 2:     return s:err('Call plug#begin() first')
line 3:   endif
line 4: 
line 5:   if exists('#PlugLOD')
line 6:     augroup PlugLOD
line 7:       autocmd!
line 8:     augroup END
line 9:     augroup! PlugLOD
line 10:   endif
line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
line 12: 
line 13:   filetype off
Searching for "ftoff.vim" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim81/ftoff.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
Error detected while processing /usr/share/vim/vim81/ftoff.vim:
line   11:
E216: No such group or event: filetypedetect *
finished sourcing /usr/share/vim/vim81/ftoff.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/home/ringu/.vim/after/ftoff.vim"
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 14:   for name in g:plugs_order
line 15:     if !has_key(g:plugs, name)
line 16:       continue
line 17:     endif
line 18:     let plug = g:plugs[name]
line 19:     if get(s:loaded, name, 0) || !has_key(plug, 'on') && !has_key(plug, 'for')
line 20:       let s:loaded[name] = 1
line 21:       continue
line 22:     endif
line 23: 
line 24:     if has_key(plug, 'on')
line 25:       let s:triggers[name] = { 'map': [], 'cmd': [] }
line 26:       for cmd in s:to_a(plug.on)
line 27:         if cmd =~? '^<Plug>.\+'
line 28:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
line 29:             call s:assoc(lod.map, cmd, name)
line 30:           endif
line 31:           call add(s:triggers[name].map, cmd)
line 32:         elseif cmd =~# '^[A-Z]'
line 33:           if exists(':'.cmd) != 2
line 34:             call s:assoc(lod.cmd, cmd, name)
line 35:           endif
line 36:           call add(s:triggers[name].cmd, cmd)
line 37:         else
line 38:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
line 40:         endif
line 41:       endfor
line 42:     endif
line 43: 
line 44:     if has_key(plug, 'for')
line 45:       let types = s:to_a(plug.for)
line 46:       if !empty(types)
line 47:         augroup filetypedetect
line 48:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
line 49:         augroup END
line 50:       endif
line 51:       for type in types
line 52:         call s:assoc(lod.ft, type, name)
line 53:       endfor
line 54:     endif
line 55:   endfor
line 56: 
line 57:   for [cmd, names] in items(lod.cmd)
line 58:     execute printf( 'command! -nargs=* -range -bang %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
line 61:   endfor
line 62: 
line 63:   for [map, names] in items(lod.map)
line 64:     for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
line 66:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), key_prefix)
line 69:     endfor
line 70:   endfor
line 71: 
line 72:   for [ft, names] in items(lod.ft)
line 73:     augroup PlugLOD
line 74:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
line 76:     augroup END
line 77:   endfor
line 78: 
line 79:   call s:reorg_rtp()
calling function plug#end[79]..<SNR>4_reorg_rtp()

line 1:   if !empty(s:first_rtp)
line 2:     execute 'set rtp-='.s:first_rtp
line 2: set rtp-=/home/ringu/.vim
line 3:     execute 'set rtp-='.s:last_rtp
line 3: set rtp-=/home/ringu/.vim/after
line 4:   endif
line 5: 
line 6:   " &rtp is modified from outside
line 7:   if exists('s:prtp') && s:prtp !=# &rtp
line 8:     call s:remove_rtp()
line 9:     unlet! s:middle
line 10:   endif
line 11: 
line 12:   let s:middle = get(s:, 'middle', &rtp)
line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_loaded_names()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_loaded_names returning ['lightline.vim', 'vim-surround', 'aut...im', 'vim-lsp', 'asyncomplete-lsp.vim']

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/itch...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/lightline.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/lightline.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/tpop...und/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-surround/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-surround/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/jian...irs/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/auto-pairs/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/auto-pairs/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/w0rp...ale/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/ale/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/ale/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/scro...ree/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/nerdtree/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/nerdtree/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/matt...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/emmet-vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/emmet-vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/ryan...ons/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-devicons/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-devicons/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/june...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fzf.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/fzf.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/vim-...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/fugitive.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/fugitive.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/airb...ter/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-gitgutter/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-gitgutter/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/Yggd...ine/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/indentLine/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/indentLine/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/asyncomplete.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/async.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/async.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...lsp/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/vim-lsp/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/vim-lsp/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp({'uri': 'https://git::@github.com/prab...vim/', 'frozen': 0, 'branch': 'master'})

line 1:     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))
calling function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath('/home/ringu/.vim/plugged/asyncomplete-lsp.vim/')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')
function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp[1]..<SNR>4_dirpath returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp

function plug#end[79]..<SNR>4_reorg_rtp[13]..<SNR>4_rtp returning '/home/ringu/.vim/plugged/asyncomplete-lsp.vim/'

continuing in function plug#end[79]..<SNR>4_reorg_rtp

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), 'isdirectory(v:val)')
line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
line 19:   let s:prtp   = &rtp
line 20: 
line 21:   if !empty(s:first_rtp)
line 22:     execute 'set rtp^='.s:first_rtp
line 22: set rtp^=/home/ringu/.vim
line 23:     execute 'set rtp+='.s:last_rtp
line 23: set rtp+=/home/ringu/.vim/after
line 24:   endif
function plug#end[79]..<SNR>4_reorg_rtp returning #0

continuing in function plug#end

line 80:   filetype plugin indent on
Searching for "filetype.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/filetype.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/filetype.vim"
Searching for "/home/ringu/.vim/plugged/ale/filetype.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/filetype.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2018 May 04
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.pacsave,?\+.pacnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Vim help file
line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 53: 
line 54: " Abaqus or Trasys
line 55: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 56: 
line 57: " A-A-P recipe
line 58: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 59: 
line 60: " A2ps printing utility
line 61: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 62: 
line 63: " ABAB/4
line 64: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 65: 
line 66: " ABC music notation
line 67: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 68: 
line 69: " ABEL
line 70: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 71: 
line 72: " AceDB
line 73: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 74: 
line 75: " Ada (83, 9X, 95)
line 76: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 77: if has("vms")
line 78:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 79: else
line 80:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 81: endif
line 82: 
line 83: " AHDL
line 84: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 85: 
line 86: " AMPL
line 87: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 88: 
line 89: " Ant
line 90: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 91: 
line 92: " Arduino
line 93: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 94: 
line 95: " Apache style config file
line 96: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 97: 
line 98: " Apache config file
line 99: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 100: 
line 101: " XA65 MOS6510 cross assembler
line 102: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 103: 
line 104: " Applescript
line 105: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 106: 
line 107: " Applix ELF
line 109: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 110: 
line 111: " ALSA configuration
line 112: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 113: 
line 114: " Arc Macro Language
line 115: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 116: 
line 117: " APT config file
line 118: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 119: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 120: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 121: 
line 122: " Arch Inventory file
line 123: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 124: 
line 125: " ART*Enterprise (formerly ART-IM)
line 126: au BufNewFile,BufRead *.art^I^I^Isetf art
line 127: 
line 128: " AsciiDoc
line 129: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 130: 
line 131: " ASN.1
line 132: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 133: 
line 134: " Active Server Pages (with Visual Basic Script)
line 140: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 141: 
line 142: " Active Server Pages (with Perl or Visual Basic Script)
line 150: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 151: 
line 152: " Grub (must be before catch *.lst)
line 153: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 154: 
line 155: " Assembly (all kinds)
line 156: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 157: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 158: 
line 159: " Macro (VAX)
line 160: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 161: 
line 162: " Atlas
line 163: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 164: 
line 165: " Autoit v3
line 166: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 167: 
line 168: " Autohotkey
line 169: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 170: 
line 171: " Automake
line 172: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 173: 
line 174: " Autotest .at files are actually m4
line 175: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 176: 
line 177: " Avenue
line 178: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 179: 
line 180: " Awk
line 181: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 182: 
line 183: " B
line 184: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 185: 
line 186: " BASIC or Visual Basic
line 187: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")
line 188: 
line 189: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 190: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 191: 
line 192: " IBasic file (similar to QBasic)
line 193: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 194: 
line 195: " FreeBasic file (similar to QBasic)
line 196: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 197: 
line 198: " Batch file for MSDOS.
line 199: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 200: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 202: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 203: 
line 204: " Batch file for 4DOS
line 205: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 206: 
line 207: " BC calculator
line 208: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 209: 
line 210: " BDF font
line 211: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 212: 
line 213: " BibTeX bibliography database file
line 214: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 215: 
line 216: " BibTeX Bibliography Style
line 217: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 218: 
line 219: " BIND configuration
line 220: " sudoedit uses namedXXXX.conf
line 221: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 222: 
line 223: " BIND zone
line 224: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 225: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 226: 
line 227: " Blank
line 228: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 229: 
line 230: " Blkid cache file
line 231: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 232: 
line 233: " Bazel (http://bazel.io)
line 234: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl
line 235: if has("fname_case")
line 236:   " There is another check for BUILD further below.
line 237:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl
line 238: endif
line 239: 
line 240: " C or lpc
line 241: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 242: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 243: 
line 244: " Calendar
line 245: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 246: 
line 247: " C#
line 248: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 249: 
line 250: " CSDL
line 251: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 252: 
line 253: " Cabal
line 254: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 255: 
line 256: " Cdrdao TOC
line 257: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 258: 
line 259: " Cdrdao config
line 260: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 261: 
line 262: " Cfengine
line 263: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 264: 
line 265: " ChaiScript
line 266: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 267: 
line 268: " Comshare Dimension Definition Language
line 269: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 270: 
line 271: " Conary Recipe
line 272: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 273: 
line 274: " Controllable Regex Mutilator
line 275: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 276: 
line 277: " Cyn++
line 278: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 279: 
line 280: " Cynlib
line 281: " .cc and .cpp files can be C++ or Cynlib.
line 283: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 285: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 286: 
line 287: " C++
line 288: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 289: if has("fname_case")
line 290:   au BufNewFile,BufRead *.C,*.H setf cpp
line 291: endif
line 292: 
line 293: " .h files can be C, Ch C++, ObjC or ObjC++.
line 294: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 295: " detected automatically.
line 296: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 297: 
line 298: " Ch (CHscript)
line 299: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 300: 
line 301: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 302: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 303: 
line 304: " Cascading Style Sheets
line 305: au BufNewFile,BufRead *.css^I^I^Isetf css
line 306: 
line 307: " Century Term Command Scripts (*.cmd too)
line 308: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 309: 
line 310: " Changelog
line 312: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 313: 
line 319: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 320: 
line 324: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 325: 
line 326: " CHILL
line 327: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 328: 
line 329: " Changes for WEB and CWEB or CHILL
line 330: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 331: 
line 332: " ChordPro
line 333: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 334: 
line 335: " Clean
line 336: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 337: 
line 338: " Clever
line 339: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 340: 
line 341: " Clever or dtd
line 342: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 343: 
line 344: " Clipper (or FoxPro; could also be eviews)
line 350: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 351: 
line 352: " Clojure
line 353: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 354: 
line 355: " Cmake
line 356: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 357: 
line 358: " Cmusrc
line 359: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 360: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 361: 
line 362: " Cobol
line 363: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 364: "   cobol or zope form controller python script? (heuristic)
line 370: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 371: 
line 372: " Coco/R
line 373: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 374: 
line 375: " Cold Fusion
line 376: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 377: 
line 378: " Configure scripts
line 379: au BufNewFile,BufRead configure.in,configure.ac setf config
line 380: 
line 381: " CUDA  Cumpute Unified Device Architecture
line 382: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 383: 
line 384: " Dockerfile
line 385: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 386: 
line 387: " WildPackets EtherPeek Decoder
line 388: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 389: 
line 390: " Enlightenment configuration files
line 391: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 392: 
line 393: " Eterm
line 394: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 395: 
line 396: " Euphoria 3 or 4
line 397: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 398: if has("fname_case")
line 399:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 400: endif
line 401: 
line 402: " Lynx config files
line 403: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 404: 
line 405: " Quake
line 406: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 407: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 408: 
line 409: " Quake C
line 410: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 411: 
line 412: " Configure files
line 413: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 414: 
line 415: " Cucumber
line 416: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 417: 
line 418: " Communicating Sequential Processes
line 419: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 420: 
line 421: " CUPL logic description and simulation
line 422: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 423: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 424: 
line 425: " Debian Control
line 426: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 430: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 431: 
line 432: " Debian Copyright
line 433: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 437: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 438: 
line 439: " Debian Sources.list
line 440: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 441: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 442: 
line 443: " Deny hosts
line 444: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 445: 
line 446: " dnsmasq(8) configuration files
line 447: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 448: 
line 449: " ROCKLinux package description
line 450: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 451: 
line 452: " the D language or dtrace
line 453: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 454: 
line 455: " Desktop files
line 456: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 457: 
line 458: " Dict config
line 459: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 460: 
line 461: " Dictd config
line 462: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 463: 
line 464: " Diff files
line 465: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 471: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 472: 
line 473: " Dircolors
line 474: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 475: 
line 476: " Diva (with Skill) or InstallShield
line 482: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 483: 
line 484: " DCL (Digital Command Language - vms) or DNS zone file
line 485: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 486: 
line 487: " DOT
line 488: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 489: 
line 490: " Dylan - lid files
line 491: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 492: 
line 493: " Dylan - intr files (melange)
line 494: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 495: 
line 496: " Dylan
line 497: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 498: 
line 499: " Microsoft Module Definition
line 500: au BufNewFile,BufRead *.def^I^I^Isetf def
line 501: 
line 502: " Dracula
line 503: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 504: 
line 505: " Datascript
line 506: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 507: 
line 508: " dsl
line 509: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 510: 
line 511: " DTD (Document Type Definition for XML)
line 512: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 513: 
line 514: " DTS/DSTI (device tree files)
line 515: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 516: 
line 517: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 518: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 524: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 525: 
line 526: " EditorConfig (close enough to dosini)
line 527: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 528: 
line 529: " Embedix Component Description
line 530: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 531: 
line 532: " Eiffel or Specman or Euphoria
line 533: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 534: 
line 535: " Elinks configuration
line 536: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 537: 
line 538: " ERicsson LANGuage; Yaws is erlang too
line 539: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 540: 
line 541: " Elm Filter Rules file
line 542: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 543: 
line 544: " ESMTP rc file
line 545: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 546: 
line 547: " ESQL-C
line 548: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 549: 
line 550: " Esterel
line 551: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 552: 
line 553: " Essbase script
line 554: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 555: 
line 556: " Exim
line 557: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 558: 
line 559: " Expect
line 560: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 561: 
line 562: " Exports
line 563: au BufNewFile,BufRead exports^I^I^Isetf exports
line 564: 
line 565: " Falcon
line 566: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 567: 
line 568: " Fantom
line 569: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 570: 
line 571: " Factor
line 572: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 573: 
line 574: " Fetchmail RC file
line 575: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 576: 
line 577: " FlexWiki - disabled, because it has side effects when a .wiki file
line 578: " is not actually FlexWiki
line 579: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 580: 
line 581: " Focus Executable
line 582: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 583: 
line 584: " Focus Master file (but not for auto.master)
line 585: au BufNewFile,BufRead auto.master^I^Isetf conf
line 586: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 587: 
line 588: " Forth
line 589: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth
line 590: 
line 591: " Reva Forth
line 592: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 593: 
line 594: " Fortran
line 595: if has("fname_case")
line 596:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 597: endif
line 598: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 599: 
line 600: " Framescript
line 601: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 602: 
line 603: " FStab
line 604: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 605: 
line 606: " GDB command files
line 607: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 608: 
line 609: " GDMO
line 610: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 611: 
line 612: " Gedcom
line 613: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 614: 
line 615: " Git
line 616: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit
line 617: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig
line 618: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 619: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 620: if !empty($XDG_CONFIG_HOME)
line 621:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 622: endif
line 623: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 624: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 628: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 632: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 633: 
line 634: " Gkrellmrc
line 635: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 636: 
line 637: " GP scripts (2.0 and onward)
line 638: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 639: 
line 640: " GPG
line 641: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 642: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 643: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 644: if !empty($GNUPGHOME)
line 645:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 646:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 647: endif
line 648: 
line 649: " gnash(1) configuration files
line 650: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 651: 
line 652: " Gitolite
line 653: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 654: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 655: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 656: 
line 657: " Gnuplot scripts
line 658: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 659: 
line 660: " Go (Google)
line 661: au BufNewFile,BufRead *.go^I^I^Isetf go
line 662: 
line 663: " GrADS scripts
line 664: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 665: 
line 666: " Gretl
line 667: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 668: 
line 669: " Groovy
line 670: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 671: 
line 672: " GNU Server Pages
line 673: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 674: 
line 675: " Group file
line 676: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 677: 
line 678: " GTK RC
line 679: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 680: 
line 681: " Haml
line 682: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 683: 
line 684: " Hamster Classic | Playground files
line 685: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 686: 
line 687: " Haskell
line 688: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 689: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 690: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 691: 
line 692: " Haste
line 693: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 694: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 695: 
line 696: " Hercules
line 697: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 698: 
line 699: " HEX (Intel)
line 700: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 701: 
line 702: " Tilde (must be before HTML)
line 703: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 704: 
line 705: " HTML (.shtml and .stm for server side)
line 706: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 707: 
line 708: " HTML with Ruby - eRuby
line 709: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 710: 
line 711: " HTML with M4
line 712: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 713: 
line 714: " HTML Cheetah template
line 715: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 716: 
line 717: " Host config
line 718: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 719: 
line 720: " Hosts access
line 721: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 722: 
line 723: " Hyper Builder
line 724: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 725: 
line 726: " Httest
line 727: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 728: 
line 729: " Icon
line 730: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 731: 
line 732: " IDL (Interface Description Language)
line 733: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 734: 
line 735: " Microsoft IDL (Interface Description Language)  Also *.idl
line 736: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 737: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 738: 
line 739: " Icewm menu
line 740: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 741: 
line 742: " Indent profile (must come before IDL *.pro!)
line 743: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 744: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 745: 
line 746: " IDL (Interactive Data Language)
line 747: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 748: 
line 749: " Indent RC
line 750: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 751: 
line 752: " Inform
line 753: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 754: 
line 755: " Initng
line 756: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 757: 
line 758: " Innovation Data Processing
line 759: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 760: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 761: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 762: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 763: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 764: 
line 765: " Ipfilter
line 766: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 767: 
line 768: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 769: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 770: 
line 771: " .INI file for MSDOS
line 772: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 773: 
line 774: " SysV Inittab
line 775: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 776: 
line 777: " Inno Setup
line 778: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 779: 
line 780: " J
line 781: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 782: 
line 783: " JAL
line 784: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 785: 
line 786: " Jam
line 787: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 788: 
line 789: " Java
line 790: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 791: 
line 792: " JavaCC
line 793: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 794: 
line 795: " JavaScript, ECMAScript
line 796: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 797: 
line 798: " Java Server Pages
line 799: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 800: 
line 801: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 802: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 803: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 804: 
line 805: " Jess
line 806: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 807: 
line 808: " Jgraph
line 809: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 810: 
line 811: " Jovial
line 812: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 813: 
line 814: " JSON
line 815: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 816: 
line 817: " Kixtart
line 818: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 819: 
line 820: " Kimwitu[++]
line 821: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 822: 
line 823: " Kivy
line 824: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 825: 
line 826: " KDE script
line 827: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 828: 
line 829: " Kconfig
line 830: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 831: 
line 832: " Lace (ISE)
line 833: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 834: 
line 835: " Latte
line 836: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 837: 
line 838: " Limits
line 839: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 840: 
line 841: " LambdaProlog (*.mod too, see Modsim)
line 842: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 843: 
line 844: " LDAP LDIF
line 845: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 846: 
line 847: " Ld loader
line 848: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 849: 
line 850: " Less
line 851: au BufNewFile,BufRead *.less^I^I^Isetf less
line 852: 
line 853: " Lex
line 854: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 855: 
line 856: " Libao
line 857: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 858: 
line 859: " Libsensors
line 860: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 861: 
line 862: " LFTP
line 863: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 864: 
line 865: " Lifelines (or Lex for C++!)
line 866: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 867: 
line 868: " Lilo: Linux loader
line 869: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 870: 
line 871: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 872: if has("fname_case")
line 873:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 874: else
line 875:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 876: endif
line 877: 
line 878: " SBCL implementation of Common Lisp
line 879: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 880: 
line 881: " Liquid
line 882: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 883: 
line 884: " Lite
line 885: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 886: 
line 887: " LiteStep RC files
line 888: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 889: 
line 890: " Login access
line 891: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 892: 
line 893: " Login defs
line 894: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 895: 
line 896: " Logtalk
line 897: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 898: 
line 899: " LOTOS
line 900: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 901: 
line 902: " Lout (also: *.lt)
line 903: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 904: 
line 905: " Lua
line 906: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 907: 
line 908: " Luarocks
line 909: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 910: 
line 911: " Linden Scripting Language (Second Life)
line 912: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 913: 
line 914: " Lynx style file (or LotusScript!)
line 915: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 916: 
line 917: " M4
line 919: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 920: 
line 921: " MaGic Point
line 922: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 923: 
line 924: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 925: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 926: 
line 927: " Mail aliases
line 928: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 929: 
line 930: " Mailcap configuration file
line 931: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 932: 
line 933: " Makefile
line 934: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 935: 
line 936: " MakeIndex
line 937: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 938: 
line 939: " Mallard
line 940: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 941: 
line 942: " Manpage
line 943: au BufNewFile,BufRead *.man^I^I^Isetf man
line 944: 
line 945: " Man config
line 946: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 947: 
line 948: " Maple V
line 949: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 950: 
line 951: " Map (UMN mapserver config file)
line 952: au BufNewFile,BufRead *.map^I^I^Isetf map
line 953: 
line 954: " Markdown
line 955: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 956: 
line 957: " Mason
line 958: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 959: 
line 960: " Mathematica, Matlab, Murphi or Objective C
line 961: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 962: 
line 963: " Mathematica notebook
line 964: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 965: 
line 966: " Maya Extension Language
line 967: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 968: 
line 969: " Mercurial (hg) commit file
line 970: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 971: 
line 972: " Mercurial config (looks like generic config file)
line 973: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 974: 
line 975: " Messages (logs mostly)
line 976: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 977: 
line 978: " Metafont
line 979: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 980: 
line 981: " MetaPost
line 982: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 983: 
line 984: " MGL
line 985: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 986: 
line 987: " MIX - Knuth assembly
line 988: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 989: 
line 990: " MMIX or VMS makefile
line 991: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 992: 
line 993: " Symbian meta-makefile definition (MMP)
line 994: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 995: 
line 996: " Modsim III (or LambdaProlog)
line 1002: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1003: 
line 1004: " Modula 2  (.md removed in favor of Markdown)
line 1005: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1006: 
line 1007: " Modula 3 (.m3, .i3, .mg, .ig)
line 1008: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1009: 
line 1010: " Monk
line 1011: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1012: 
line 1013: " MOO
line 1014: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1015: 
line 1016: " Modconf
line 1017: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1018: 
line 1019: " Mplayer config
line 1020: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1021: 
line 1022: " Motorola S record
line 1023: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1024: 
line 1025: " Mrxvtrc
line 1026: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1027: 
line 1028: " Msql
line 1029: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1030: 
line 1031: " Mysql
line 1032: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1033: 
line 1034: " Mutt setup files (must be before catch *.rc)
line 1035: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1036: 
line 1037: " M$ Resource files
line 1038: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1039: 
line 1040: " MuPAD source
line 1041: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1042: 
line 1043: " Mush
line 1044: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1045: 
line 1046: " Mutt setup file (also for Muttng)
line 1047: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1048: 
line 1049: " N1QL
line 1050: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1051: 
line 1052: " Nano
line 1053: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1054: 
line 1055: " Nastran input/DMAP
line 1056: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1057: 
line 1058: " Natural
line 1059: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1060: 
line 1061: " Noemutt setup file
line 1062: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1063: 
line 1064: " Netrc
line 1065: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1066: 
line 1067: " Ninja file
line 1068: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1069: 
line 1070: " Novell netware batch files
line 1071: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1072: 
line 1073: " Nroff/Troff (*.ms and *.t are checked below)
line 1077: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1078: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1079: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1080: 
line 1081: " Nroff or Objective C++
line 1082: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1083: 
line 1084: " Not Quite C
line 1085: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1086: 
line 1087: " NSE - Nmap Script Engine - uses Lua syntax
line 1088: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1089: 
line 1090: " NSIS
line 1091: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1092: 
line 1093: " OCAML
line 1094: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1095: 
line 1096: " Occam
line 1097: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1098: 
line 1099: " Omnimark
line 1100: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1101: 
line 1102: " OpenROAD
line 1103: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1104: 
line 1105: " OPL
line 1106: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1107: 
line 1108: " Oracle config file
line 1109: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1110: 
line 1111: " Packet filter conf
line 1112: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1113: 
line 1114: " Pam conf
line 1115: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1116: 
line 1117: " PApp
line 1118: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1119: 
line 1120: " Password file
line 1121: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1122: 
line 1123: " Pascal (also *.p)
line 1124: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1125: 
line 1126: " Delphi project file
line 1127: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1128: 
line 1129: " PDF
line 1130: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1131: 
line 1132: " PCMK - HAE - crm configure edit
line 1133: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk
line 1134: 
line 1135: " Perl
line 1136: if has("fname_case")
line 1137:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()
line 1138: else
line 1139:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()
line 1140: endif
line 1141: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1142: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1143: 
line 1144: " Perl, XPM or XPM2
line 1152: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1153: 
line 1154: " Perl POD
line 1155: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1156: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1157: 
line 1158: " Php, php3, php4, etc.
line 1159: " Also Phtml (was used for PHP 2 in the past)
line 1160: " Also .ctp for Cake template file
line 1161: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1162: 
line 1163: " Pike and Cmod
line 1164: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1165: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1166: 
line 1167: " Pinfo config
line 1168: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1169: 
line 1170: " Palm Resource compiler
line 1171: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1172: 
line 1173: " Pine config
line 1174: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1175: 
line 1176: " PL/1, PL/I
line 1177: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1178: 
line 1179: " PL/M (also: *.inp)
line 1180: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1181: 
line 1182: " PL/SQL
line 1183: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1184: 
line 1185: " PLP
line 1186: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1187: 
line 1188: " PO and PO template (GNU gettext)
line 1189: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1190: 
line 1191: " Postfix main config
line 1192: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1193: 
line 1194: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1195: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1196: 
line 1197: " PostScript Printer Description
line 1198: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1199: 
line 1200: " Povray
line 1201: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1202: 
line 1203: " Povray configuration
line 1204: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1205: 
line 1206: " Povray, PHP or assembly
line 1207: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1208: 
line 1209: " Printcap and Termcap
line 1211: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1213: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1214: 
line 1215: " PCCTS / ANTRL
line 1216: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1217: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1218: 
line 1219: " PPWizard
line 1220: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1221: 
line 1222: " Obj 3D file format
line 1223: " TODO: is there a way to avoid MS-Windows Object files?
line 1224: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1225: 
line 1226: " Oracle Pro*C/C++
line 1227: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1228: 
line 1229: " Privoxy actions file
line 1230: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1231: 
line 1232: " Procmail
line 1233: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1234: 
line 1235: " Progress or CWEB
line 1236: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1237: 
line 1238: " Progress or assembly
line 1239: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()
line 1240: 
line 1241: " Progress or Pascal
line 1242: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1243: 
line 1244: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1245: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1249: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1250: 
line 1251: " Prolog
line 1252: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1253: 
line 1254: " Promela
line 1255: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1256: 
line 1257: " Google protocol buffers
line 1258: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1259: 
line 1260: " Protocols
line 1261: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1262: 
line 1263: " Pyrex
line 1264: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1265: 
line 1266: " Python, Python Shell Startup and Python Stub Files
line 1267: " Quixote (Python-based web framework)
line 1268: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python
line 1269: 
line 1270: " Radiance
line 1271: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1272: 
line 1273: " Ratpoison config/command files
line 1274: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1275: 
line 1276: " RCS file
line 1277: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1278: 
line 1279: " Readline
line 1280: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1281: 
line 1282: " Registry for MS-Windows
line 1284: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1285: 
line 1286: " Renderman Interface Bytestream
line 1287: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1288: 
line 1289: " Rexx
line 1290: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1291: 
line 1292: " R (Splus)
line 1293: if has("fname_case")
line 1294:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1295: else
line 1296:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1297: endif
line 1298: 
line 1299: " R Help file
line 1300: if has("fname_case")
line 1301:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1302: else
line 1303:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1304: endif
line 1305: 
line 1306: " R noweb file
line 1307: if has("fname_case")
line 1308:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1309: else
line 1310:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1311: endif
line 1312: 
line 1313: " R Markdown file
line 1314: if has("fname_case")
line 1315:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1316: else
line 1317:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1318: endif
line 1319: 
line 1320: " R reStructuredText file
line 1321: if has("fname_case")
line 1322:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1323: else
line 1324:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1325: endif
line 1326: 
line 1327: " Rexx, Rebol or R
line 1328: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1329: 
line 1330: " Remind
line 1331: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1332: 
line 1333: " Resolv.conf
line 1334: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1335: 
line 1336: " Relax NG Compact
line 1337: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1338: 
line 1339: " Relax NG XML
line 1340: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1341: 
line 1342: " RPL/2
line 1343: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1344: 
line 1345: " Robots.txt
line 1346: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1347: 
line 1348: " Rpcgen
line 1349: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1350: 
line 1351: " reStructuredText Documentation Format
line 1352: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1353: 
line 1354: " RTF
line 1355: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1356: 
line 1357: " Interactive Ruby shell
line 1358: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1359: 
line 1360: " Ruby
line 1361: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1362: 
line 1363: " RubyGems
line 1364: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1365: 
line 1366: " Rust
line 1367: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1368: 
line 1369: " Rackup
line 1370: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1371: 
line 1372: " Bundler
line 1373: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1374: 
line 1375: " Ruby on Rails
line 1376: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1377: 
line 1378: " Rantfile and Rakefile is like Ruby
line 1379: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1380: 
line 1381: " S-lang (or shader language, or SmallLisp)
line 1382: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1383: 
line 1384: " Samba config
line 1385: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1386: 
line 1387: " SAS script
line 1388: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1389: 
line 1390: " Sass
line 1391: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1392: 
line 1393: " Sather
line 1394: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1395: 
line 1396: " Scala
line 1397: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1398: 
line 1399: " SBT - Scala Build Tool
line 1400: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1401: 
line 1402: " Scilab
line 1403: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1404: 
line 1405: " SCSS
line 1406: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1407: 
line 1408: " SD: Streaming Descriptors
line 1409: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1410: 
line 1411: " SDL
line 1412: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1413: 
line 1414: " sed
line 1415: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1416: 
line 1417: " Sieve (RFC 3028, 5228)
line 1418: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1419: 
line 1420: " Sendmail
line 1421: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1422: 
line 1423: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1424: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1425: 
line 1426: " Services
line 1427: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1428: 
line 1429: " Service Location config
line 1430: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1431: 
line 1432: " Service Location registration
line 1433: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1434: 
line 1435: " Service Location SPI
line 1436: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1437: 
line 1438: " Setserial config
line 1439: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1440: 
line 1441: " SGML
line 1451: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1452: 
line 1453: " SGMLDECL
line 1457: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1458: 
line 1459: " SGML catalog file
line 1460: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1461: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1462: 
line 1463: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1464: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1465: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,PKGBUILD*,*.install,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
line 1466: au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1467: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1468: 
line 1469: " Shell script (Arch Linux) or PHP file (Drupal)
line 1475: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 1476: 
line 1477: " tcsh scripts
line 1478: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 1479: 
line 1480: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1481: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 1482: 
line 1483: " Z-Shell script
line 1484: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1485: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1486: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1487: 
line 1488: " Scheme
line 1489: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1490: 
line 1491: " Screen RC
line 1492: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1493: 
line 1494: " Simula
line 1495: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1496: 
line 1497: " SINDA
line 1498: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1499: 
line 1500: " SiSU
line 1501: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1502: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1503: 
line 1504: " SKILL
line 1505: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1506: 
line 1507: " SLRN
line 1508: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1509: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1510: 
line 1511: " Smalltalk (and TeX)
line 1512: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1520: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1521: 
line 1522: " Smarty templates
line 1523: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1524: 
line 1525: " SMIL or XML
line 1531: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 1532: 
line 1533: " SMIL or SNMP MIB file
line 1539: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 1540: 
line 1541: " SMITH
line 1542: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 1543: 
line 1544: " Snobol4 and spitbol
line 1545: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 1546: 
line 1547: " SNMP MIB files
line 1548: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 1549: 
line 1550: " Snort Configuration
line 1551: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 1552: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 1553: 
line 1554: " Spec (Linux RPM)
line 1555: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 1556: 
line 1557: " Speedup (AspenTech plant simulator)
line 1558: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 1559: 
line 1560: " Slice
line 1561: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 1562: 
line 1563: " Spice
line 1564: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 1565: 
line 1566: " Spyce
line 1567: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 1568: 
line 1569: " Squid
line 1570: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 1571: 
line 1572: " SQL for Oracle Designer
line 1573: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 1574: 
line 1575: " SQL
line 1576: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 1577: 
line 1578: " SQLJ
line 1579: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 1580: 
line 1581: " SQR
line 1582: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 1583: 
line 1584: " OpenSSH configuration
line 1585: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 1586: 
line 1587: " OpenSSH server configuration
line 1588: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 1589: 
line 1590: " Stata
line 1591: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 1592: " Also *.class, but not when it's a Java bytecode file
line 1594: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 1595: 
line 1596: " SMCL
line 1597: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 1598: 
line 1599: " Stored Procedures
line 1600: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 1601: 
line 1602: " Standard ML
line 1603: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 1604: 
line 1605: " Sratus VOS command macro
line 1606: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 1607: 
line 1608: " Sysctl
line 1609: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 1610: 
line 1611: " Systemd unit files
line 1612: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 1613: 
line 1614: " Synopsys Design Constraints
line 1615: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 1616: 
line 1617: " Sudoers
line 1618: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 1619: 
line 1620: " SVG (Scalable Vector Graphics)
line 1621: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 1622: 
line 1623: " Tads (or Nroff or Perl test file)
line 1625: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 1626: 
line 1627: " Tags
line 1628: au BufNewFile,BufRead tags^I^I^Isetf tags
line 1629: 
line 1630: " TAK
line 1631: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 1632: 
line 1633: " Task
line 1634: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 1635: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 1636: 
line 1637: " Tcl (JACL too)
line 1638: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 1639: 
line 1640: " TealInfo
line 1641: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 1642: 
line 1643: " Telix Salt
line 1644: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 1645: 
line 1646: " Tera Term Language
line 1647: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 1648: 
line 1649: " Terminfo
line 1650: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 1651: 
line 1652: " TeX
line 1653: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 1654: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 1655: 
line 1656: " ConTeXt
line 1657: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 1658: 
line 1659: " Texinfo
line 1660: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 1661: 
line 1662: " TeX configuration
line 1663: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 1664: 
line 1665: " Tidy config
line 1666: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 1667: 
line 1668: " TF mud client
line 1669: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 1670: 
line 1671: " tmux configuration
line 1672: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 1673: 
line 1674: " TPP - Text Presentation Program
line 1675: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 1676: 
line 1677: " Treetop
line 1678: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 1679: 
line 1680: " Trustees
line 1681: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 1682: 
line 1683: " TSS - Geometry
line 1684: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 1685: 
line 1686: " TSS - Optics
line 1687: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 1688: 
line 1689: " TSS - Command Line (temporary)
line 1690: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 1691: 
line 1692: " TWIG files
line 1693: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 1694: 
line 1695: " Motif UIT/UIL files
line 1696: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 1697: 
line 1698: " Udev conf
line 1699: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 1700: 
line 1701: " Udev permissions
line 1702: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 1703: "
line 1704: " Udev symlinks config
line 1705: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 1706: 
line 1707: " UnrealScript
line 1708: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 1709: 
line 1710: " Updatedb
line 1711: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 1712: 
line 1713: " Upstart (init(8)) config files
line 1714: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 1715: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 1716: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 1717: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 1718: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 1719: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 1720: 
line 1721: " Vera
line 1722: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 1723: 
line 1724: " Verilog HDL
line 1725: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 1726: 
line 1727: " Verilog-AMS HDL
line 1728: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 1729: 
line 1730: " SystemVerilog
line 1731: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 1732: 
line 1733: " VHDL
line 1734: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 1735: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 1736: 
line 1737: " Vim script
line 1738: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 1739: 
line 1740: " Viminfo file
line 1741: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 1742: 
line 1743: " Virata Config Script File or Drupal module
line 1749: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 1750: 
line 1751: " Visual Basic (also uses *.bas) or FORM
line 1752: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")
line 1753: 
line 1754: " SaxBasic is close to Visual Basic
line 1755: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 1756: 
line 1757: " Vgrindefs file
line 1758: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 1759: 
line 1760: " VRML V1.0c
line 1761: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 1762: 
line 1763: " Vroom (vim testing and executable documentation)
line 1764: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 1765: 
line 1766: " Webmacro
line 1767: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 1768: 
line 1769: " WebAssembly
line 1770: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast
line 1771: 
line 1772: " Wget config
line 1773: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 1774: 
line 1775: " Website MetaLanguage
line 1776: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 1777: 
line 1778: " Winbatch
line 1779: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 1780: 
line 1781: " WSML
line 1782: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 1783: 
line 1784: " WPL
line 1785: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 1786: 
line 1787: " WvDial
line 1788: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 1789: 
line 1790: " CVS RC file
line 1791: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 1792: 
line 1793: " CVS commit file
line 1794: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 1795: 
line 1796: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 1797: " lines in a WEB file).
line 1803: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 1804: 
line 1805: " Windows Scripting Host and Windows Script Component
line 1806: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 1807: 
line 1808: " XHTML
line 1809: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 1810: 
line 1811: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 1817: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 1818: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 1819: 
line 1820: " XFree86 config
line 1825: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 1828: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1829: 
line 1830: " Xorg config
line 1831: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 1832: 
line 1833: " Xinetd conf
line 1834: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 1835: 
line 1836: " XS Perl extension interface language
line 1837: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 1838: 
line 1839: " X resources file
line 1840: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 1841: 
line 1842: " Xmath
line 1843: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 1845: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 1846: 
line 1847: " XML  specific variants: docbk and xbl
line 1848: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 1849: 
line 1850: " XMI (holding UML models) is also XML
line 1851: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 1852: 
line 1853: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 1854: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 1855: 
line 1856: " Qt Linguist translation source and Qt User Interface Files are XML
line 1857: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 1858: 
line 1859: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 1860: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 1861: 
line 1862: " Xdg menus
line 1863: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 1864: 
line 1865: " ATI graphics driver configuration
line 1866: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 1867: 
line 1868: " Web Services Description Language (WSDL)
line 1869: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 1870: 
line 1871: " XLIFF (XML Localisation Interchange File Format) is also XML
line 1872: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 1873: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 1874: 
line 1875: " XML User Interface Language
line 1876: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 1877: 
line 1878: " X11 xmodmap (also see below)
line 1879: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 1880: 
line 1881: " Xquery
line 1882: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 1883: 
line 1884: " XSD
line 1885: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 1886: 
line 1887: " Xslt
line 1888: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 1889: 
line 1890: " Yacc
line 1891: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 1892: 
line 1893: " Yacc or racc
line 1894: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 1895: 
line 1896: " Yaml
line 1897: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 1898: 
line 1899: " Raml
line 1900: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 1901: 
line 1902: " yum conf (close enough to dosini)
line 1903: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 1904: 
line 1905: " Zimbu
line 1906: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 1907: " Zimbu Templates
line 1908: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 1909: 
line 1910: " Zope
line 1911: "   dtml (zope dynamic template markup language), pt (zope page template),
line 1912: "   cpt (zope form controller page template)
line 1913: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 1914: "   zsql (zope sql method)
line 1915: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 1916: 
line 1917: " Z80 assembler asz80
line 1918: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 1919: 
line 1920: augroup END
line 1921: 
line 1922: 
line 1923: " Source the user-specified filetype file, for backwards compatibility with
line 1924: " Vim 5.x.
line 1925: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 1926:   execute "source " . myfiletypefile
line 1927: endif
line 1928: 
line 1929: 
line 1930: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 1931: " when there are no matching file name extensions.
line 1932: " Don't do this for compressed files.
line 1933: augroup filetypedetect
line 1936: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 1937: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 1938: 
line 1939: 
line 1940: " Extra checks for when no filetype has been detected now.  Mostly used for
line 1941: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 1942: " script file.
line 1943: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 1944: " like are used.
line 1945: 
line 1946: " More Apache style config files
line 1947: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 1948: 
line 1949: " More Apache config files
line 1950: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 1951: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 1952: 
line 1953: " Asterisk config file
line 1954: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 1955: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 1956: 
line 1957: " Bazaar version control
line 1958: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 1959: 
line 1960: " Bazel build file
line 1961: if !has("fname_case")
line 1962:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 1963: endif
line 1964: 
line 1965: " BIND zone
line 1966: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 1967: 
line 1968: " Calendar
line 1971: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 1972: 
line 1973: " Changelog
line 1979: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 1980: 
line 1981: " Crontab
line 1982: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 1983: 
line 1984: " dnsmasq(8) configuration
line 1985: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 1986: 
line 1987: " Dracula
line 1988: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 1989: 
line 1990: " Fvwm
line 1991: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 1993: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 1999: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2000: 
line 2001: " Gedcom
line 2002: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2003: 
line 2004: " GTK RC
line 2005: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2006: 
line 2007: " Jam
line 2008: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2009: 
line 2010: " Jargon
line 2014: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2015: 
line 2016: " Kconfig
line 2017: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2018: 
line 2019: " Lilo: Linux loader
line 2020: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2021: 
line 2022: " Logcheck
line 2023: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2024: 
line 2025: " Makefile
line 2026: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2027: 
line 2028: " Ruby Makefile
line 2029: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2030: 
line 2031: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2032: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2033: 
line 2034: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2035: 
line 2036: " Modconf
line 2040: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2041: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2042: 
line 2043: " Mutt setup file
line 2044: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2045: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2046: 
line 2047: " Neomutt setup file
line 2048: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2049: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2050: 
line 2051: " Nroff macros
line 2052: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2053: 
line 2054: " OpenBSD hostname.if
line 2055: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2056: 
line 2057: " Pam conf
line 2058: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2059: 
line 2060: " Printcap and Termcap
line 2064: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2068: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2069: 
line 2070: " ReDIF
line 2071: " Only used when the .rdf file was not detected to be XML.
line 2072: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2073: 
line 2074: " Remind
line 2075: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2076: 
line 2077: " Vim script
line 2078: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2079: 
line 2080: " Subversion commit file
line 2081: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2082: 
line 2083: " X resources file
line 2084: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2085: 
line 2086: " XFree86 config
line 2088: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2093: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2094: 
line 2095: " X11 xmodmap
line 2096: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2097: 
line 2098: " Xinetd conf
line 2099: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2100: 
line 2101: " yum conf (close enough to dosini)
line 2102: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2103: 
line 2104: " Z-Shell script
line 2105: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2106: 
line 2107: 
line 2108: " Plain text files, needs to be far down to not override others.  This avoids
line 2109: " the "conf" type being used if there is a line starting with '#'.
line 2110: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2111: 
line 2112: " Help files match *.txt but should have a last line that is a modeline.
line 2116: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2117: 
line 2118: 
line 2119: " Use the filetype detect plugins.  They may overrule any of the previously
line 2120: " detected filetypes.
line 2121: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 2121: sourcing "/usr/share/vim/vimfiles/ftdetect/conkyrc.vim"
line 1: " Vim filetype detection file for Conky config files
line 2: "
line 3: 
line 4: au BufNewFile,BufRead *conkyrc set filetype=conkyrc
line 5: au BufNewFile,BufRead conky.conf set filetype=conkyrc
finished sourcing /usr/share/vim/vimfiles/ftdetect/conkyrc.vim
continuing in /usr/share/vim/vim81/filetype.vim
chdir(/usr/share/vim/vimfiles/ftdetect)
fchdir() to previous dir
line 2121: sourcing "/usr/share/vim/vimfiles/ftdetect/meson.vim"
line 1: au BufNewFile,BufRead meson.build set filetype=meson
line 2: au BufNewFile,BufRead meson_options.txt set filetype=meson
finished sourcing /usr/share/vim/vimfiles/ftdetect/meson.vim
continuing in /usr/share/vim/vim81/filetype.vim
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftdetect/*.vim"
Searching for "/home/ringu/.vim/after/ftdetect/*.vim"
line 2122: 
line 2123: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2124: " and started another one. Let's make sure it has ended to get to a consistent
line 2125: " state.
line 2126: augroup END
line 2127: 
line 2128: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2134: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2135: 
line 2136: 
line 2137: " If the GUI is already running, may still need to install the Syntax menu.
line 2138: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2140: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2141:   source <sfile>:p:h/menu.vim
line 2142: endif
line 2143: 
line 2144: " Function called for testing all functions defined here.  These are
line 2145: " script-local, thus need to be executed here.
line 2146: " Returns a string with error messages (hopefully empty).
line 2147: func! TestFiletypeFuncs(testlist)
line 2158: 
line 2159: " Restore 'cpoptions'
line 2160: let &cpo = s:cpo_save
line 2161: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/filetype.vim"
Searching for "/home/ringu/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftplugin.vim"
Searching for "/home/ringu/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/indent.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/indent.vim"
Searching for "/home/ringu/.vim/plugged/ale/indent.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/indent.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/indent.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 80: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in function plug#end
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/indent.vim"
Searching for "/home/ringu/.vim/after/indent.vim"
line 81:   if has('vim_starting')
line 82:     if has('syntax') && !exists('g:syntax_on')
line 83:       syntax enable
line 83: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 83: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in function plug#end
line 84:     end
line 85:   else
line 86:     call s:reload_plugins()
line 87:   endif
function plug#end returning #0

continuing in /home/ringu/.vimrc

line 20: 
line 21: set laststatus=2
line 22: set noshowmode
line 23: set showtabline=2
line 24: set t_Co=256
line 25: set background=dark
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 25: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 26: set noswapfile
line 27: set nowrap
line 28: set title
line 29: set updatetime=100
line 30: colorscheme gruvbox 
Searching for "colors/gruvbox.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/ale/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/colors/gruvbox.vim"
Searching for "/usr/share/vim/vimfiles/colors/gruvbox.vim"
chdir(/usr/share/vim/vimfiles/colors)
fchdir() to previous dir
line 30: sourcing "/usr/share/vim/vimfiles/colors/gruvbox.vim"
line 1: " -----------------------------------------------------------------------------
line 2: " File: gruvbox.vim
line 3: " Description: Retro groove color scheme for Vim
line 4: " Author: morhetz <morhetz@gmail.com>
line 5: " Source: https://github.com/morhetz/gruvbox
line 6: " Last Modified: 12 Aug 2017
line 7: " -----------------------------------------------------------------------------
line 8: 
line 9: " Supporting code -------------------------------------------------------------
line 10: " Initialisation: {{{
line 11: 
line 12: if version > 580
line 13:   hi clear
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 14:   if exists("syntax_on")
line 15:     syntax reset
line 15: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 16:   endif
line 17: endif
line 18: 
line 19: let g:colors_name='gruvbox'
line 20: 
line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256
line 22:   finish
line 23: endif
line 24: 
line 25: " }}}
line 26: " Global Settings: {{{
line 27: 
line 28: if !exists('g:gruvbox_bold')
line 29:   let g:gruvbox_bold=1
line 30: endif
line 31: if !exists('g:gruvbox_italic')
line 32:   if has('gui_running') || $TERM_ITALICS == 'true'
line 33:     let g:gruvbox_italic=1
line 34:   else
line 35:     let g:gruvbox_italic=0
line 36:   endif
line 37: endif
line 38: if !exists('g:gruvbox_undercurl')
line 39:   let g:gruvbox_undercurl=1
line 40: endif
line 41: if !exists('g:gruvbox_underline')
line 42:   let g:gruvbox_underline=1
line 43: endif
line 44: if !exists('g:gruvbox_inverse')
line 45:   let g:gruvbox_inverse=1
line 46: endif
line 47: 
line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
line 49:   let g:gruvbox_guisp_fallback='NONE'
line 50: endif
line 51: 
line 52: if !exists('g:gruvbox_improved_strings')
line 53:   let g:gruvbox_improved_strings=0
line 54: endif
line 55: 
line 56: if !exists('g:gruvbox_improved_warnings')
line 57:   let g:gruvbox_improved_warnings=0
line 58: endif
line 59: 
line 60: if !exists('g:gruvbox_termcolors')
line 61:   let g:gruvbox_termcolors=256
line 62: endif
line 63: 
line 64: if !exists('g:gruvbox_invert_indent_guides')
line 65:   let g:gruvbox_invert_indent_guides=0
line 66: endif
line 67: 
line 68: if exists('g:gruvbox_contrast')
line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
line 70: endif
line 71: 
line 72: if !exists('g:gruvbox_contrast_dark')
line 73:   let g:gruvbox_contrast_dark='medium'
line 74: endif
line 75: 
line 76: if !exists('g:gruvbox_contrast_light')
line 77:   let g:gruvbox_contrast_light='medium'
line 78: endif
line 79: 
line 80: let s:is_dark=(&background == 'dark')
line 81: 
line 82: " }}}
line 83: " Palette: {{{
line 84: 
line 85: " setup palette dictionary
line 86: let s:gb = {}
line 87: 
line 88: " fill it with absolute colors
line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40
line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69
line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
line 97: 
line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
line 100: 
line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132
line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
line 109: 
line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
line 117: 
line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
line 125: 
line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
line 133: 
line 134: " }}}
line 135: " Setup Emphasis: {{{
line 136: 
line 137: let s:bold = 'bold,'
line 138: if g:gruvbox_bold == 0
line 139:   let s:bold = ''
line 140: endif
line 141: 
line 142: let s:italic = 'italic,'
line 143: if g:gruvbox_italic == 0
line 144:   let s:italic = ''
line 145: endif
line 146: 
line 147: let s:underline = 'underline,'
line 148: if g:gruvbox_underline == 0
line 149:   let s:underline = ''
line 150: endif
line 151: 
line 152: let s:undercurl = 'undercurl,'
line 153: if g:gruvbox_undercurl == 0
line 154:   let s:undercurl = ''
line 155: endif
line 156: 
line 157: let s:inverse = 'inverse,'
line 158: if g:gruvbox_inverse == 0
line 159:   let s:inverse = ''
line 160: endif
line 161: 
line 162: " }}}
line 163: " Setup Colors: {{{
line 164: 
line 165: let s:vim_bg = ['bg', 'bg']
line 166: let s:vim_fg = ['fg', 'fg']
line 167: let s:none = ['NONE', 'NONE']
line 168: 
line 169: " determine relative colors
line 170: if s:is_dark
line 171:   let s:bg0  = s:gb.dark0
line 172:   if g:gruvbox_contrast_dark == 'soft'
line 173:     let s:bg0  = s:gb.dark0_soft
line 174:   elseif g:gruvbox_contrast_dark == 'hard'
line 175:     let s:bg0  = s:gb.dark0_hard
line 176:   endif
line 177: 
line 178:   let s:bg1  = s:gb.dark1
line 179:   let s:bg2  = s:gb.dark2
line 180:   let s:bg3  = s:gb.dark3
line 181:   let s:bg4  = s:gb.dark4
line 182: 
line 183:   let s:gray = s:gb.gray_245
line 184: 
line 185:   let s:fg0 = s:gb.light0
line 186:   let s:fg1 = s:gb.light1
line 187:   let s:fg2 = s:gb.light2
line 188:   let s:fg3 = s:gb.light3
line 189:   let s:fg4 = s:gb.light4
line 190: 
line 191:   let s:fg4_256 = s:gb.light4_256
line 192: 
line 193:   let s:red    = s:gb.bright_red
line 194:   let s:green  = s:gb.bright_green
line 195:   let s:yellow = s:gb.bright_yellow
line 196:   let s:blue   = s:gb.bright_blue
line 197:   let s:purple = s:gb.bright_purple
line 198:   let s:aqua   = s:gb.bright_aqua
line 199:   let s:orange = s:gb.bright_orange
line 200: else
line 201:   let s:bg0  = s:gb.light0
line 202:   if g:gruvbox_contrast_light == 'soft'
line 203:     let s:bg0  = s:gb.light0_soft
line 204:   elseif g:gruvbox_contrast_light == 'hard'
line 205:     let s:bg0  = s:gb.light0_hard
line 206:   endif
line 207: 
line 208:   let s:bg1  = s:gb.light1
line 209:   let s:bg2  = s:gb.light2
line 210:   let s:bg3  = s:gb.light3
line 211:   let s:bg4  = s:gb.light4
line 212: 
line 213:   let s:gray = s:gb.gray_244
line 214: 
line 215:   let s:fg0 = s:gb.dark0
line 216:   let s:fg1 = s:gb.dark1
line 217:   let s:fg2 = s:gb.dark2
line 218:   let s:fg3 = s:gb.dark3
line 219:   let s:fg4 = s:gb.dark4
line 220: 
line 221:   let s:fg4_256 = s:gb.dark4_256
line 222: 
line 223:   let s:red    = s:gb.faded_red
line 224:   let s:green  = s:gb.faded_green
line 225:   let s:yellow = s:gb.faded_yellow
line 226:   let s:blue   = s:gb.faded_blue
line 227:   let s:purple = s:gb.faded_purple
line 228:   let s:aqua   = s:gb.faded_aqua
line 229:   let s:orange = s:gb.faded_orange
line 230: endif
line 231: 
line 232: " reset to 16 colors fallback
line 233: if g:gruvbox_termcolors == 16
line 234:   let s:bg0[1]    = 0
line 235:   let s:fg4[1]    = 7
line 236:   let s:gray[1]   = 8
line 237:   let s:red[1]    = 9
line 238:   let s:green[1]  = 10
line 239:   let s:yellow[1] = 11
line 240:   let s:blue[1]   = 12
line 241:   let s:purple[1] = 13
line 242:   let s:aqua[1]   = 14
line 243:   let s:fg1[1]    = 15
line 244: endif
line 245: 
line 246: " save current relative colors back to palette dictionary
line 247: let s:gb.bg0 = s:bg0
line 248: let s:gb.bg1 = s:bg1
line 249: let s:gb.bg2 = s:bg2
line 250: let s:gb.bg3 = s:bg3
line 251: let s:gb.bg4 = s:bg4
line 252: 
line 253: let s:gb.gray = s:gray
line 254: 
line 255: let s:gb.fg0 = s:fg0
line 256: let s:gb.fg1 = s:fg1
line 257: let s:gb.fg2 = s:fg2
line 258: let s:gb.fg3 = s:fg3
line 259: let s:gb.fg4 = s:fg4
line 260: 
line 261: let s:gb.fg4_256 = s:fg4_256
line 262: 
line 263: let s:gb.red    = s:red
line 264: let s:gb.green  = s:green
line 265: let s:gb.yellow = s:yellow
line 266: let s:gb.blue   = s:blue
line 267: let s:gb.purple = s:purple
line 268: let s:gb.aqua   = s:aqua
line 269: let s:gb.orange = s:orange
line 270: 
line 271: " }}}
line 272: " Setup Terminal Colors For Neovim: {{{
line 273: 
line 274: if has('nvim')
line 275:   let g:terminal_color_0 = s:bg0[0]
line 276:   let g:terminal_color_8 = s:gray[0]
line 277: 
line 278:   let g:terminal_color_1 = s:gb.neutral_red[0]
line 279:   let g:terminal_color_9 = s:red[0]
line 280: 
line 281:   let g:terminal_color_2 = s:gb.neutral_green[0]
line 282:   let g:terminal_color_10 = s:green[0]
line 283: 
line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0]
line 285:   let g:terminal_color_11 = s:yellow[0]
line 286: 
line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0]
line 288:   let g:terminal_color_12 = s:blue[0]
line 289: 
line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0]
line 291:   let g:terminal_color_13 = s:purple[0]
line 292: 
line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0]
line 294:   let g:terminal_color_14 = s:aqua[0]
line 295: 
line 296:   let g:terminal_color_7 = s:fg4[0]
line 297:   let g:terminal_color_15 = s:fg1[0]
line 298: endif
line 299: 
line 300: " }}}
line 301: " Overload Setting: {{{
line 302: 
line 303: let s:hls_cursor = s:orange
line 304: if exists('g:gruvbox_hls_cursor')
line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
line 306: endif
line 307: 
line 308: let s:number_column = s:none
line 309: if exists('g:gruvbox_number_column')
line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)
line 311: endif
line 312: 
line 313: let s:sign_column = s:bg1
line 314: 
line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1
line 317:   let s:sign_column = s:number_column
line 318: else
line 319:   let g:gitgutter_override_sign_column_highlight = 0
line 320: 
line 321:   if exists('g:gruvbox_sign_column')
line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)
line 323:   endif
line 324: endif
line 325: 
line 326: let s:color_column = s:bg1
line 327: if exists('g:gruvbox_color_column')
line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)
line 329: endif
line 330: 
line 331: let s:vert_split = s:bg0
line 332: if exists('g:gruvbox_vert_split')
line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)
line 334: endif
line 335: 
line 336: let s:invert_signs = ''
line 337: if exists('g:gruvbox_invert_signs')
line 338:   if g:gruvbox_invert_signs == 1
line 339:     let s:invert_signs = s:inverse
line 340:   endif
line 341: endif
line 342: 
line 343: let s:invert_selection = s:inverse
line 344: if exists('g:gruvbox_invert_selection')
line 345:   if g:gruvbox_invert_selection == 0
line 346:     let s:invert_selection = ''
line 347:   endif
line 348: endif
line 349: 
line 350: let s:invert_tabline = ''
line 351: if exists('g:gruvbox_invert_tabline')
line 352:   if g:gruvbox_invert_tabline == 1
line 353:     let s:invert_tabline = s:inverse
line 354:   endif
line 355: endif
line 356: 
line 357: let s:italicize_comments = s:italic
line 358: if exists('g:gruvbox_italicize_comments')
line 359:   if g:gruvbox_italicize_comments == 0
line 360:     let s:italicize_comments = ''
line 361:   endif
line 362: endif
line 363: 
line 364: let s:italicize_strings = ''
line 365: if exists('g:gruvbox_italicize_strings')
line 366:   if g:gruvbox_italicize_strings == 1
line 367:     let s:italicize_strings = s:italic
line 368:   endif
line 369: endif
line 370: 
line 371: " }}}
line 372: " Highlighting Function: {{{
line 373: 
line 374: function! s:HL(group, fg, ...)
line 419: 
line 420: " }}}
line 421: " Gruvbox Hi Groups: {{{
line 422: 
line 423: " memoize common hi groups
line 424: call s:HL('GruvboxFg0', s:fg0)
calling function <SNR>14_HL('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 425: call s:HL('GruvboxFg1', s:fg1)
calling function <SNR>14_HL('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 426: call s:HL('GruvboxFg2', s:fg2)
calling function <SNR>14_HL('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 427: call s:HL('GruvboxFg3', s:fg3)
calling function <SNR>14_HL('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 428: call s:HL('GruvboxFg4', s:fg4)
calling function <SNR>14_HL('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 429: call s:HL('GruvboxGray', s:gray)
calling function <SNR>14_HL('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 430: call s:HL('GruvboxBg0', s:bg0)
calling function <SNR>14_HL('GruvboxBg0', ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg0 guifg=#282828 ctermfg=235 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 431: call s:HL('GruvboxBg1', s:bg1)
calling function <SNR>14_HL('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 432: call s:HL('GruvboxBg2', s:bg2)
calling function <SNR>14_HL('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 433: call s:HL('GruvboxBg3', s:bg3)
calling function <SNR>14_HL('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 434: call s:HL('GruvboxBg4', s:bg4)
calling function <SNR>14_HL('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 435: 
line 436: call s:HL('GruvboxRed', s:red)
calling function <SNR>14_HL('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
calling function <SNR>14_HL('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 438: call s:HL('GruvboxGreen', s:green)
calling function <SNR>14_HL('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
calling function <SNR>14_HL('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 440: call s:HL('GruvboxYellow', s:yellow)
calling function <SNR>14_HL('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
calling function <SNR>14_HL('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 442: call s:HL('GruvboxBlue', s:blue)
calling function <SNR>14_HL('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
calling function <SNR>14_HL('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 444: call s:HL('GruvboxPurple', s:purple)
calling function <SNR>14_HL('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
calling function <SNR>14_HL('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 446: call s:HL('GruvboxAqua', s:aqua)
calling function <SNR>14_HL('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
calling function <SNR>14_HL('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 448: call s:HL('GruvboxOrange', s:orange)
calling function <SNR>14_HL('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
calling function <SNR>14_HL('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 450: 
line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 457: 
line 458: " }}}
line 459: 
line 460: " Vanilla colorscheme ---------------------------------------------------------
line 461: " General UI: {{{
line 462: 
line 463: " Normal text
line 464: call s:HL('Normal', s:fg1, s:bg0)
calling function <SNR>14_HL('Normal', ['#ebdbb2', 223], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 465: 
line 466: " Correct background (see issue #7):
line 467: " --- Problem with changing between dark and light on 256 color terminal
line 468: " --- https://github.com/morhetz/gruvbox/issues/7
line 469: if s:is_dark
line 470:   set background=dark
line 471: else
line 472:   set background=light
line 473: endif
line 474: 
line 475: if version >= 700
line 476:   " Screen line that the cursor is
line 477:   call s:HL('CursorLine',   s:none, s:bg1)
calling function <SNR>14_HL('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 478:   " Screen column that the cursor is
line 479:   hi! link CursorColumn CursorLine
line 480: 
line 481:   " Tab pages line filler
line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 483:   " Active tab page label
line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 485:   " Not active tab page label
line 486:   hi! link TabLine TabLineFill
line 487: 
line 488:   " Match paired bracket under the cursor
line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)
calling function <SNR>14_HL('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 490: endif
line 491: 
line 492: if version >= 703
line 493:   " Highlighted screen columns
line 494:   call s:HL('ColorColumn',  s:none, s:color_column)
calling function <SNR>14_HL('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 495: 
line 496:   " Concealed element: \lambda  
line 497:   call s:HL('Conceal', s:blue, s:none)
calling function <SNR>14_HL('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 498: 
line 499:   " Line number of CursorLine
line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)
calling function <SNR>14_HL('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 501: endif
line 502: 
line 503: hi! link NonText GruvboxBg2
line 504: hi! link SpecialKey GruvboxBg2
line 505: 
line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
calling function <SNR>14_HL('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 507: hi! link VisualNOS Visual
line 508: 
line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('Search', ['#fabd2f', 214], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
calling function <SNR>14_HL('IncSearch', ['#fe8019', 208], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 511: 
line 512: call s:HL('Underlined', s:blue, s:none, s:underline)
calling function <SNR>14_HL('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 513: 
line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)
calling function <SNR>14_HL('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)
calling function <SNR>14_HL('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 516: 
line 517: " The column separating vertically split windows
line 518: call s:HL('VertSplit', s:bg3, s:vert_split)
calling function <SNR>14_HL('VertSplit', ['#665c54', 241], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 519: 
line 520: " Current match in wildmenu completion
line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 522: 
line 523: " Directory names, special names in listing
line 524: hi! link Directory GruvboxGreenBold
line 525: 
line 526: " Titles for output from :set all, :autocmd, etc.
line 527: hi! link Title GruvboxGreenBold
line 528: 
line 529: " Error messages on the command line
line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
calling function <SNR>14_HL('ErrorMsg', ['#282828', 235], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ErrorMsg guifg=#282828 ctermfg=235 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 531: " More prompt: -- More --
line 532: hi! link MoreMsg GruvboxYellowBold
line 533: " Current mode message: -- INSERT --
line 534: hi! link ModeMsg GruvboxYellowBold
line 535: " 'Press enter' prompt and yes/no questions
line 536: hi! link Question GruvboxOrangeBold
line 537: " Warning messages
line 538: hi! link WarningMsg GruvboxRedBold
line 539: 
line 540: " }}}
line 541: " Gutter: {{{
line 542: 
line 543: " Line number for :number and :# commands
line 544: call s:HL('LineNr', s:bg4, s:number_column)
calling function <SNR>14_HL('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 545: 
line 546: " Column where signs are displayed
line 547: call s:HL('SignColumn', s:none, s:sign_column)
calling function <SNR>14_HL('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 548: 
line 549: " Line used for closed folds
line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)
calling function <SNR>14_HL('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 551: " Column where folds are displayed
line 552: call s:HL('FoldColumn', s:gray, s:bg1)
calling function <SNR>14_HL('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 553: 
line 554: " }}}
line 555: " Cursor: {{{
line 556: 
line 557: " Character under cursor
line 558: call s:HL('Cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 559: " Visual mode cursor, selection
line 560: hi! link vCursor Cursor
line 561: " Input moder cursor
line 562: hi! link iCursor Cursor
line 563: " Language mapping cursor
line 564: hi! link lCursor Cursor
line 565: 
line 566: " }}}
line 567: " Syntax Highlighting: {{{
line 568: 
line 569: if g:gruvbox_improved_strings == 0
line 570:   hi! link Special GruvboxOrange
line 571: else
line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)
line 573: endif
line 574: 
line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)
calling function <SNR>14_HL('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
calling function <SNR>14_HL('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 578: 
line 579: " Generic statement
line 580: hi! link Statement GruvboxRed
line 581: " if, then, else, endif, swicth, etc.
line 582: hi! link Conditional GruvboxRed
line 583: " for, do, while, etc.
line 584: hi! link Repeat GruvboxRed
line 585: " case, default, etc.
line 586: hi! link Label GruvboxRed
line 587: " try, catch, throw
line 588: hi! link Exception GruvboxRed
line 589: " sizeof, "+", "*", etc.
line 590: hi! link Operator Normal
line 591: " Any other keyword
line 592: hi! link Keyword GruvboxRed
line 593: 
line 594: " Variable name
line 595: hi! link Identifier GruvboxBlue
line 596: " Function name
line 597: hi! link Function GruvboxGreenBold
line 598: 
line 599: " Generic preprocessor
line 600: hi! link PreProc GruvboxAqua
line 601: " Preprocessor #include
line 602: hi! link Include GruvboxAqua
line 603: " Preprocessor #define
line 604: hi! link Define GruvboxAqua
line 605: " Same as Define
line 606: hi! link Macro GruvboxAqua
line 607: " Preprocessor #if, #else, #endif, etc.
line 608: hi! link PreCondit GruvboxAqua
line 609: 
line 610: " Generic constant
line 611: hi! link Constant GruvboxPurple
line 612: " Character constant: 'c', '/n'
line 613: hi! link Character GruvboxPurple
line 614: " String constant: "this is a string"
line 615: if g:gruvbox_improved_strings == 0
line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)
calling function <SNR>14_HL('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 617: else
line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)
line 619: endif
line 620: " Boolean constant: TRUE, false
line 621: hi! link Boolean GruvboxPurple
line 622: " Number constant: 234, 0xff
line 623: hi! link Number GruvboxPurple
line 624: " Floating point constant: 2.3e10
line 625: hi! link Float GruvboxPurple
line 626: 
line 627: " Generic type
line 628: hi! link Type GruvboxYellow
line 629: " static, register, volatile, etc
line 630: hi! link StorageClass GruvboxOrange
line 631: " struct, union, enum, etc.
line 632: hi! link Structure GruvboxAqua
line 633: " typedef
line 634: hi! link Typedef GruvboxYellow
line 635: 
line 636: " }}}
line 637: " Completion Menu: {{{
line 638: 
line 639: if version >= 700
line 640:   " Popup menu: normal item
line 641:   call s:HL('Pmenu', s:fg1, s:bg2)
calling function <SNR>14_HL('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 642:   " Popup menu: selected item
line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
calling function <SNR>14_HL('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 644:   " Popup menu: scrollbar
line 645:   call s:HL('PmenuSbar', s:none, s:bg2)
calling function <SNR>14_HL('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 646:   " Popup menu: scrollbar thumb
line 647:   call s:HL('PmenuThumb', s:none, s:bg4)
calling function <SNR>14_HL('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 648: endif
line 649: 
line 650: " }}}
line 651: " Diffs: {{{
line 652: 
line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffDelete', ['#fb4934', 167], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffAdd', ['#b8bb26', 142], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 655: "call s:HL('DiffChange', s:bg0, s:blue)
line 656: "call s:HL('DiffText',   s:bg0, s:yellow)
line 657: 
line 658: " Alternative setting
line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffChange', ['#8ec07c', 108], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffText', ['#fabd2f', 214], ['#282828', 235], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#282828 ctermbg=235 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 661: 
line 662: " }}}
line 663: " Spelling: {{{
line 664: 
line 665: if has("spell")
line 666:   " Not capitalised word, or compile warnings
line 667:   if g:gruvbox_improved_warnings == 0
line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 669:   else
line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
line 671:   endif
line 672:   " Not recognized word
line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 674:   " Wrong spelling for selected region
line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
calling function <SNR>14_HL('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 676:   " Rare word
line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
calling function <SNR>14_HL('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 678: endif
line 679: 
line 680: " }}}
line 681: 
line 682: " Plugin specific -------------------------------------------------------------
line 683: " EasyMotion: {{{
line 684: 
line 685: hi! link EasyMotionTarget Search
line 686: hi! link EasyMotionShade Comment
line 687: 
line 688: " }}}
line 689: " Sneak: {{{
line 690: 
line 691: hi! link Sneak Search
line 692: hi! link SneakLabel Search
line 693: 
line 694: " }}}
line 695: " Indent Guides: {{{
line 696: 
line 697: if !exists('g:indent_guides_auto_colors')
line 698:   let g:indent_guides_auto_colors = 0
line 699: endif
line 700: 
line 701: if g:indent_guides_auto_colors == 0
line 702:   if g:gruvbox_invert_indent_guides == 0
line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
calling function <SNR>14_HL('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
calling function <SNR>14_HL('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 705:   else
line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
line 708:   endif
line 709: endif
line 710: 
line 711: " }}}
line 712: " IndentLine: {{{
line 713: 
line 714: if !exists('g:indentLine_color_term')
line 715:   let g:indentLine_color_term = s:bg2[1]
line 716: endif
line 717: if !exists('g:indentLine_color_gui')
line 718:   let g:indentLine_color_gui = s:bg2[0]
line 719: endif
line 720: 
line 721: " }}}
line 722: " Rainbow Parentheses: {{{
line 723: 
line 724: if !exists('g:rbpt_colorpairs')
line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ]
line 730: endif
line 731: 
line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
line 734: 
line 735: if !exists('g:rainbow_conf')
line 736:    let g:rainbow_conf = {}
line 737: endif
line 738: if !has_key(g:rainbow_conf, 'guifgs')
line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
line 740: endif
line 741: if !has_key(g:rainbow_conf, 'ctermfgs')
line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
line 743: endif
line 744: 
line 745: let g:niji_dark_colours = g:rbpt_colorpairs
line 746: let g:niji_light_colours = g:rbpt_colorpairs
line 747: 
line 748: "}}}
line 749: " GitGutter: {{{
line 750: 
line 751: hi! link GitGutterAdd GruvboxGreenSign
line 752: hi! link GitGutterChange GruvboxAquaSign
line 753: hi! link GitGutterDelete GruvboxRedSign
line 754: hi! link GitGutterChangeDelete GruvboxAquaSign
line 755: 
line 756: " }}}
line 757: " GitCommit: "{{{
line 758: 
line 759: hi! link gitcommitSelectedFile GruvboxGreen
line 760: hi! link gitcommitDiscardedFile GruvboxRed
line 761: 
line 762: " }}}
line 763: " Signify: {{{
line 764: 
line 765: hi! link SignifySignAdd GruvboxGreenSign
line 766: hi! link SignifySignChange GruvboxAquaSign
line 767: hi! link SignifySignDelete GruvboxRedSign
line 768: 
line 769: " }}}
line 770: " Syntastic: {{{
line 771: 
line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 774: 
line 775: hi! link SyntasticErrorSign GruvboxRedSign
line 776: hi! link SyntasticWarningSign GruvboxYellowSign
line 777: 
line 778: " }}}
line 779: " Signature: {{{
line 780: hi! link SignatureMarkText   GruvboxBlueSign
line 781: hi! link SignatureMarkerText GruvboxPurpleSign
line 782: 
line 783: " }}}
line 784: " ShowMarks: {{{
line 785: 
line 786: hi! link ShowMarksHLl GruvboxBlueSign
line 787: hi! link ShowMarksHLu GruvboxBlueSign
line 788: hi! link ShowMarksHLo GruvboxBlueSign
line 789: hi! link ShowMarksHLm GruvboxBlueSign
line 790: 
line 791: " }}}
line 792: " CtrlP: {{{
line 793: 
line 794: hi! link CtrlPMatch GruvboxYellow
line 795: hi! link CtrlPNoEntries GruvboxRed
line 796: hi! link CtrlPPrtBase GruvboxBg2
line 797: hi! link CtrlPPrtCursor GruvboxBlue
line 798: hi! link CtrlPLinePre GruvboxBg2
line 799: 
line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
calling function <SNR>14_HL('CtrlPMode2', ['#282828', 235], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode2 guifg=#282828 ctermfg=235 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 803: 
line 804: " }}}
line 805: " Startify: {{{
line 806: 
line 807: hi! link StartifyBracket GruvboxFg3
line 808: hi! link StartifyFile GruvboxFg1
line 809: hi! link StartifyNumber GruvboxBlue
line 810: hi! link StartifyPath GruvboxGray
line 811: hi! link StartifySlash GruvboxGray
line 812: hi! link StartifySection GruvboxYellow
line 813: hi! link StartifySpecial GruvboxBg2
line 814: hi! link StartifyHeader GruvboxOrange
line 815: hi! link StartifyFooter GruvboxBg2
line 816: 
line 817: " }}}
line 818: " Vimshell: {{{
line 819: 
line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ]
line 826: 
line 827: " }}}
line 828: " BufTabLine: {{{
line 829: 
line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
calling function <SNR>14_HL('BufTabLineCurrent', ['#282828', 235], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineCurrent guifg=#282828 ctermfg=235 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)
calling function <SNR>14_HL('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)
calling function <SNR>14_HL('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)
calling function <SNR>14_HL('BufTabLineFill', ['#282828', 235], ['#282828', 235])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineFill guifg=#282828 ctermfg=235 guibg=#282828 ctermbg=235 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 834: 
line 835: " }}}
line 836: " Asynchronous Lint Engine: {{{
line 837: 
line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 841: 
line 842: hi! link ALEErrorSign GruvboxRedSign
line 843: hi! link ALEWarningSign GruvboxYellowSign
line 844: hi! link ALEInfoSign GruvboxBlueSign
line 845: 
line 846: " }}}
line 847: " Dirvish: {{{
line 848: 
line 849: hi! link DirvishPathTail GruvboxAqua
line 850: hi! link DirvishArg GruvboxYellow
line 851: 
line 852: " }}}
line 853: " Netrw: {{{
line 854: 
line 855: hi! link netrwDir GruvboxAqua
line 856: hi! link netrwClassify GruvboxAqua
line 857: hi! link netrwLink GruvboxGray
line 858: hi! link netrwSymLink GruvboxFg1
line 859: hi! link netrwExe GruvboxYellow
line 860: hi! link netrwComment GruvboxGray
line 861: hi! link netrwList GruvboxBlue
line 862: hi! link netrwHelpCmd GruvboxAqua
line 863: hi! link netrwCmdSep GruvboxFg3
line 864: hi! link netrwVersion GruvboxGreen
line 865: 
line 866: " }}}
line 867: " NERDTree: {{{
line 868: 
line 869: hi! link NERDTreeDir GruvboxAqua
line 870: hi! link NERDTreeDirSlash GruvboxAqua
line 871: 
line 872: hi! link NERDTreeOpenable GruvboxOrange
line 873: hi! link NERDTreeClosable GruvboxOrange
line 874: 
line 875: hi! link NERDTreeFile GruvboxFg1
line 876: hi! link NERDTreeExecFile GruvboxYellow
line 877: 
line 878: hi! link NERDTreeUp GruvboxGray
line 879: hi! link NERDTreeCWD GruvboxGreen
line 880: hi! link NERDTreeHelp GruvboxFg1
line 881: 
line 882: hi! link NERDTreeToggleOn GruvboxGreen
line 883: hi! link NERDTreeToggleOff GruvboxRed
line 884: 
line 885: " }}}
line 886: " Vim Multiple Cursors: {{{
line 887: 
line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)
calling function <SNR>14_HL('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 890: 
line 891: " }}}
line 892: 
line 893: " Filetype specific -----------------------------------------------------------
line 894: " Diff: {{{
line 895: 
line 896: hi! link diffAdded GruvboxGreen
line 897: hi! link diffRemoved GruvboxRed
line 898: hi! link diffChanged GruvboxAqua
line 899: 
line 900: hi! link diffFile GruvboxOrange
line 901: hi! link diffNewFile GruvboxYellow
line 902: 
line 903: hi! link diffLine GruvboxBlue
line 904: 
line 905: " }}}
line 906: " Html: {{{
line 907: 
line 908: hi! link htmlTag GruvboxBlue
line 909: hi! link htmlEndTag GruvboxBlue
line 910: 
line 911: hi! link htmlTagName GruvboxAquaBold
line 912: hi! link htmlArg GruvboxAqua
line 913: 
line 914: hi! link htmlScriptTag GruvboxPurple
line 915: hi! link htmlTagN GruvboxFg1
line 916: hi! link htmlSpecialTagName GruvboxAquaBold
line 917: 
line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)
calling function <SNR>14_HL('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 919: 
line 920: hi! link htmlSpecialChar GruvboxOrange
line 921: 
line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
calling function <SNR>14_HL('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
calling function <SNR>14_HL('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
calling function <SNR>14_HL('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 926: 
line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
calling function <SNR>14_HL('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
calling function <SNR>14_HL('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
calling function <SNR>14_HL('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 930: 
line 931: " }}}
line 932: " Xml: {{{
line 933: 
line 934: hi! link xmlTag GruvboxBlue
line 935: hi! link xmlEndTag GruvboxBlue
line 936: hi! link xmlTagName GruvboxBlue
line 937: hi! link xmlEqual GruvboxBlue
line 938: hi! link docbkKeyword GruvboxAquaBold
line 939: 
line 940: hi! link xmlDocTypeDecl GruvboxGray
line 941: hi! link xmlDocTypeKeyword GruvboxPurple
line 942: hi! link xmlCdataStart GruvboxGray
line 943: hi! link xmlCdataCdata GruvboxPurple
line 944: hi! link dtdFunction GruvboxGray
line 945: hi! link dtdTagName GruvboxPurple
line 946: 
line 947: hi! link xmlAttrib GruvboxAqua
line 948: hi! link xmlProcessingDelim GruvboxGray
line 949: hi! link dtdParamEntityPunct GruvboxGray
line 950: hi! link dtdParamEntityDPunct GruvboxGray
line 951: hi! link xmlAttribPunct GruvboxGray
line 952: 
line 953: hi! link xmlEntity GruvboxOrange
line 954: hi! link xmlEntityPunct GruvboxOrange
line 955: " }}}
line 956: " Vim: {{{
line 957: 
line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
calling function <SNR>14_HL('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 959: 
line 960: hi! link vimNotation GruvboxOrange
line 961: hi! link vimBracket GruvboxOrange
line 962: hi! link vimMapModKey GruvboxOrange
line 963: hi! link vimFuncSID GruvboxFg3
line 964: hi! link vimSetSep GruvboxFg3
line 965: hi! link vimSep GruvboxFg3
line 966: hi! link vimContinue GruvboxFg3
line 967: 
line 968: " }}}
line 969: " Clojure: {{{
line 970: 
line 971: hi! link clojureKeyword GruvboxBlue
line 972: hi! link clojureCond GruvboxOrange
line 973: hi! link clojureSpecial GruvboxOrange
line 974: hi! link clojureDefine GruvboxOrange
line 975: 
line 976: hi! link clojureFunc GruvboxYellow
line 977: hi! link clojureRepeat GruvboxYellow
line 978: hi! link clojureCharacter GruvboxAqua
line 979: hi! link clojureStringEscape GruvboxAqua
line 980: hi! link clojureException GruvboxRed
line 981: 
line 982: hi! link clojureRegexp GruvboxAqua
line 983: hi! link clojureRegexpEscape GruvboxAqua
line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
calling function <SNR>14_HL('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 985: hi! link clojureRegexpMod clojureRegexpCharClass
line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass
line 987: 
line 988: hi! link clojureParen GruvboxFg3
line 989: hi! link clojureAnonArg GruvboxYellow
line 990: hi! link clojureVariable GruvboxBlue
line 991: hi! link clojureMacro GruvboxOrange
line 992: 
line 993: hi! link clojureMeta GruvboxYellow
line 994: hi! link clojureDeref GruvboxYellow
line 995: hi! link clojureQuote GruvboxYellow
line 996: hi! link clojureUnquote GruvboxYellow
line 997: 
line 998: " }}}
line 999: " C: {{{
line 1000: 
line 1001: hi! link cOperator GruvboxPurple
line 1002: hi! link cStructure GruvboxOrange
line 1003: 
line 1004: " }}}
line 1005: " Python: {{{
line 1006: 
line 1007: hi! link pythonBuiltin GruvboxOrange
line 1008: hi! link pythonBuiltinObj GruvboxOrange
line 1009: hi! link pythonBuiltinFunc GruvboxOrange
line 1010: hi! link pythonFunction GruvboxAqua
line 1011: hi! link pythonDecorator GruvboxRed
line 1012: hi! link pythonInclude GruvboxBlue
line 1013: hi! link pythonImport GruvboxBlue
line 1014: hi! link pythonRun GruvboxBlue
line 1015: hi! link pythonCoding GruvboxBlue
line 1016: hi! link pythonOperator GruvboxRed
line 1017: hi! link pythonException GruvboxRed
line 1018: hi! link pythonExceptions GruvboxPurple
line 1019: hi! link pythonBoolean GruvboxPurple
line 1020: hi! link pythonDot GruvboxFg3
line 1021: hi! link pythonConditional GruvboxRed
line 1022: hi! link pythonRepeat GruvboxRed
line 1023: hi! link pythonDottedName GruvboxGreenBold
line 1024: 
line 1025: " }}}
line 1026: " CSS: {{{
line 1027: 
line 1028: hi! link cssBraces GruvboxBlue
line 1029: hi! link cssFunctionName GruvboxYellow
line 1030: hi! link cssIdentifier GruvboxOrange
line 1031: hi! link cssClassName GruvboxGreen
line 1032: hi! link cssColor GruvboxBlue
line 1033: hi! link cssSelectorOp GruvboxBlue
line 1034: hi! link cssSelectorOp2 GruvboxBlue
line 1035: hi! link cssImportant GruvboxGreen
line 1036: hi! link cssVendor GruvboxFg1
line 1037: 
line 1038: hi! link cssTextProp GruvboxAqua
line 1039: hi! link cssAnimationProp GruvboxAqua
line 1040: hi! link cssUIProp GruvboxYellow
line 1041: hi! link cssTransformProp GruvboxAqua
line 1042: hi! link cssTransitionProp GruvboxAqua
line 1043: hi! link cssPrintProp GruvboxAqua
line 1044: hi! link cssPositioningProp GruvboxYellow
line 1045: hi! link cssBoxProp GruvboxAqua
line 1046: hi! link cssFontDescriptorProp GruvboxAqua
line 1047: hi! link cssFlexibleBoxProp GruvboxAqua
line 1048: hi! link cssBorderOutlineProp GruvboxAqua
line 1049: hi! link cssBackgroundProp GruvboxAqua
line 1050: hi! link cssMarginProp GruvboxAqua
line 1051: hi! link cssListProp GruvboxAqua
line 1052: hi! link cssTableProp GruvboxAqua
line 1053: hi! link cssFontProp GruvboxAqua
line 1054: hi! link cssPaddingProp GruvboxAqua
line 1055: hi! link cssDimensionProp GruvboxAqua
line 1056: hi! link cssRenderProp GruvboxAqua
line 1057: hi! link cssColorProp GruvboxAqua
line 1058: hi! link cssGeneratedContentProp GruvboxAqua
line 1059: 
line 1060: " }}}
line 1061: " JavaScript: {{{
line 1062: 
line 1063: hi! link javaScriptBraces GruvboxFg1
line 1064: hi! link javaScriptFunction GruvboxAqua
line 1065: hi! link javaScriptIdentifier GruvboxRed
line 1066: hi! link javaScriptMember GruvboxBlue
line 1067: hi! link javaScriptNumber GruvboxPurple
line 1068: hi! link javaScriptNull GruvboxPurple
line 1069: hi! link javaScriptParens GruvboxFg3
line 1070: 
line 1071: " }}}
line 1072: " YAJS: {{{
line 1073: 
line 1074: hi! link javascriptImport GruvboxAqua
line 1075: hi! link javascriptExport GruvboxAqua
line 1076: hi! link javascriptClassKeyword GruvboxAqua
line 1077: hi! link javascriptClassExtends GruvboxAqua
line 1078: hi! link javascriptDefault GruvboxAqua
line 1079: 
line 1080: hi! link javascriptClassName GruvboxYellow
line 1081: hi! link javascriptClassSuperName GruvboxYellow
line 1082: hi! link javascriptGlobal GruvboxYellow
line 1083: 
line 1084: hi! link javascriptEndColons GruvboxFg1
line 1085: hi! link javascriptFuncArg GruvboxFg1
line 1086: hi! link javascriptGlobalMethod GruvboxFg1
line 1087: hi! link javascriptNodeGlobal GruvboxFg1
line 1088: hi! link javascriptBOMWindowProp GruvboxFg1
line 1089: hi! link javascriptArrayMethod GruvboxFg1
line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1
line 1091: hi! link javascriptCacheMethod GruvboxFg1
line 1092: hi! link javascriptDateMethod GruvboxFg1
line 1093: hi! link javascriptMathStaticMethod GruvboxFg1
line 1094: 
line 1095: " hi! link javascriptProp GruvboxFg1
line 1096: hi! link javascriptURLUtilsProp GruvboxFg1
line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1
line 1098: hi! link javascriptDOMDocMethod GruvboxFg1
line 1099: hi! link javascriptDOMDocProp GruvboxFg1
line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1
line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1
line 1102: hi! link javascriptStringMethod GruvboxFg1
line 1103: 
line 1104: hi! link javascriptVariable GruvboxOrange
line 1105: " hi! link javascriptVariable GruvboxRed
line 1106: " hi! link javascriptIdentifier GruvboxOrange
line 1107: " hi! link javascriptClassSuper GruvboxOrange
line 1108: hi! link javascriptIdentifier GruvboxOrange
line 1109: hi! link javascriptClassSuper GruvboxOrange
line 1110: 
line 1111: " hi! link javascriptFuncKeyword GruvboxOrange
line 1112: " hi! link javascriptAsyncFunc GruvboxOrange
line 1113: hi! link javascriptFuncKeyword GruvboxAqua
line 1114: hi! link javascriptAsyncFunc GruvboxAqua
line 1115: hi! link javascriptClassStatic GruvboxOrange
line 1116: 
line 1117: hi! link javascriptOperator GruvboxRed
line 1118: hi! link javascriptForOperator GruvboxRed
line 1119: hi! link javascriptYield GruvboxRed
line 1120: hi! link javascriptExceptions GruvboxRed
line 1121: hi! link javascriptMessage GruvboxRed
line 1122: 
line 1123: hi! link javascriptTemplateSB GruvboxAqua
line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1
line 1125: 
line 1126: " hi! link javascriptLabel GruvboxBlue
line 1127: " hi! link javascriptObjectLabel GruvboxBlue
line 1128: " hi! link javascriptPropertyName GruvboxBlue
line 1129: hi! link javascriptLabel GruvboxFg1
line 1130: hi! link javascriptObjectLabel GruvboxFg1
line 1131: hi! link javascriptPropertyName GruvboxFg1
line 1132: 
line 1133: hi! link javascriptLogicSymbols GruvboxFg1
line 1134: hi! link javascriptArrowFunc GruvboxYellow
line 1135: 
line 1136: hi! link javascriptDocParamName GruvboxFg4
line 1137: hi! link javascriptDocTags GruvboxFg4
line 1138: hi! link javascriptDocNotation GruvboxFg4
line 1139: hi! link javascriptDocParamType GruvboxFg4
line 1140: hi! link javascriptDocNamedParamType GruvboxFg4
line 1141: 
line 1142: hi! link javascriptBrackets GruvboxFg1
line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1
line 1144: hi! link javascriptDOMEventMethod GruvboxFg1
line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1
line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1
line 1147: hi! link javascriptHeadersMethod GruvboxFg1
line 1148: 
line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed
line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed
line 1151: 
line 1152: " }}}
line 1153: " PanglossJS: {{{
line 1154: 
line 1155: hi! link jsClassKeyword GruvboxAqua
line 1156: hi! link jsExtendsKeyword GruvboxAqua
line 1157: hi! link jsExportDefault GruvboxAqua
line 1158: hi! link jsTemplateBraces GruvboxAqua
line 1159: hi! link jsGlobalNodeObjects GruvboxFg1
line 1160: hi! link jsGlobalObjects GruvboxFg1
line 1161: hi! link jsFunction GruvboxAqua
line 1162: hi! link jsFuncParens GruvboxFg3
line 1163: hi! link jsParens GruvboxFg3
line 1164: hi! link jsNull GruvboxPurple
line 1165: hi! link jsUndefined GruvboxPurple
line 1166: hi! link jsClassDefinition GruvboxYellow
line 1167: 
line 1168: " }}}
line 1169: " TypeScript: {{{
line 1170: 
line 1171: hi! link typeScriptReserved GruvboxAqua
line 1172: hi! link typeScriptLabel GruvboxAqua
line 1173: hi! link typeScriptFuncKeyword GruvboxAqua
line 1174: hi! link typeScriptIdentifier GruvboxOrange
line 1175: hi! link typeScriptBraces GruvboxFg1
line 1176: hi! link typeScriptEndColons GruvboxFg1
line 1177: hi! link typeScriptDOMObjects GruvboxFg1
line 1178: hi! link typeScriptAjaxMethods GruvboxFg1
line 1179: hi! link typeScriptLogicSymbols GruvboxFg1
line 1180: hi! link typeScriptDocSeeTag Comment
line 1181: hi! link typeScriptDocParam Comment
line 1182: hi! link typeScriptDocTags vimCommentTitle
line 1183: hi! link typeScriptGlobalObjects GruvboxFg1
line 1184: hi! link typeScriptParens GruvboxFg3
line 1185: hi! link typeScriptOpSymbols GruvboxFg3
line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1
line 1187: hi! link typeScriptNull GruvboxPurple
line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua
line 1189: 
line 1190: " }}}
line 1191: " PureScript: {{{
line 1192: 
line 1193: hi! link purescriptModuleKeyword GruvboxAqua
line 1194: hi! link purescriptModuleName GruvboxFg1
line 1195: hi! link purescriptWhere GruvboxAqua
line 1196: hi! link purescriptDelimiter GruvboxFg4
line 1197: hi! link purescriptType GruvboxFg1
line 1198: hi! link purescriptImportKeyword GruvboxAqua
line 1199: hi! link purescriptHidingKeyword GruvboxAqua
line 1200: hi! link purescriptAsKeyword GruvboxAqua
line 1201: hi! link purescriptStructure GruvboxAqua
line 1202: hi! link purescriptOperator GruvboxBlue
line 1203: 
line 1204: hi! link purescriptTypeVar GruvboxFg1
line 1205: hi! link purescriptConstructor GruvboxFg1
line 1206: hi! link purescriptFunction GruvboxFg1
line 1207: hi! link purescriptConditional GruvboxOrange
line 1208: hi! link purescriptBacktick GruvboxOrange
line 1209: 
line 1210: " }}}
line 1211: " CoffeeScript: {{{
line 1212: 
line 1213: hi! link coffeeExtendedOp GruvboxFg3
line 1214: hi! link coffeeSpecialOp GruvboxFg3
line 1215: hi! link coffeeCurly GruvboxOrange
line 1216: hi! link coffeeParen GruvboxFg3
line 1217: hi! link coffeeBracket GruvboxOrange
line 1218: 
line 1219: " }}}
line 1220: " Ruby: {{{
line 1221: 
line 1222: hi! link rubyStringDelimiter GruvboxGreen
line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua
line 1224: 
line 1225: " }}}
line 1226: " ObjectiveC: {{{
line 1227: 
line 1228: hi! link objcTypeModifier GruvboxRed
line 1229: hi! link objcDirective GruvboxBlue
line 1230: 
line 1231: " }}}
line 1232: " Go: {{{
line 1233: 
line 1234: hi! link goDirective GruvboxAqua
line 1235: hi! link goConstants GruvboxPurple
line 1236: hi! link goDeclaration GruvboxRed
line 1237: hi! link goDeclType GruvboxBlue
line 1238: hi! link goBuiltins GruvboxOrange
line 1239: 
line 1240: " }}}
line 1241: " Lua: {{{
line 1242: 
line 1243: hi! link luaIn GruvboxRed
line 1244: hi! link luaFunction GruvboxAqua
line 1245: hi! link luaTable GruvboxOrange
line 1246: 
line 1247: " }}}
line 1248: " MoonScript: {{{
line 1249: 
line 1250: hi! link moonSpecialOp GruvboxFg3
line 1251: hi! link moonExtendedOp GruvboxFg3
line 1252: hi! link moonFunction GruvboxFg3
line 1253: hi! link moonObject GruvboxYellow
line 1254: 
line 1255: " }}}
line 1256: " Java: {{{
line 1257: 
line 1258: hi! link javaAnnotation GruvboxBlue
line 1259: hi! link javaDocTags GruvboxAqua
line 1260: hi! link javaCommentTitle vimCommentTitle
line 1261: hi! link javaParen GruvboxFg3
line 1262: hi! link javaParen1 GruvboxFg3
line 1263: hi! link javaParen2 GruvboxFg3
line 1264: hi! link javaParen3 GruvboxFg3
line 1265: hi! link javaParen4 GruvboxFg3
line 1266: hi! link javaParen5 GruvboxFg3
line 1267: hi! link javaOperator GruvboxOrange
line 1268: 
line 1269: hi! link javaVarArg GruvboxGreen
line 1270: 
line 1271: " }}}
line 1272: " Elixir: {{{
line 1273: 
line 1274: hi! link elixirDocString Comment
line 1275: 
line 1276: hi! link elixirStringDelimiter GruvboxGreen
line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua
line 1278: 
line 1279: hi! link elixirModuleDeclaration GruvboxYellow
line 1280: 
line 1281: " }}}
line 1282: " Scala: {{{
line 1283: 
line 1284: " NB: scala vim syntax file is kinda horrible
line 1285: hi! link scalaNameDefinition GruvboxFg1
line 1286: hi! link scalaCaseFollowing GruvboxFg1
line 1287: hi! link scalaCapitalWord GruvboxFg1
line 1288: hi! link scalaTypeExtension GruvboxFg1
line 1289: 
line 1290: hi! link scalaKeyword GruvboxRed
line 1291: hi! link scalaKeywordModifier GruvboxRed
line 1292: 
line 1293: hi! link scalaSpecial GruvboxAqua
line 1294: hi! link scalaOperator GruvboxFg1
line 1295: 
line 1296: hi! link scalaTypeDeclaration GruvboxYellow
line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow
line 1298: 
line 1299: hi! link scalaInstanceDeclaration GruvboxFg1
line 1300: hi! link scalaInterpolation GruvboxAqua
line 1301: 
line 1302: " }}}
line 1303: " Markdown: {{{
line 1304: 
line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)
calling function <SNR>14_HL('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1306: 
line 1307: hi! link markdownH1 GruvboxGreenBold
line 1308: hi! link markdownH2 GruvboxGreenBold
line 1309: hi! link markdownH3 GruvboxYellowBold
line 1310: hi! link markdownH4 GruvboxYellowBold
line 1311: hi! link markdownH5 GruvboxYellow
line 1312: hi! link markdownH6 GruvboxYellow
line 1313: 
line 1314: hi! link markdownCode GruvboxAqua
line 1315: hi! link markdownCodeBlock GruvboxAqua
line 1316: hi! link markdownCodeDelimiter GruvboxAqua
line 1317: 
line 1318: hi! link markdownBlockquote GruvboxGray
line 1319: hi! link markdownListMarker GruvboxGray
line 1320: hi! link markdownOrderedListMarker GruvboxGray
line 1321: hi! link markdownRule GruvboxGray
line 1322: hi! link markdownHeadingRule GruvboxGray
line 1323: 
line 1324: hi! link markdownUrlDelimiter GruvboxFg3
line 1325: hi! link markdownLinkDelimiter GruvboxFg3
line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3
line 1327: 
line 1328: hi! link markdownHeadingDelimiter GruvboxOrange
line 1329: hi! link markdownUrl GruvboxPurple
line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen
line 1331: 
line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)
calling function <SNR>14_HL('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1333: hi! link markdownIdDeclaration markdownLinkText
line 1334: 
line 1335: " }}}
line 1336: " Haskell: {{{
line 1337: 
line 1338: " hi! link haskellType GruvboxYellow
line 1339: " hi! link haskellOperators GruvboxOrange
line 1340: " hi! link haskellConditional GruvboxAqua
line 1341: " hi! link haskellLet GruvboxOrange
line 1342: "
line 1343: hi! link haskellType GruvboxFg1
line 1344: hi! link haskellIdentifier GruvboxFg1
line 1345: hi! link haskellSeparator GruvboxFg1
line 1346: hi! link haskellDelimiter GruvboxFg4
line 1347: hi! link haskellOperators GruvboxBlue
line 1348: "
line 1349: hi! link haskellBacktick GruvboxOrange
line 1350: hi! link haskellStatement GruvboxOrange
line 1351: hi! link haskellConditional GruvboxOrange
line 1352: 
line 1353: hi! link haskellLet GruvboxAqua
line 1354: hi! link haskellDefault GruvboxAqua
line 1355: hi! link haskellWhere GruvboxAqua
line 1356: hi! link haskellBottom GruvboxAqua
line 1357: hi! link haskellBlockKeywords GruvboxAqua
line 1358: hi! link haskellImportKeywords GruvboxAqua
line 1359: hi! link haskellDeclKeyword GruvboxAqua
line 1360: hi! link haskellDeriving GruvboxAqua
line 1361: hi! link haskellAssocType GruvboxAqua
line 1362: 
line 1363: hi! link haskellNumber GruvboxPurple
line 1364: hi! link haskellPragma GruvboxPurple
line 1365: 
line 1366: hi! link haskellString GruvboxGreen
line 1367: hi! link haskellChar GruvboxGreen
line 1368: 
line 1369: " }}}
line 1370: " Json: {{{
line 1371: 
line 1372: hi! link jsonKeyword GruvboxGreen
line 1373: hi! link jsonQuote GruvboxGreen
line 1374: hi! link jsonBraces GruvboxFg1
line 1375: hi! link jsonString GruvboxFg1
line 1376: 
line 1377: " }}}
line 1378: 
line 1379: 
line 1380: " Functions -------------------------------------------------------------------
line 1381: " Search Highlighting Cursor {{{
line 1382: 
line 1383: function! GruvboxHlsShowCursor()
line 1386: 
line 1387: function! GruvboxHlsHideCursor()
line 1390: 
line 1391: " }}}
line 1392: 
line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
finished sourcing /usr/share/vim/vimfiles/colors/gruvbox.vim
continuing in /home/ringu/.vimrc
line 31: 
line 42: let g:lightline = { 'colorscheme': 'one',   'active': {     'left':[ [ 'mode', 'paste' ],              [ 'gitbranch', 'readonly']     ]   },   'component_function': {     'gitbranch': 'fugitive#head',   } }
line 43: 
line 46: let g:lightline.separator = {   'left': '', 'right': ''}
line 49: let g:lightline.subseparator = {   'left': '', 'right': '' }
line 50: 
line 54: let g:lightline.tabline = { 'left': [['tabs','filename']], 'right': [['close']]}
line 55: 
line 59: let g:ale_fixers = { 'javascript': ['eslint'], 'css' : ['prettier'], }
line 60: 
line 63: let g:ale_linters = { 'javascript': ['eslint'], }
line 64: 
line 65: let g:gruvbox_contrast_dark='hard'
line 66: let g:indentLine_char='|'
line 67: 
line 68: set history=200^I^I" keep 200 lines of command line history
line 69: set ruler^I^I" show the cursor position all the time
line 70: set showcmd^I^I" display incomplete commands
line 71: set wildmenu^I^I" display completion matches in a status line
line 72: 
line 73: "show existing tab with 2 spaces width
line 74: set tabstop=2
line 75: set softtabstop=2
line 76: "when indenting with '>' use 2 spaces width
line 77: set shiftwidth=2
line 78: "On pressing tab insert 2 spaces
line 79: set expandtab
line 80: set number
line 81: set visualbell
line 82: set encoding=utf-8
line 83: 
line 84: " Switch syntax highlighting on when the terminal has colors or when using the
line 85: " GUI (which always has colors).
line 86: if &t_Co > 2 || has("gui_running")
line 87:   " Revert with ":syntax off".
line 88:   syntax on
line 88: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 88: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim81/syntax/nosyntax.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/synload.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim81/syntax/synload.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 19: colors gruvbox
Searching for "colors/gruvbox.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/ale/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/colors/gruvbox.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/colors/gruvbox.vim"
Searching for "/usr/share/vim/vimfiles/colors/gruvbox.vim"
chdir(/usr/share/vim/vimfiles/colors)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vimfiles/colors/gruvbox.vim"
line 1: " -----------------------------------------------------------------------------
line 2: " File: gruvbox.vim
line 3: " Description: Retro groove color scheme for Vim
line 4: " Author: morhetz <morhetz@gmail.com>
line 5: " Source: https://github.com/morhetz/gruvbox
line 6: " Last Modified: 12 Aug 2017
line 7: " -----------------------------------------------------------------------------
line 8: 
line 9: " Supporting code -------------------------------------------------------------
line 10: " Initialisation: {{{
line 11: 
line 12: if version > 580
line 13:   hi clear
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 13: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 14:   if exists("syntax_on")
line 15:     syntax reset
line 15: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/ale/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"
chdir(/usr/share/vim/vim81/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim
continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/syntax/syncolor.vim"
Searching for "/home/ringu/.vim/after/syntax/syncolor.vim"
line 16:   endif
line 17: endif
line 18: 
line 19: let g:colors_name='gruvbox'
line 20: 
line 21: if !(has('termguicolors') && &termguicolors) && !has('gui_running') && &t_Co != 256
line 22:   finish
line 23: endif
line 24: 
line 25: " }}}
line 26: " Global Settings: {{{
line 27: 
line 28: if !exists('g:gruvbox_bold')
line 29:   let g:gruvbox_bold=1
line 30: endif
line 31: if !exists('g:gruvbox_italic')
line 32:   if has('gui_running') || $TERM_ITALICS == 'true'
line 33:     let g:gruvbox_italic=1
line 34:   else
line 35:     let g:gruvbox_italic=0
line 36:   endif
line 37: endif
line 38: if !exists('g:gruvbox_undercurl')
line 39:   let g:gruvbox_undercurl=1
line 40: endif
line 41: if !exists('g:gruvbox_underline')
line 42:   let g:gruvbox_underline=1
line 43: endif
line 44: if !exists('g:gruvbox_inverse')
line 45:   let g:gruvbox_inverse=1
line 46: endif
line 47: 
line 48: if !exists('g:gruvbox_guisp_fallback') || index(['fg', 'bg'], g:gruvbox_guisp_fallback) == -1
line 49:   let g:gruvbox_guisp_fallback='NONE'
line 50: endif
line 51: 
line 52: if !exists('g:gruvbox_improved_strings')
line 53:   let g:gruvbox_improved_strings=0
line 54: endif
line 55: 
line 56: if !exists('g:gruvbox_improved_warnings')
line 57:   let g:gruvbox_improved_warnings=0
line 58: endif
line 59: 
line 60: if !exists('g:gruvbox_termcolors')
line 61:   let g:gruvbox_termcolors=256
line 62: endif
line 63: 
line 64: if !exists('g:gruvbox_invert_indent_guides')
line 65:   let g:gruvbox_invert_indent_guides=0
line 66: endif
line 67: 
line 68: if exists('g:gruvbox_contrast')
line 69:   echo 'g:gruvbox_contrast is deprecated; use g:gruvbox_contrast_light and g:gruvbox_contrast_dark instead'
line 70: endif
line 71: 
line 72: if !exists('g:gruvbox_contrast_dark')
line 73:   let g:gruvbox_contrast_dark='medium'
line 74: endif
line 75: 
line 76: if !exists('g:gruvbox_contrast_light')
line 77:   let g:gruvbox_contrast_light='medium'
line 78: endif
line 79: 
line 80: let s:is_dark=(&background == 'dark')
line 81: 
line 82: " }}}
line 83: " Palette: {{{
line 84: 
line 85: " setup palette dictionary
line 86: let s:gb = {}
line 87: 
line 88: " fill it with absolute colors
line 89: let s:gb.dark0_hard  = ['#1d2021', 234]     " 29-32-33
line 90: let s:gb.dark0       = ['#282828', 235]     " 40-40-40
line 91: let s:gb.dark0_soft  = ['#32302f', 236]     " 50-48-47
line 92: let s:gb.dark1       = ['#3c3836', 237]     " 60-56-54
line 93: let s:gb.dark2       = ['#504945', 239]     " 80-73-69
line 94: let s:gb.dark3       = ['#665c54', 241]     " 102-92-84
line 95: let s:gb.dark4       = ['#7c6f64', 243]     " 124-111-100
line 96: let s:gb.dark4_256   = ['#7c6f64', 243]     " 124-111-100
line 97: 
line 98: let s:gb.gray_245    = ['#928374', 245]     " 146-131-116
line 99: let s:gb.gray_244    = ['#928374', 244]     " 146-131-116
line 100: 
line 101: let s:gb.light0_hard = ['#f9f5d7', 230]     " 249-245-215
line 102: let s:gb.light0      = ['#fbf1c7', 229]     " 253-244-193
line 103: let s:gb.light0_soft = ['#f2e5bc', 228]     " 242-229-188
line 104: let s:gb.light1      = ['#ebdbb2', 223]     " 235-219-178
line 105: let s:gb.light2      = ['#d5c4a1', 250]     " 213-196-161
line 106: let s:gb.light3      = ['#bdae93', 248]     " 189-174-147
line 107: let s:gb.light4      = ['#a89984', 246]     " 168-153-132
line 108: let s:gb.light4_256  = ['#a89984', 246]     " 168-153-132
line 109: 
line 110: let s:gb.bright_red     = ['#fb4934', 167]     " 251-73-52
line 111: let s:gb.bright_green   = ['#b8bb26', 142]     " 184-187-38
line 112: let s:gb.bright_yellow  = ['#fabd2f', 214]     " 250-189-47
line 113: let s:gb.bright_blue    = ['#83a598', 109]     " 131-165-152
line 114: let s:gb.bright_purple  = ['#d3869b', 175]     " 211-134-155
line 115: let s:gb.bright_aqua    = ['#8ec07c', 108]     " 142-192-124
line 116: let s:gb.bright_orange  = ['#fe8019', 208]     " 254-128-25
line 117: 
line 118: let s:gb.neutral_red    = ['#cc241d', 124]     " 204-36-29
line 119: let s:gb.neutral_green  = ['#98971a', 106]     " 152-151-26
line 120: let s:gb.neutral_yellow = ['#d79921', 172]     " 215-153-33
line 121: let s:gb.neutral_blue   = ['#458588', 66]      " 69-133-136
line 122: let s:gb.neutral_purple = ['#b16286', 132]     " 177-98-134
line 123: let s:gb.neutral_aqua   = ['#689d6a', 72]      " 104-157-106
line 124: let s:gb.neutral_orange = ['#d65d0e', 166]     " 214-93-14
line 125: 
line 126: let s:gb.faded_red      = ['#9d0006', 88]      " 157-0-6
line 127: let s:gb.faded_green    = ['#79740e', 100]     " 121-116-14
line 128: let s:gb.faded_yellow   = ['#b57614', 136]     " 181-118-20
line 129: let s:gb.faded_blue     = ['#076678', 24]      " 7-102-120
line 130: let s:gb.faded_purple   = ['#8f3f71', 96]      " 143-63-113
line 131: let s:gb.faded_aqua     = ['#427b58', 66]      " 66-123-88
line 132: let s:gb.faded_orange   = ['#af3a03', 130]     " 175-58-3
line 133: 
line 134: " }}}
line 135: " Setup Emphasis: {{{
line 136: 
line 137: let s:bold = 'bold,'
line 138: if g:gruvbox_bold == 0
line 139:   let s:bold = ''
line 140: endif
line 141: 
line 142: let s:italic = 'italic,'
line 143: if g:gruvbox_italic == 0
line 144:   let s:italic = ''
line 145: endif
line 146: 
line 147: let s:underline = 'underline,'
line 148: if g:gruvbox_underline == 0
line 149:   let s:underline = ''
line 150: endif
line 151: 
line 152: let s:undercurl = 'undercurl,'
line 153: if g:gruvbox_undercurl == 0
line 154:   let s:undercurl = ''
line 155: endif
line 156: 
line 157: let s:inverse = 'inverse,'
line 158: if g:gruvbox_inverse == 0
line 159:   let s:inverse = ''
line 160: endif
line 161: 
line 162: " }}}
line 163: " Setup Colors: {{{
line 164: 
line 165: let s:vim_bg = ['bg', 'bg']
line 166: let s:vim_fg = ['fg', 'fg']
line 167: let s:none = ['NONE', 'NONE']
line 168: 
line 169: " determine relative colors
line 170: if s:is_dark
line 171:   let s:bg0  = s:gb.dark0
line 172:   if g:gruvbox_contrast_dark == 'soft'
line 173:     let s:bg0  = s:gb.dark0_soft
line 174:   elseif g:gruvbox_contrast_dark == 'hard'
line 175:     let s:bg0  = s:gb.dark0_hard
line 176:   endif
line 177: 
line 178:   let s:bg1  = s:gb.dark1
line 179:   let s:bg2  = s:gb.dark2
line 180:   let s:bg3  = s:gb.dark3
line 181:   let s:bg4  = s:gb.dark4
line 182: 
line 183:   let s:gray = s:gb.gray_245
line 184: 
line 185:   let s:fg0 = s:gb.light0
line 186:   let s:fg1 = s:gb.light1
line 187:   let s:fg2 = s:gb.light2
line 188:   let s:fg3 = s:gb.light3
line 189:   let s:fg4 = s:gb.light4
line 190: 
line 191:   let s:fg4_256 = s:gb.light4_256
line 192: 
line 193:   let s:red    = s:gb.bright_red
line 194:   let s:green  = s:gb.bright_green
line 195:   let s:yellow = s:gb.bright_yellow
line 196:   let s:blue   = s:gb.bright_blue
line 197:   let s:purple = s:gb.bright_purple
line 198:   let s:aqua   = s:gb.bright_aqua
line 199:   let s:orange = s:gb.bright_orange
line 200: else
line 201:   let s:bg0  = s:gb.light0
line 202:   if g:gruvbox_contrast_light == 'soft'
line 203:     let s:bg0  = s:gb.light0_soft
line 204:   elseif g:gruvbox_contrast_light == 'hard'
line 205:     let s:bg0  = s:gb.light0_hard
line 206:   endif
line 207: 
line 208:   let s:bg1  = s:gb.light1
line 209:   let s:bg2  = s:gb.light2
line 210:   let s:bg3  = s:gb.light3
line 211:   let s:bg4  = s:gb.light4
line 212: 
line 213:   let s:gray = s:gb.gray_244
line 214: 
line 215:   let s:fg0 = s:gb.dark0
line 216:   let s:fg1 = s:gb.dark1
line 217:   let s:fg2 = s:gb.dark2
line 218:   let s:fg3 = s:gb.dark3
line 219:   let s:fg4 = s:gb.dark4
line 220: 
line 221:   let s:fg4_256 = s:gb.dark4_256
line 222: 
line 223:   let s:red    = s:gb.faded_red
line 224:   let s:green  = s:gb.faded_green
line 225:   let s:yellow = s:gb.faded_yellow
line 226:   let s:blue   = s:gb.faded_blue
line 227:   let s:purple = s:gb.faded_purple
line 228:   let s:aqua   = s:gb.faded_aqua
line 229:   let s:orange = s:gb.faded_orange
line 230: endif
line 231: 
line 232: " reset to 16 colors fallback
line 233: if g:gruvbox_termcolors == 16
line 234:   let s:bg0[1]    = 0
line 235:   let s:fg4[1]    = 7
line 236:   let s:gray[1]   = 8
line 237:   let s:red[1]    = 9
line 238:   let s:green[1]  = 10
line 239:   let s:yellow[1] = 11
line 240:   let s:blue[1]   = 12
line 241:   let s:purple[1] = 13
line 242:   let s:aqua[1]   = 14
line 243:   let s:fg1[1]    = 15
line 244: endif
line 245: 
line 246: " save current relative colors back to palette dictionary
line 247: let s:gb.bg0 = s:bg0
line 248: let s:gb.bg1 = s:bg1
line 249: let s:gb.bg2 = s:bg2
line 250: let s:gb.bg3 = s:bg3
line 251: let s:gb.bg4 = s:bg4
line 252: 
line 253: let s:gb.gray = s:gray
line 254: 
line 255: let s:gb.fg0 = s:fg0
line 256: let s:gb.fg1 = s:fg1
line 257: let s:gb.fg2 = s:fg2
line 258: let s:gb.fg3 = s:fg3
line 259: let s:gb.fg4 = s:fg4
line 260: 
line 261: let s:gb.fg4_256 = s:fg4_256
line 262: 
line 263: let s:gb.red    = s:red
line 264: let s:gb.green  = s:green
line 265: let s:gb.yellow = s:yellow
line 266: let s:gb.blue   = s:blue
line 267: let s:gb.purple = s:purple
line 268: let s:gb.aqua   = s:aqua
line 269: let s:gb.orange = s:orange
line 270: 
line 271: " }}}
line 272: " Setup Terminal Colors For Neovim: {{{
line 273: 
line 274: if has('nvim')
line 275:   let g:terminal_color_0 = s:bg0[0]
line 276:   let g:terminal_color_8 = s:gray[0]
line 277: 
line 278:   let g:terminal_color_1 = s:gb.neutral_red[0]
line 279:   let g:terminal_color_9 = s:red[0]
line 280: 
line 281:   let g:terminal_color_2 = s:gb.neutral_green[0]
line 282:   let g:terminal_color_10 = s:green[0]
line 283: 
line 284:   let g:terminal_color_3 = s:gb.neutral_yellow[0]
line 285:   let g:terminal_color_11 = s:yellow[0]
line 286: 
line 287:   let g:terminal_color_4 = s:gb.neutral_blue[0]
line 288:   let g:terminal_color_12 = s:blue[0]
line 289: 
line 290:   let g:terminal_color_5 = s:gb.neutral_purple[0]
line 291:   let g:terminal_color_13 = s:purple[0]
line 292: 
line 293:   let g:terminal_color_6 = s:gb.neutral_aqua[0]
line 294:   let g:terminal_color_14 = s:aqua[0]
line 295: 
line 296:   let g:terminal_color_7 = s:fg4[0]
line 297:   let g:terminal_color_15 = s:fg1[0]
line 298: endif
line 299: 
line 300: " }}}
line 301: " Overload Setting: {{{
line 302: 
line 303: let s:hls_cursor = s:orange
line 304: if exists('g:gruvbox_hls_cursor')
line 305:   let s:hls_cursor = get(s:gb, g:gruvbox_hls_cursor)
line 306: endif
line 307: 
line 308: let s:number_column = s:none
line 309: if exists('g:gruvbox_number_column')
line 310:   let s:number_column = get(s:gb, g:gruvbox_number_column)
line 311: endif
line 312: 
line 313: let s:sign_column = s:bg1
line 314: 
line 316: if exists('g:gitgutter_override_sign_column_highlight') && g:gitgutter_override_sign_column_highlight == 1
line 317:   let s:sign_column = s:number_column
line 318: else
line 319:   let g:gitgutter_override_sign_column_highlight = 0
line 320: 
line 321:   if exists('g:gruvbox_sign_column')
line 322:     let s:sign_column = get(s:gb, g:gruvbox_sign_column)
line 323:   endif
line 324: endif
line 325: 
line 326: let s:color_column = s:bg1
line 327: if exists('g:gruvbox_color_column')
line 328:   let s:color_column = get(s:gb, g:gruvbox_color_column)
line 329: endif
line 330: 
line 331: let s:vert_split = s:bg0
line 332: if exists('g:gruvbox_vert_split')
line 333:   let s:vert_split = get(s:gb, g:gruvbox_vert_split)
line 334: endif
line 335: 
line 336: let s:invert_signs = ''
line 337: if exists('g:gruvbox_invert_signs')
line 338:   if g:gruvbox_invert_signs == 1
line 339:     let s:invert_signs = s:inverse
line 340:   endif
line 341: endif
line 342: 
line 343: let s:invert_selection = s:inverse
line 344: if exists('g:gruvbox_invert_selection')
line 345:   if g:gruvbox_invert_selection == 0
line 346:     let s:invert_selection = ''
line 347:   endif
line 348: endif
line 349: 
line 350: let s:invert_tabline = ''
line 351: if exists('g:gruvbox_invert_tabline')
line 352:   if g:gruvbox_invert_tabline == 1
line 353:     let s:invert_tabline = s:inverse
line 354:   endif
line 355: endif
line 356: 
line 357: let s:italicize_comments = s:italic
line 358: if exists('g:gruvbox_italicize_comments')
line 359:   if g:gruvbox_italicize_comments == 0
line 360:     let s:italicize_comments = ''
line 361:   endif
line 362: endif
line 363: 
line 364: let s:italicize_strings = ''
line 365: if exists('g:gruvbox_italicize_strings')
line 366:   if g:gruvbox_italicize_strings == 1
line 367:     let s:italicize_strings = s:italic
line 368:   endif
line 369: endif
line 370: 
line 371: " }}}
line 372: " Highlighting Function: {{{
line 373: 
line 374: function! s:HL(group, fg, ...)
line 419: 
line 420: " }}}
line 421: " Gruvbox Hi Groups: {{{
line 422: 
line 423: " memoize common hi groups
line 424: call s:HL('GruvboxFg0', s:fg0)
calling function <SNR>14_HL('GruvboxFg0', ['#fbf1c7', 229])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg0 guifg=#fbf1c7 ctermfg=229 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 425: call s:HL('GruvboxFg1', s:fg1)
calling function <SNR>14_HL('GruvboxFg1', ['#ebdbb2', 223])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg1 guifg=#ebdbb2 ctermfg=223 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 426: call s:HL('GruvboxFg2', s:fg2)
calling function <SNR>14_HL('GruvboxFg2', ['#d5c4a1', 250])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg2 guifg=#d5c4a1 ctermfg=250 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 427: call s:HL('GruvboxFg3', s:fg3)
calling function <SNR>14_HL('GruvboxFg3', ['#bdae93', 248])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg3 guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 428: call s:HL('GruvboxFg4', s:fg4)
calling function <SNR>14_HL('GruvboxFg4', ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxFg4 guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 429: call s:HL('GruvboxGray', s:gray)
calling function <SNR>14_HL('GruvboxGray', ['#928374', 245])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGray guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 430: call s:HL('GruvboxBg0', s:bg0)
calling function <SNR>14_HL('GruvboxBg0', ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg0 guifg=#1d2021 ctermfg=234 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 431: call s:HL('GruvboxBg1', s:bg1)
calling function <SNR>14_HL('GruvboxBg1', ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg1 guifg=#3c3836 ctermfg=237 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 432: call s:HL('GruvboxBg2', s:bg2)
calling function <SNR>14_HL('GruvboxBg2', ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg2 guifg=#504945 ctermfg=239 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 433: call s:HL('GruvboxBg3', s:bg3)
calling function <SNR>14_HL('GruvboxBg3', ['#665c54', 241])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg3 guifg=#665c54 ctermfg=241 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 434: call s:HL('GruvboxBg4', s:bg4)
calling function <SNR>14_HL('GruvboxBg4', ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBg4 guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 435: 
line 436: call s:HL('GruvboxRed', s:red)
calling function <SNR>14_HL('GruvboxRed', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRed guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 437: call s:HL('GruvboxRedBold', s:red, s:none, s:bold)
calling function <SNR>14_HL('GruvboxRedBold', ['#fb4934', 167], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedBold guifg=#fb4934 ctermfg=167 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 438: call s:HL('GruvboxGreen', s:green)
calling function <SNR>14_HL('GruvboxGreen', ['#b8bb26', 142])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreen guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 439: call s:HL('GruvboxGreenBold', s:green, s:none, s:bold)
calling function <SNR>14_HL('GruvboxGreenBold', ['#b8bb26', 142], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenBold guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 440: call s:HL('GruvboxYellow', s:yellow)
calling function <SNR>14_HL('GruvboxYellow', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellow guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 441: call s:HL('GruvboxYellowBold', s:yellow, s:none, s:bold)
calling function <SNR>14_HL('GruvboxYellowBold', ['#fabd2f', 214], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowBold guifg=#fabd2f ctermfg=214 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 442: call s:HL('GruvboxBlue', s:blue)
calling function <SNR>14_HL('GruvboxBlue', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlue guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 443: call s:HL('GruvboxBlueBold', s:blue, s:none, s:bold)
calling function <SNR>14_HL('GruvboxBlueBold', ['#83a598', 109], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueBold guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 444: call s:HL('GruvboxPurple', s:purple)
calling function <SNR>14_HL('GruvboxPurple', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurple guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 445: call s:HL('GruvboxPurpleBold', s:purple, s:none, s:bold)
calling function <SNR>14_HL('GruvboxPurpleBold', ['#d3869b', 175], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleBold guifg=#d3869b ctermfg=175 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 446: call s:HL('GruvboxAqua', s:aqua)
calling function <SNR>14_HL('GruvboxAqua', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAqua guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 447: call s:HL('GruvboxAquaBold', s:aqua, s:none, s:bold)
calling function <SNR>14_HL('GruvboxAquaBold', ['#8ec07c', 108], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaBold guifg=#8ec07c ctermfg=108 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 448: call s:HL('GruvboxOrange', s:orange)
calling function <SNR>14_HL('GruvboxOrange', ['#fe8019', 208])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrange guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 449: call s:HL('GruvboxOrangeBold', s:orange, s:none, s:bold)
calling function <SNR>14_HL('GruvboxOrangeBold', ['#fe8019', 208], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxOrangeBold guifg=#fe8019 ctermfg=208 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 450: 
line 451: call s:HL('GruvboxRedSign', s:red, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxRedSign', ['#fb4934', 167], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxRedSign guifg=#fb4934 ctermfg=167 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 452: call s:HL('GruvboxGreenSign', s:green, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxGreenSign', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxGreenSign guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 453: call s:HL('GruvboxYellowSign', s:yellow, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxYellowSign', ['#fabd2f', 214], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxYellowSign guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 454: call s:HL('GruvboxBlueSign', s:blue, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxBlueSign', ['#83a598', 109], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxBlueSign guifg=#83a598 ctermfg=109 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 455: call s:HL('GruvboxPurpleSign', s:purple, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxPurpleSign', ['#d3869b', 175], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxPurpleSign guifg=#d3869b ctermfg=175 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 456: call s:HL('GruvboxAquaSign', s:aqua, s:sign_column, s:invert_signs)
calling function <SNR>14_HL('GruvboxAquaSign', ['#8ec07c', 108], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi GruvboxAquaSign guifg=#8ec07c ctermfg=108 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 457: 
line 458: " }}}
line 459: 
line 460: " Vanilla colorscheme ---------------------------------------------------------
line 461: " General UI: {{{
line 462: 
line 463: " Normal text
line 464: call s:HL('Normal', s:fg1, s:bg0)
calling function <SNR>14_HL('Normal', ['#ebdbb2', 223], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Normal guifg=#ebdbb2 ctermfg=223 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 465: 
line 466: " Correct background (see issue #7):
line 467: " --- Problem with changing between dark and light on 256 color terminal
line 468: " --- https://github.com/morhetz/gruvbox/issues/7
line 469: if s:is_dark
line 470:   set background=dark
line 471: else
line 472:   set background=light
line 473: endif
line 474: 
line 475: if version >= 700
line 476:   " Screen line that the cursor is
line 477:   call s:HL('CursorLine',   s:none, s:bg1)
calling function <SNR>14_HL('CursorLine', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLine guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 478:   " Screen column that the cursor is
line 479:   hi! link CursorColumn CursorLine
line 480: 
line 481:   " Tab pages line filler
line 482:   call s:HL('TabLineFill', s:bg4, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineFill', ['#7c6f64', 243], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineFill guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 483:   " Active tab page label
line 484:   call s:HL('TabLineSel', s:green, s:bg1, s:invert_tabline)
calling function <SNR>14_HL('TabLineSel', ['#b8bb26', 142], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi TabLineSel guifg=#b8bb26 ctermfg=142 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 485:   " Not active tab page label
line 486:   hi! link TabLine TabLineFill
line 487: 
line 488:   " Match paired bracket under the cursor
line 489:   call s:HL('MatchParen', s:none, s:bg3, s:bold)
calling function <SNR>14_HL('MatchParen', ['NONE', 'NONE'], ['#665c54', 241], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi MatchParen guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 490: endif
line 491: 
line 492: if version >= 703
line 493:   " Highlighted screen columns
line 494:   call s:HL('ColorColumn',  s:none, s:color_column)
calling function <SNR>14_HL('ColorColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ColorColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 495: 
line 496:   " Concealed element: \lambda  
line 497:   call s:HL('Conceal', s:blue, s:none)
calling function <SNR>14_HL('Conceal', ['#83a598', 109], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Conceal guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 498: 
line 499:   " Line number of CursorLine
line 500:   call s:HL('CursorLineNr', s:yellow, s:bg1)
calling function <SNR>14_HL('CursorLineNr', ['#fabd2f', 214], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CursorLineNr guifg=#fabd2f ctermfg=214 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 501: endif
line 502: 
line 503: hi! link NonText GruvboxBg2
line 504: hi! link SpecialKey GruvboxBg2
line 505: 
line 506: call s:HL('Visual',    s:none,  s:bg3, s:invert_selection)
calling function <SNR>14_HL('Visual', ['NONE', 'NONE'], ['#665c54', 241], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Visual guifg=NONE ctermfg=NONE guibg=#665c54 ctermbg=241 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 507: hi! link VisualNOS Visual
line 508: 
line 509: call s:HL('Search',    s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('Search', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Search guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 510: call s:HL('IncSearch', s:hls_cursor, s:bg0, s:inverse)
calling function <SNR>14_HL('IncSearch', ['#fe8019', 208], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IncSearch guifg=#fe8019 ctermfg=208 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 511: 
line 512: call s:HL('Underlined', s:blue, s:none, s:underline)
calling function <SNR>14_HL('Underlined', ['#83a598', 109], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Underlined guifg=#83a598 ctermfg=109 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 513: 
line 514: call s:HL('StatusLine',   s:bg2, s:fg1, s:inverse)
calling function <SNR>14_HL('StatusLine', ['#504945', 239], ['#ebdbb2', 223], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLine guifg=#504945 ctermfg=239 guibg=#ebdbb2 ctermbg=223 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 515: call s:HL('StatusLineNC', s:bg1, s:fg4, s:inverse)
calling function <SNR>14_HL('StatusLineNC', ['#3c3836', 237], ['#a89984', 246], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi StatusLineNC guifg=#3c3836 ctermfg=237 guibg=#a89984 ctermbg=246 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 516: 
line 517: " The column separating vertically split windows
line 518: call s:HL('VertSplit', s:bg3, s:vert_split)
calling function <SNR>14_HL('VertSplit', ['#665c54', 241], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi VertSplit guifg=#665c54 ctermfg=241 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 519: 
line 520: " Current match in wildmenu completion
line 521: call s:HL('WildMenu', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('WildMenu', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi WildMenu guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 522: 
line 523: " Directory names, special names in listing
line 524: hi! link Directory GruvboxGreenBold
line 525: 
line 526: " Titles for output from :set all, :autocmd, etc.
line 527: hi! link Title GruvboxGreenBold
line 528: 
line 529: " Error messages on the command line
line 530: call s:HL('ErrorMsg',   s:bg0, s:red, s:bold)
calling function <SNR>14_HL('ErrorMsg', ['#1d2021', 234], ['#fb4934', 167], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ErrorMsg guifg=#1d2021 ctermfg=234 guibg=#fb4934 ctermbg=167 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 531: " More prompt: -- More --
line 532: hi! link MoreMsg GruvboxYellowBold
line 533: " Current mode message: -- INSERT --
line 534: hi! link ModeMsg GruvboxYellowBold
line 535: " 'Press enter' prompt and yes/no questions
line 536: hi! link Question GruvboxOrangeBold
line 537: " Warning messages
line 538: hi! link WarningMsg GruvboxRedBold
line 539: 
line 540: " }}}
line 541: " Gutter: {{{
line 542: 
line 543: " Line number for :number and :# commands
line 544: call s:HL('LineNr', s:bg4, s:number_column)
calling function <SNR>14_HL('LineNr', ['#7c6f64', 243], ['NONE', 'NONE'])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi LineNr guifg=#7c6f64 ctermfg=243 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 545: 
line 546: " Column where signs are displayed
line 547: call s:HL('SignColumn', s:none, s:sign_column)
calling function <SNR>14_HL('SignColumn', ['NONE', 'NONE'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SignColumn guifg=NONE ctermfg=NONE guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 548: 
line 549: " Line used for closed folds
line 550: call s:HL('Folded', s:gray, s:bg1, s:italic)
calling function <SNR>14_HL('Folded', ['#928374', 245], ['#3c3836', 237], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Folded guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 551: " Column where folds are displayed
line 552: call s:HL('FoldColumn', s:gray, s:bg1)
calling function <SNR>14_HL('FoldColumn', ['#928374', 245], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi FoldColumn guifg=#928374 ctermfg=245 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 553: 
line 554: " }}}
line 555: " Cursor: {{{
line 556: 
line 557: " Character under cursor
line 558: call s:HL('Cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('Cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 559: " Visual mode cursor, selection
line 560: hi! link vCursor Cursor
line 561: " Input moder cursor
line 562: hi! link iCursor Cursor
line 563: " Language mapping cursor
line 564: hi! link lCursor Cursor
line 565: 
line 566: " }}}
line 567: " Syntax Highlighting: {{{
line 568: 
line 569: if g:gruvbox_improved_strings == 0
line 570:   hi! link Special GruvboxOrange
line 571: else
line 572:   call s:HL('Special', s:orange, s:bg1, s:italicize_strings)
line 573: endif
line 574: 
line 575: call s:HL('Comment', s:gray, s:none, s:italicize_comments)
calling function <SNR>14_HL('Comment', ['#928374', 245], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Comment guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 576: call s:HL('Todo', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('Todo', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Todo guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 577: call s:HL('Error', s:red, s:vim_bg, s:bold . s:inverse)
calling function <SNR>14_HL('Error', ['#fb4934', 167], ['bg', 'bg'], 'bold,inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Error guifg=#fb4934 ctermfg=167 guibg=bg ctermbg=bg gui=bold,inverse cterm=bold,inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 578: 
line 579: " Generic statement
line 580: hi! link Statement GruvboxRed
line 581: " if, then, else, endif, swicth, etc.
line 582: hi! link Conditional GruvboxRed
line 583: " for, do, while, etc.
line 584: hi! link Repeat GruvboxRed
line 585: " case, default, etc.
line 586: hi! link Label GruvboxRed
line 587: " try, catch, throw
line 588: hi! link Exception GruvboxRed
line 589: " sizeof, "+", "*", etc.
line 590: hi! link Operator Normal
line 591: " Any other keyword
line 592: hi! link Keyword GruvboxRed
line 593: 
line 594: " Variable name
line 595: hi! link Identifier GruvboxBlue
line 596: " Function name
line 597: hi! link Function GruvboxGreenBold
line 598: 
line 599: " Generic preprocessor
line 600: hi! link PreProc GruvboxAqua
line 601: " Preprocessor #include
line 602: hi! link Include GruvboxAqua
line 603: " Preprocessor #define
line 604: hi! link Define GruvboxAqua
line 605: " Same as Define
line 606: hi! link Macro GruvboxAqua
line 607: " Preprocessor #if, #else, #endif, etc.
line 608: hi! link PreCondit GruvboxAqua
line 609: 
line 610: " Generic constant
line 611: hi! link Constant GruvboxPurple
line 612: " Character constant: 'c', '/n'
line 613: hi! link Character GruvboxPurple
line 614: " String constant: "this is a string"
line 615: if g:gruvbox_improved_strings == 0
line 616:   call s:HL('String',  s:green, s:none, s:italicize_strings)
calling function <SNR>14_HL('String', ['#b8bb26', 142], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi String guifg=#b8bb26 ctermfg=142 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 617: else
line 618:   call s:HL('String',  s:fg1, s:bg1, s:italicize_strings)
line 619: endif
line 620: " Boolean constant: TRUE, false
line 621: hi! link Boolean GruvboxPurple
line 622: " Number constant: 234, 0xff
line 623: hi! link Number GruvboxPurple
line 624: " Floating point constant: 2.3e10
line 625: hi! link Float GruvboxPurple
line 626: 
line 627: " Generic type
line 628: hi! link Type GruvboxYellow
line 629: " static, register, volatile, etc
line 630: hi! link StorageClass GruvboxOrange
line 631: " struct, union, enum, etc.
line 632: hi! link Structure GruvboxAqua
line 633: " typedef
line 634: hi! link Typedef GruvboxYellow
line 635: 
line 636: " }}}
line 637: " Completion Menu: {{{
line 638: 
line 639: if version >= 700
line 640:   " Popup menu: normal item
line 641:   call s:HL('Pmenu', s:fg1, s:bg2)
calling function <SNR>14_HL('Pmenu', ['#ebdbb2', 223], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi Pmenu guifg=#ebdbb2 ctermfg=223 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 642:   " Popup menu: selected item
line 643:   call s:HL('PmenuSel', s:bg2, s:blue, s:bold)
calling function <SNR>14_HL('PmenuSel', ['#504945', 239], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSel guifg=#504945 ctermfg=239 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 644:   " Popup menu: scrollbar
line 645:   call s:HL('PmenuSbar', s:none, s:bg2)
calling function <SNR>14_HL('PmenuSbar', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuSbar guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 646:   " Popup menu: scrollbar thumb
line 647:   call s:HL('PmenuThumb', s:none, s:bg4)
calling function <SNR>14_HL('PmenuThumb', ['NONE', 'NONE'], ['#7c6f64', 243])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi PmenuThumb guifg=NONE ctermfg=NONE guibg=#7c6f64 ctermbg=243 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 648: endif
line 649: 
line 650: " }}}
line 651: " Diffs: {{{
line 652: 
line 653: call s:HL('DiffDelete', s:red, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffDelete', ['#fb4934', 167], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffDelete guifg=#fb4934 ctermfg=167 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 654: call s:HL('DiffAdd',    s:green, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffAdd', ['#b8bb26', 142], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffAdd guifg=#b8bb26 ctermfg=142 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 655: "call s:HL('DiffChange', s:bg0, s:blue)
line 656: "call s:HL('DiffText',   s:bg0, s:yellow)
line 657: 
line 658: " Alternative setting
line 659: call s:HL('DiffChange', s:aqua, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffChange', ['#8ec07c', 108], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffChange guifg=#8ec07c ctermfg=108 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 660: call s:HL('DiffText',   s:yellow, s:bg0, s:inverse)
calling function <SNR>14_HL('DiffText', ['#fabd2f', 214], ['#1d2021', 234], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi DiffText guifg=#fabd2f ctermfg=214 guibg=#1d2021 ctermbg=234 gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 661: 
line 662: " }}}
line 663: " Spelling: {{{
line 664: 
line 665: if has("spell")
line 666:   " Not capitalised word, or compile warnings
line 667:   if g:gruvbox_improved_warnings == 0
line 668:     call s:HL('SpellCap',   s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SpellCap', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellCap guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 669:   else
line 670:     call s:HL('SpellCap',   s:green, s:none, s:bold . s:italic)
line 671:   endif
line 672:   " Not recognized word
line 673:   call s:HL('SpellBad',   s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('SpellBad', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellBad guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 674:   " Wrong spelling for selected region
line 675:   call s:HL('SpellLocal', s:none, s:none, s:undercurl, s:aqua)
calling function <SNR>14_HL('SpellLocal', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#8ec07c', 108])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellLocal guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#8ec07c
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 676:   " Rare word
line 677:   call s:HL('SpellRare',  s:none, s:none, s:undercurl, s:purple)
calling function <SNR>14_HL('SpellRare', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#d3869b', 175])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SpellRare guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#d3869b
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 678: endif
line 679: 
line 680: " }}}
line 681: 
line 682: " Plugin specific -------------------------------------------------------------
line 683: " EasyMotion: {{{
line 684: 
line 685: hi! link EasyMotionTarget Search
line 686: hi! link EasyMotionShade Comment
line 687: 
line 688: " }}}
line 689: " Sneak: {{{
line 690: 
line 691: hi! link Sneak Search
line 692: hi! link SneakLabel Search
line 693: 
line 694: " }}}
line 695: " Indent Guides: {{{
line 696: 
line 697: if !exists('g:indent_guides_auto_colors')
line 698:   let g:indent_guides_auto_colors = 0
line 699: endif
line 700: 
line 701: if g:indent_guides_auto_colors == 0
line 702:   if g:gruvbox_invert_indent_guides == 0
line 703:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2)
calling function <SNR>14_HL('IndentGuidesOdd', ['bg', 'bg'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesOdd guifg=bg ctermfg=bg guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 704:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg1)
calling function <SNR>14_HL('IndentGuidesEven', ['bg', 'bg'], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi IndentGuidesEven guifg=bg ctermfg=bg guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 705:   else
line 706:     call s:HL('IndentGuidesOdd', s:vim_bg, s:bg2, s:inverse)
line 707:     call s:HL('IndentGuidesEven', s:vim_bg, s:bg3, s:inverse)
line 708:   endif
line 709: endif
line 710: 
line 711: " }}}
line 712: " IndentLine: {{{
line 713: 
line 714: if !exists('g:indentLine_color_term')
line 715:   let g:indentLine_color_term = s:bg2[1]
line 716: endif
line 717: if !exists('g:indentLine_color_gui')
line 718:   let g:indentLine_color_gui = s:bg2[0]
line 719: endif
line 720: 
line 721: " }}}
line 722: " Rainbow Parentheses: {{{
line 723: 
line 724: if !exists('g:rbpt_colorpairs')
line 729:   let g:rbpt_colorpairs = [ ['blue', '#458588'], ['magenta', '#b16286'], ['red',  '#cc241d'], ['166',     '#d65d0e'] ]
line 730: endif
line 731: 
line 732: let g:rainbow_guifgs = [ '#d65d0e', '#cc241d', '#b16286', '#458588' ]
line 733: let g:rainbow_ctermfgs = [ '166', 'red', 'magenta', 'blue' ]
line 734: 
line 735: if !exists('g:rainbow_conf')
line 736:    let g:rainbow_conf = {}
line 737: endif
line 738: if !has_key(g:rainbow_conf, 'guifgs')
line 739:    let g:rainbow_conf['guifgs'] = g:rainbow_guifgs
line 740: endif
line 741: if !has_key(g:rainbow_conf, 'ctermfgs')
line 742:    let g:rainbow_conf['ctermfgs'] = g:rainbow_ctermfgs
line 743: endif
line 744: 
line 745: let g:niji_dark_colours = g:rbpt_colorpairs
line 746: let g:niji_light_colours = g:rbpt_colorpairs
line 747: 
line 748: "}}}
line 749: " GitGutter: {{{
line 750: 
line 751: hi! link GitGutterAdd GruvboxGreenSign
line 752: hi! link GitGutterChange GruvboxAquaSign
line 753: hi! link GitGutterDelete GruvboxRedSign
line 754: hi! link GitGutterChangeDelete GruvboxAquaSign
line 755: 
line 756: " }}}
line 757: " GitCommit: "{{{
line 758: 
line 759: hi! link gitcommitSelectedFile GruvboxGreen
line 760: hi! link gitcommitDiscardedFile GruvboxRed
line 761: 
line 762: " }}}
line 763: " Signify: {{{
line 764: 
line 765: hi! link SignifySignAdd GruvboxGreenSign
line 766: hi! link SignifySignChange GruvboxAquaSign
line 767: hi! link SignifySignDelete GruvboxRedSign
line 768: 
line 769: " }}}
line 770: " Syntastic: {{{
line 771: 
line 772: call s:HL('SyntasticError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('SyntasticError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 773: call s:HL('SyntasticWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('SyntasticWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi SyntasticWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 774: 
line 775: hi! link SyntasticErrorSign GruvboxRedSign
line 776: hi! link SyntasticWarningSign GruvboxYellowSign
line 777: 
line 778: " }}}
line 779: " Signature: {{{
line 780: hi! link SignatureMarkText   GruvboxBlueSign
line 781: hi! link SignatureMarkerText GruvboxPurpleSign
line 782: 
line 783: " }}}
line 784: " ShowMarks: {{{
line 785: 
line 786: hi! link ShowMarksHLl GruvboxBlueSign
line 787: hi! link ShowMarksHLu GruvboxBlueSign
line 788: hi! link ShowMarksHLo GruvboxBlueSign
line 789: hi! link ShowMarksHLm GruvboxBlueSign
line 790: 
line 791: " }}}
line 792: " CtrlP: {{{
line 793: 
line 794: hi! link CtrlPMatch GruvboxYellow
line 795: hi! link CtrlPNoEntries GruvboxRed
line 796: hi! link CtrlPPrtBase GruvboxBg2
line 797: hi! link CtrlPPrtCursor GruvboxBlue
line 798: hi! link CtrlPLinePre GruvboxBg2
line 799: 
line 800: call s:HL('CtrlPMode1', s:blue, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPMode1', ['#83a598', 109], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode1 guifg=#83a598 ctermfg=109 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 801: call s:HL('CtrlPMode2', s:bg0, s:blue, s:bold)
calling function <SNR>14_HL('CtrlPMode2', ['#1d2021', 234], ['#83a598', 109], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPMode2 guifg=#1d2021 ctermfg=234 guibg=#83a598 ctermbg=109 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 802: call s:HL('CtrlPStats', s:fg4, s:bg2, s:bold)
calling function <SNR>14_HL('CtrlPStats', ['#a89984', 246], ['#504945', 239], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi CtrlPStats guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 803: 
line 804: " }}}
line 805: " Startify: {{{
line 806: 
line 807: hi! link StartifyBracket GruvboxFg3
line 808: hi! link StartifyFile GruvboxFg1
line 809: hi! link StartifyNumber GruvboxBlue
line 810: hi! link StartifyPath GruvboxGray
line 811: hi! link StartifySlash GruvboxGray
line 812: hi! link StartifySection GruvboxYellow
line 813: hi! link StartifySpecial GruvboxBg2
line 814: hi! link StartifyHeader GruvboxOrange
line 815: hi! link StartifyFooter GruvboxBg2
line 816: 
line 817: " }}}
line 818: " Vimshell: {{{
line 819: 
line 825: let g:vimshell_escape_colors = [ s:bg4[0], s:red[0], s:green[0], s:yellow[0], s:blue[0], s:purple[0], s:aqua[0], s:fg4[0], s:bg0[0], s:red[0], s:green[0], s:orange[0], s:blue[0], s:purple[0], s:aqua[0], s:fg0[0] ]
line 826: 
line 827: " }}}
line 828: " BufTabLine: {{{
line 829: 
line 830: call s:HL('BufTabLineCurrent', s:bg0, s:fg4)
calling function <SNR>14_HL('BufTabLineCurrent', ['#1d2021', 234], ['#a89984', 246])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineCurrent guifg=#1d2021 ctermfg=234 guibg=#a89984 ctermbg=246 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 831: call s:HL('BufTabLineActive', s:fg4, s:bg2)
calling function <SNR>14_HL('BufTabLineActive', ['#a89984', 246], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineActive guifg=#a89984 ctermfg=246 guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 832: call s:HL('BufTabLineHidden', s:bg4, s:bg1)
calling function <SNR>14_HL('BufTabLineHidden', ['#7c6f64', 243], ['#3c3836', 237])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineHidden guifg=#7c6f64 ctermfg=243 guibg=#3c3836 ctermbg=237 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 833: call s:HL('BufTabLineFill', s:bg0, s:bg0)
calling function <SNR>14_HL('BufTabLineFill', ['#1d2021', 234], ['#1d2021', 234])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi BufTabLineFill guifg=#1d2021 ctermfg=234 guibg=#1d2021 ctermbg=234 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 834: 
line 835: " }}}
line 836: " Asynchronous Lint Engine: {{{
line 837: 
line 838: call s:HL('ALEError', s:none, s:none, s:undercurl, s:red)
calling function <SNR>14_HL('ALEError', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fb4934', 167])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEError guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fb4934
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 839: call s:HL('ALEWarning', s:none, s:none, s:undercurl, s:yellow)
calling function <SNR>14_HL('ALEWarning', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#fabd2f', 214])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEWarning guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#fabd2f
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 840: call s:HL('ALEInfo', s:none, s:none, s:undercurl, s:blue)
calling function <SNR>14_HL('ALEInfo', ['NONE', 'NONE'], ['NONE', 'NONE'], 'undercurl,', ['#83a598', 109])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi ALEInfo guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=undercurl cterm=undercurl guisp=#83a598
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 841: 
line 842: hi! link ALEErrorSign GruvboxRedSign
line 843: hi! link ALEWarningSign GruvboxYellowSign
line 844: hi! link ALEInfoSign GruvboxBlueSign
line 845: 
line 846: " }}}
line 847: " Dirvish: {{{
line 848: 
line 849: hi! link DirvishPathTail GruvboxAqua
line 850: hi! link DirvishArg GruvboxYellow
line 851: 
line 852: " }}}
line 853: " Netrw: {{{
line 854: 
line 855: hi! link netrwDir GruvboxAqua
line 856: hi! link netrwClassify GruvboxAqua
line 857: hi! link netrwLink GruvboxGray
line 858: hi! link netrwSymLink GruvboxFg1
line 859: hi! link netrwExe GruvboxYellow
line 860: hi! link netrwComment GruvboxGray
line 861: hi! link netrwList GruvboxBlue
line 862: hi! link netrwHelpCmd GruvboxAqua
line 863: hi! link netrwCmdSep GruvboxFg3
line 864: hi! link netrwVersion GruvboxGreen
line 865: 
line 866: " }}}
line 867: " NERDTree: {{{
line 868: 
line 869: hi! link NERDTreeDir GruvboxAqua
line 870: hi! link NERDTreeDirSlash GruvboxAqua
line 871: 
line 872: hi! link NERDTreeOpenable GruvboxOrange
line 873: hi! link NERDTreeClosable GruvboxOrange
line 874: 
line 875: hi! link NERDTreeFile GruvboxFg1
line 876: hi! link NERDTreeExecFile GruvboxYellow
line 877: 
line 878: hi! link NERDTreeUp GruvboxGray
line 879: hi! link NERDTreeCWD GruvboxGreen
line 880: hi! link NERDTreeHelp GruvboxFg1
line 881: 
line 882: hi! link NERDTreeToggleOn GruvboxGreen
line 883: hi! link NERDTreeToggleOff GruvboxRed
line 884: 
line 885: " }}}
line 886: " Vim Multiple Cursors: {{{
line 887: 
line 888: call s:HL('multiple_cursors_cursor', s:none, s:none, s:inverse)
calling function <SNR>14_HL('multiple_cursors_cursor', ['NONE', 'NONE'], ['NONE', 'NONE'], 'inverse,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_cursor guifg=NONE ctermfg=NONE guibg=NONE ctermbg=NONE gui=inverse cterm=inverse
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 889: call s:HL('multiple_cursors_visual', s:none, s:bg2)
calling function <SNR>14_HL('multiple_cursors_visual', ['NONE', 'NONE'], ['#504945', 239])

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi multiple_cursors_visual guifg=NONE ctermfg=NONE guibg=#504945 ctermbg=239 gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 890: 
line 891: " }}}
line 892: 
line 893: " Filetype specific -----------------------------------------------------------
line 894: " Diff: {{{
line 895: 
line 896: hi! link diffAdded GruvboxGreen
line 897: hi! link diffRemoved GruvboxRed
line 898: hi! link diffChanged GruvboxAqua
line 899: 
line 900: hi! link diffFile GruvboxOrange
line 901: hi! link diffNewFile GruvboxYellow
line 902: 
line 903: hi! link diffLine GruvboxBlue
line 904: 
line 905: " }}}
line 906: " Html: {{{
line 907: 
line 908: hi! link htmlTag GruvboxBlue
line 909: hi! link htmlEndTag GruvboxBlue
line 910: 
line 911: hi! link htmlTagName GruvboxAquaBold
line 912: hi! link htmlArg GruvboxAqua
line 913: 
line 914: hi! link htmlScriptTag GruvboxPurple
line 915: hi! link htmlTagN GruvboxFg1
line 916: hi! link htmlSpecialTagName GruvboxAquaBold
line 917: 
line 918: call s:HL('htmlLink', s:fg4, s:none, s:underline)
calling function <SNR>14_HL('htmlLink', ['#a89984', 246], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlLink guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 919: 
line 920: hi! link htmlSpecialChar GruvboxOrange
line 921: 
line 922: call s:HL('htmlBold', s:vim_fg, s:vim_bg, s:bold)
calling function <SNR>14_HL('htmlBold', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBold guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 923: call s:HL('htmlBoldUnderline', s:vim_fg, s:vim_bg, s:bold . s:underline)
calling function <SNR>14_HL('htmlBoldUnderline', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 924: call s:HL('htmlBoldItalic', s:vim_fg, s:vim_bg, s:bold . s:italic)
calling function <SNR>14_HL('htmlBoldItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 925: call s:HL('htmlBoldUnderlineItalic', s:vim_fg, s:vim_bg, s:bold . s:underline . s:italic)
calling function <SNR>14_HL('htmlBoldUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'bold,underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlBoldUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=bold,underline cterm=bold,underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 926: 
line 927: call s:HL('htmlUnderline', s:vim_fg, s:vim_bg, s:underline)
calling function <SNR>14_HL('htmlUnderline', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderline guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 928: call s:HL('htmlUnderlineItalic', s:vim_fg, s:vim_bg, s:underline . s:italic)
calling function <SNR>14_HL('htmlUnderlineItalic', ['fg', 'fg'], ['bg', 'bg'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlUnderlineItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 929: call s:HL('htmlItalic', s:vim_fg, s:vim_bg, s:italic)
calling function <SNR>14_HL('htmlItalic', ['fg', 'fg'], ['bg', 'bg'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi htmlItalic guifg=fg ctermfg=fg guibg=bg ctermbg=bg gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 930: 
line 931: " }}}
line 932: " Xml: {{{
line 933: 
line 934: hi! link xmlTag GruvboxBlue
line 935: hi! link xmlEndTag GruvboxBlue
line 936: hi! link xmlTagName GruvboxBlue
line 937: hi! link xmlEqual GruvboxBlue
line 938: hi! link docbkKeyword GruvboxAquaBold
line 939: 
line 940: hi! link xmlDocTypeDecl GruvboxGray
line 941: hi! link xmlDocTypeKeyword GruvboxPurple
line 942: hi! link xmlCdataStart GruvboxGray
line 943: hi! link xmlCdataCdata GruvboxPurple
line 944: hi! link dtdFunction GruvboxGray
line 945: hi! link dtdTagName GruvboxPurple
line 946: 
line 947: hi! link xmlAttrib GruvboxAqua
line 948: hi! link xmlProcessingDelim GruvboxGray
line 949: hi! link dtdParamEntityPunct GruvboxGray
line 950: hi! link dtdParamEntityDPunct GruvboxGray
line 951: hi! link xmlAttribPunct GruvboxGray
line 952: 
line 953: hi! link xmlEntity GruvboxOrange
line 954: hi! link xmlEntityPunct GruvboxOrange
line 955: " }}}
line 956: " Vim: {{{
line 957: 
line 958: call s:HL('vimCommentTitle', s:fg4_256, s:none, s:bold . s:italicize_comments)
calling function <SNR>14_HL('vimCommentTitle', ['#a89984', 246], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi vimCommentTitle guifg=#a89984 ctermfg=246 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 959: 
line 960: hi! link vimNotation GruvboxOrange
line 961: hi! link vimBracket GruvboxOrange
line 962: hi! link vimMapModKey GruvboxOrange
line 963: hi! link vimFuncSID GruvboxFg3
line 964: hi! link vimSetSep GruvboxFg3
line 965: hi! link vimSep GruvboxFg3
line 966: hi! link vimContinue GruvboxFg3
line 967: 
line 968: " }}}
line 969: " Clojure: {{{
line 970: 
line 971: hi! link clojureKeyword GruvboxBlue
line 972: hi! link clojureCond GruvboxOrange
line 973: hi! link clojureSpecial GruvboxOrange
line 974: hi! link clojureDefine GruvboxOrange
line 975: 
line 976: hi! link clojureFunc GruvboxYellow
line 977: hi! link clojureRepeat GruvboxYellow
line 978: hi! link clojureCharacter GruvboxAqua
line 979: hi! link clojureStringEscape GruvboxAqua
line 980: hi! link clojureException GruvboxRed
line 981: 
line 982: hi! link clojureRegexp GruvboxAqua
line 983: hi! link clojureRegexpEscape GruvboxAqua
line 984: call s:HL('clojureRegexpCharClass', s:fg3, s:none, s:bold)
calling function <SNR>14_HL('clojureRegexpCharClass', ['#bdae93', 248], ['NONE', 'NONE'], 'bold,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi clojureRegexpCharClass guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=bold cterm=bold
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 985: hi! link clojureRegexpMod clojureRegexpCharClass
line 986: hi! link clojureRegexpQuantifier clojureRegexpCharClass
line 987: 
line 988: hi! link clojureParen GruvboxFg3
line 989: hi! link clojureAnonArg GruvboxYellow
line 990: hi! link clojureVariable GruvboxBlue
line 991: hi! link clojureMacro GruvboxOrange
line 992: 
line 993: hi! link clojureMeta GruvboxYellow
line 994: hi! link clojureDeref GruvboxYellow
line 995: hi! link clojureQuote GruvboxYellow
line 996: hi! link clojureUnquote GruvboxYellow
line 997: 
line 998: " }}}
line 999: " C: {{{
line 1000: 
line 1001: hi! link cOperator GruvboxPurple
line 1002: hi! link cStructure GruvboxOrange
line 1003: 
line 1004: " }}}
line 1005: " Python: {{{
line 1006: 
line 1007: hi! link pythonBuiltin GruvboxOrange
line 1008: hi! link pythonBuiltinObj GruvboxOrange
line 1009: hi! link pythonBuiltinFunc GruvboxOrange
line 1010: hi! link pythonFunction GruvboxAqua
line 1011: hi! link pythonDecorator GruvboxRed
line 1012: hi! link pythonInclude GruvboxBlue
line 1013: hi! link pythonImport GruvboxBlue
line 1014: hi! link pythonRun GruvboxBlue
line 1015: hi! link pythonCoding GruvboxBlue
line 1016: hi! link pythonOperator GruvboxRed
line 1017: hi! link pythonException GruvboxRed
line 1018: hi! link pythonExceptions GruvboxPurple
line 1019: hi! link pythonBoolean GruvboxPurple
line 1020: hi! link pythonDot GruvboxFg3
line 1021: hi! link pythonConditional GruvboxRed
line 1022: hi! link pythonRepeat GruvboxRed
line 1023: hi! link pythonDottedName GruvboxGreenBold
line 1024: 
line 1025: " }}}
line 1026: " CSS: {{{
line 1027: 
line 1028: hi! link cssBraces GruvboxBlue
line 1029: hi! link cssFunctionName GruvboxYellow
line 1030: hi! link cssIdentifier GruvboxOrange
line 1031: hi! link cssClassName GruvboxGreen
line 1032: hi! link cssColor GruvboxBlue
line 1033: hi! link cssSelectorOp GruvboxBlue
line 1034: hi! link cssSelectorOp2 GruvboxBlue
line 1035: hi! link cssImportant GruvboxGreen
line 1036: hi! link cssVendor GruvboxFg1
line 1037: 
line 1038: hi! link cssTextProp GruvboxAqua
line 1039: hi! link cssAnimationProp GruvboxAqua
line 1040: hi! link cssUIProp GruvboxYellow
line 1041: hi! link cssTransformProp GruvboxAqua
line 1042: hi! link cssTransitionProp GruvboxAqua
line 1043: hi! link cssPrintProp GruvboxAqua
line 1044: hi! link cssPositioningProp GruvboxYellow
line 1045: hi! link cssBoxProp GruvboxAqua
line 1046: hi! link cssFontDescriptorProp GruvboxAqua
line 1047: hi! link cssFlexibleBoxProp GruvboxAqua
line 1048: hi! link cssBorderOutlineProp GruvboxAqua
line 1049: hi! link cssBackgroundProp GruvboxAqua
line 1050: hi! link cssMarginProp GruvboxAqua
line 1051: hi! link cssListProp GruvboxAqua
line 1052: hi! link cssTableProp GruvboxAqua
line 1053: hi! link cssFontProp GruvboxAqua
line 1054: hi! link cssPaddingProp GruvboxAqua
line 1055: hi! link cssDimensionProp GruvboxAqua
line 1056: hi! link cssRenderProp GruvboxAqua
line 1057: hi! link cssColorProp GruvboxAqua
line 1058: hi! link cssGeneratedContentProp GruvboxAqua
line 1059: 
line 1060: " }}}
line 1061: " JavaScript: {{{
line 1062: 
line 1063: hi! link javaScriptBraces GruvboxFg1
line 1064: hi! link javaScriptFunction GruvboxAqua
line 1065: hi! link javaScriptIdentifier GruvboxRed
line 1066: hi! link javaScriptMember GruvboxBlue
line 1067: hi! link javaScriptNumber GruvboxPurple
line 1068: hi! link javaScriptNull GruvboxPurple
line 1069: hi! link javaScriptParens GruvboxFg3
line 1070: 
line 1071: " }}}
line 1072: " YAJS: {{{
line 1073: 
line 1074: hi! link javascriptImport GruvboxAqua
line 1075: hi! link javascriptExport GruvboxAqua
line 1076: hi! link javascriptClassKeyword GruvboxAqua
line 1077: hi! link javascriptClassExtends GruvboxAqua
line 1078: hi! link javascriptDefault GruvboxAqua
line 1079: 
line 1080: hi! link javascriptClassName GruvboxYellow
line 1081: hi! link javascriptClassSuperName GruvboxYellow
line 1082: hi! link javascriptGlobal GruvboxYellow
line 1083: 
line 1084: hi! link javascriptEndColons GruvboxFg1
line 1085: hi! link javascriptFuncArg GruvboxFg1
line 1086: hi! link javascriptGlobalMethod GruvboxFg1
line 1087: hi! link javascriptNodeGlobal GruvboxFg1
line 1088: hi! link javascriptBOMWindowProp GruvboxFg1
line 1089: hi! link javascriptArrayMethod GruvboxFg1
line 1090: hi! link javascriptArrayStaticMethod GruvboxFg1
line 1091: hi! link javascriptCacheMethod GruvboxFg1
line 1092: hi! link javascriptDateMethod GruvboxFg1
line 1093: hi! link javascriptMathStaticMethod GruvboxFg1
line 1094: 
line 1095: " hi! link javascriptProp GruvboxFg1
line 1096: hi! link javascriptURLUtilsProp GruvboxFg1
line 1097: hi! link javascriptBOMNavigatorProp GruvboxFg1
line 1098: hi! link javascriptDOMDocMethod GruvboxFg1
line 1099: hi! link javascriptDOMDocProp GruvboxFg1
line 1100: hi! link javascriptBOMLocationMethod GruvboxFg1
line 1101: hi! link javascriptBOMWindowMethod GruvboxFg1
line 1102: hi! link javascriptStringMethod GruvboxFg1
line 1103: 
line 1104: hi! link javascriptVariable GruvboxOrange
line 1105: " hi! link javascriptVariable GruvboxRed
line 1106: " hi! link javascriptIdentifier GruvboxOrange
line 1107: " hi! link javascriptClassSuper GruvboxOrange
line 1108: hi! link javascriptIdentifier GruvboxOrange
line 1109: hi! link javascriptClassSuper GruvboxOrange
line 1110: 
line 1111: " hi! link javascriptFuncKeyword GruvboxOrange
line 1112: " hi! link javascriptAsyncFunc GruvboxOrange
line 1113: hi! link javascriptFuncKeyword GruvboxAqua
line 1114: hi! link javascriptAsyncFunc GruvboxAqua
line 1115: hi! link javascriptClassStatic GruvboxOrange
line 1116: 
line 1117: hi! link javascriptOperator GruvboxRed
line 1118: hi! link javascriptForOperator GruvboxRed
line 1119: hi! link javascriptYield GruvboxRed
line 1120: hi! link javascriptExceptions GruvboxRed
line 1121: hi! link javascriptMessage GruvboxRed
line 1122: 
line 1123: hi! link javascriptTemplateSB GruvboxAqua
line 1124: hi! link javascriptTemplateSubstitution GruvboxFg1
line 1125: 
line 1126: " hi! link javascriptLabel GruvboxBlue
line 1127: " hi! link javascriptObjectLabel GruvboxBlue
line 1128: " hi! link javascriptPropertyName GruvboxBlue
line 1129: hi! link javascriptLabel GruvboxFg1
line 1130: hi! link javascriptObjectLabel GruvboxFg1
line 1131: hi! link javascriptPropertyName GruvboxFg1
line 1132: 
line 1133: hi! link javascriptLogicSymbols GruvboxFg1
line 1134: hi! link javascriptArrowFunc GruvboxYellow
line 1135: 
line 1136: hi! link javascriptDocParamName GruvboxFg4
line 1137: hi! link javascriptDocTags GruvboxFg4
line 1138: hi! link javascriptDocNotation GruvboxFg4
line 1139: hi! link javascriptDocParamType GruvboxFg4
line 1140: hi! link javascriptDocNamedParamType GruvboxFg4
line 1141: 
line 1142: hi! link javascriptBrackets GruvboxFg1
line 1143: hi! link javascriptDOMElemAttrs GruvboxFg1
line 1144: hi! link javascriptDOMEventMethod GruvboxFg1
line 1145: hi! link javascriptDOMNodeMethod GruvboxFg1
line 1146: hi! link javascriptDOMStorageMethod GruvboxFg1
line 1147: hi! link javascriptHeadersMethod GruvboxFg1
line 1148: 
line 1149: hi! link javascriptAsyncFuncKeyword GruvboxRed
line 1150: hi! link javascriptAwaitFuncKeyword GruvboxRed
line 1151: 
line 1152: " }}}
line 1153: " PanglossJS: {{{
line 1154: 
line 1155: hi! link jsClassKeyword GruvboxAqua
line 1156: hi! link jsExtendsKeyword GruvboxAqua
line 1157: hi! link jsExportDefault GruvboxAqua
line 1158: hi! link jsTemplateBraces GruvboxAqua
line 1159: hi! link jsGlobalNodeObjects GruvboxFg1
line 1160: hi! link jsGlobalObjects GruvboxFg1
line 1161: hi! link jsFunction GruvboxAqua
line 1162: hi! link jsFuncParens GruvboxFg3
line 1163: hi! link jsParens GruvboxFg3
line 1164: hi! link jsNull GruvboxPurple
line 1165: hi! link jsUndefined GruvboxPurple
line 1166: hi! link jsClassDefinition GruvboxYellow
line 1167: 
line 1168: " }}}
line 1169: " TypeScript: {{{
line 1170: 
line 1171: hi! link typeScriptReserved GruvboxAqua
line 1172: hi! link typeScriptLabel GruvboxAqua
line 1173: hi! link typeScriptFuncKeyword GruvboxAqua
line 1174: hi! link typeScriptIdentifier GruvboxOrange
line 1175: hi! link typeScriptBraces GruvboxFg1
line 1176: hi! link typeScriptEndColons GruvboxFg1
line 1177: hi! link typeScriptDOMObjects GruvboxFg1
line 1178: hi! link typeScriptAjaxMethods GruvboxFg1
line 1179: hi! link typeScriptLogicSymbols GruvboxFg1
line 1180: hi! link typeScriptDocSeeTag Comment
line 1181: hi! link typeScriptDocParam Comment
line 1182: hi! link typeScriptDocTags vimCommentTitle
line 1183: hi! link typeScriptGlobalObjects GruvboxFg1
line 1184: hi! link typeScriptParens GruvboxFg3
line 1185: hi! link typeScriptOpSymbols GruvboxFg3
line 1186: hi! link typeScriptHtmlElemProperties GruvboxFg1
line 1187: hi! link typeScriptNull GruvboxPurple
line 1188: hi! link typeScriptInterpolationDelimiter GruvboxAqua
line 1189: 
line 1190: " }}}
line 1191: " PureScript: {{{
line 1192: 
line 1193: hi! link purescriptModuleKeyword GruvboxAqua
line 1194: hi! link purescriptModuleName GruvboxFg1
line 1195: hi! link purescriptWhere GruvboxAqua
line 1196: hi! link purescriptDelimiter GruvboxFg4
line 1197: hi! link purescriptType GruvboxFg1
line 1198: hi! link purescriptImportKeyword GruvboxAqua
line 1199: hi! link purescriptHidingKeyword GruvboxAqua
line 1200: hi! link purescriptAsKeyword GruvboxAqua
line 1201: hi! link purescriptStructure GruvboxAqua
line 1202: hi! link purescriptOperator GruvboxBlue
line 1203: 
line 1204: hi! link purescriptTypeVar GruvboxFg1
line 1205: hi! link purescriptConstructor GruvboxFg1
line 1206: hi! link purescriptFunction GruvboxFg1
line 1207: hi! link purescriptConditional GruvboxOrange
line 1208: hi! link purescriptBacktick GruvboxOrange
line 1209: 
line 1210: " }}}
line 1211: " CoffeeScript: {{{
line 1212: 
line 1213: hi! link coffeeExtendedOp GruvboxFg3
line 1214: hi! link coffeeSpecialOp GruvboxFg3
line 1215: hi! link coffeeCurly GruvboxOrange
line 1216: hi! link coffeeParen GruvboxFg3
line 1217: hi! link coffeeBracket GruvboxOrange
line 1218: 
line 1219: " }}}
line 1220: " Ruby: {{{
line 1221: 
line 1222: hi! link rubyStringDelimiter GruvboxGreen
line 1223: hi! link rubyInterpolationDelimiter GruvboxAqua
line 1224: 
line 1225: " }}}
line 1226: " ObjectiveC: {{{
line 1227: 
line 1228: hi! link objcTypeModifier GruvboxRed
line 1229: hi! link objcDirective GruvboxBlue
line 1230: 
line 1231: " }}}
line 1232: " Go: {{{
line 1233: 
line 1234: hi! link goDirective GruvboxAqua
line 1235: hi! link goConstants GruvboxPurple
line 1236: hi! link goDeclaration GruvboxRed
line 1237: hi! link goDeclType GruvboxBlue
line 1238: hi! link goBuiltins GruvboxOrange
line 1239: 
line 1240: " }}}
line 1241: " Lua: {{{
line 1242: 
line 1243: hi! link luaIn GruvboxRed
line 1244: hi! link luaFunction GruvboxAqua
line 1245: hi! link luaTable GruvboxOrange
line 1246: 
line 1247: " }}}
line 1248: " MoonScript: {{{
line 1249: 
line 1250: hi! link moonSpecialOp GruvboxFg3
line 1251: hi! link moonExtendedOp GruvboxFg3
line 1252: hi! link moonFunction GruvboxFg3
line 1253: hi! link moonObject GruvboxYellow
line 1254: 
line 1255: " }}}
line 1256: " Java: {{{
line 1257: 
line 1258: hi! link javaAnnotation GruvboxBlue
line 1259: hi! link javaDocTags GruvboxAqua
line 1260: hi! link javaCommentTitle vimCommentTitle
line 1261: hi! link javaParen GruvboxFg3
line 1262: hi! link javaParen1 GruvboxFg3
line 1263: hi! link javaParen2 GruvboxFg3
line 1264: hi! link javaParen3 GruvboxFg3
line 1265: hi! link javaParen4 GruvboxFg3
line 1266: hi! link javaParen5 GruvboxFg3
line 1267: hi! link javaOperator GruvboxOrange
line 1268: 
line 1269: hi! link javaVarArg GruvboxGreen
line 1270: 
line 1271: " }}}
line 1272: " Elixir: {{{
line 1273: 
line 1274: hi! link elixirDocString Comment
line 1275: 
line 1276: hi! link elixirStringDelimiter GruvboxGreen
line 1277: hi! link elixirInterpolationDelimiter GruvboxAqua
line 1278: 
line 1279: hi! link elixirModuleDeclaration GruvboxYellow
line 1280: 
line 1281: " }}}
line 1282: " Scala: {{{
line 1283: 
line 1284: " NB: scala vim syntax file is kinda horrible
line 1285: hi! link scalaNameDefinition GruvboxFg1
line 1286: hi! link scalaCaseFollowing GruvboxFg1
line 1287: hi! link scalaCapitalWord GruvboxFg1
line 1288: hi! link scalaTypeExtension GruvboxFg1
line 1289: 
line 1290: hi! link scalaKeyword GruvboxRed
line 1291: hi! link scalaKeywordModifier GruvboxRed
line 1292: 
line 1293: hi! link scalaSpecial GruvboxAqua
line 1294: hi! link scalaOperator GruvboxFg1
line 1295: 
line 1296: hi! link scalaTypeDeclaration GruvboxYellow
line 1297: hi! link scalaTypeTypePostDeclaration GruvboxYellow
line 1298: 
line 1299: hi! link scalaInstanceDeclaration GruvboxFg1
line 1300: hi! link scalaInterpolation GruvboxAqua
line 1301: 
line 1302: " }}}
line 1303: " Markdown: {{{
line 1304: 
line 1305: call s:HL('markdownItalic', s:fg3, s:none, s:italic)
calling function <SNR>14_HL('markdownItalic', ['#bdae93', 248], ['NONE', 'NONE'], '')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownItalic guifg=#bdae93 ctermfg=248 guibg=NONE ctermbg=NONE gui=NONE cterm=NONE
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1306: 
line 1307: hi! link markdownH1 GruvboxGreenBold
line 1308: hi! link markdownH2 GruvboxGreenBold
line 1309: hi! link markdownH3 GruvboxYellowBold
line 1310: hi! link markdownH4 GruvboxYellowBold
line 1311: hi! link markdownH5 GruvboxYellow
line 1312: hi! link markdownH6 GruvboxYellow
line 1313: 
line 1314: hi! link markdownCode GruvboxAqua
line 1315: hi! link markdownCodeBlock GruvboxAqua
line 1316: hi! link markdownCodeDelimiter GruvboxAqua
line 1317: 
line 1318: hi! link markdownBlockquote GruvboxGray
line 1319: hi! link markdownListMarker GruvboxGray
line 1320: hi! link markdownOrderedListMarker GruvboxGray
line 1321: hi! link markdownRule GruvboxGray
line 1322: hi! link markdownHeadingRule GruvboxGray
line 1323: 
line 1324: hi! link markdownUrlDelimiter GruvboxFg3
line 1325: hi! link markdownLinkDelimiter GruvboxFg3
line 1326: hi! link markdownLinkTextDelimiter GruvboxFg3
line 1327: 
line 1328: hi! link markdownHeadingDelimiter GruvboxOrange
line 1329: hi! link markdownUrl GruvboxPurple
line 1330: hi! link markdownUrlTitleDelimiter GruvboxGreen
line 1331: 
line 1332: call s:HL('markdownLinkText', s:gray, s:none, s:underline)
calling function <SNR>14_HL('markdownLinkText', ['#928374', 245], ['NONE', 'NONE'], 'underline,')

line 1:   " Arguments: group, guifg, guibg, gui, guisp
line 2: 
line 3:   " foreground
line 4:   let fg = a:fg
line 5: 
line 6:   " background
line 7:   if a:0 >= 1
line 8:     let bg = a:1
line 9:   else
line 10:     let bg = s:none
line 11:   endif
line 12: 
line 13:   " emphasis
line 14:   if a:0 >= 2 && strlen(a:2)
line 15:     let emstr = a:2
line 16:   else
line 17:     let emstr = 'NONE,'
line 18:   endif
line 19: 
line 20:   " special fallback
line 21:   if a:0 >= 3
line 22:     if g:gruvbox_guisp_fallback != 'NONE'
line 23:       let fg = a:3
line 24:     endif
line 25: 
line 26:     " bg fallback mode should invert higlighting
line 27:     if g:gruvbox_guisp_fallback == 'bg'
line 28:       let emstr .= 'inverse,'
line 29:     endif
line 30:   endif
line 31: 
line 32:   let histring = [ 'hi', a:group, 'guifg=' . fg[0], 'ctermfg=' . fg[1], 'guibg=' . bg[0], 'ctermbg=' . bg[1], 'gui=' . emstr[:-2], 'cterm=' . emstr[:-2] ]
line 37: 
line 38:   " special
line 39:   if a:0 >= 3
line 40:     call add(histring, 'guisp=' . a:3[0])
line 41:   endif
line 42: 
line 43:   execute join(histring, ' ')
line 43: hi markdownLinkText guifg=#928374 ctermfg=245 guibg=NONE ctermbg=NONE gui=underline cterm=underline
function <SNR>14_HL returning #0

continuing in /usr/share/vim/vimfiles/colors/gruvbox.vim

line 1333: hi! link markdownIdDeclaration markdownLinkText
line 1334: 
line 1335: " }}}
line 1336: " Haskell: {{{
line 1337: 
line 1338: " hi! link haskellType GruvboxYellow
line 1339: " hi! link haskellOperators GruvboxOrange
line 1340: " hi! link haskellConditional GruvboxAqua
line 1341: " hi! link haskellLet GruvboxOrange
line 1342: "
line 1343: hi! link haskellType GruvboxFg1
line 1344: hi! link haskellIdentifier GruvboxFg1
line 1345: hi! link haskellSeparator GruvboxFg1
line 1346: hi! link haskellDelimiter GruvboxFg4
line 1347: hi! link haskellOperators GruvboxBlue
line 1348: "
line 1349: hi! link haskellBacktick GruvboxOrange
line 1350: hi! link haskellStatement GruvboxOrange
line 1351: hi! link haskellConditional GruvboxOrange
line 1352: 
line 1353: hi! link haskellLet GruvboxAqua
line 1354: hi! link haskellDefault GruvboxAqua
line 1355: hi! link haskellWhere GruvboxAqua
line 1356: hi! link haskellBottom GruvboxAqua
line 1357: hi! link haskellBlockKeywords GruvboxAqua
line 1358: hi! link haskellImportKeywords GruvboxAqua
line 1359: hi! link haskellDeclKeyword GruvboxAqua
line 1360: hi! link haskellDeriving GruvboxAqua
line 1361: hi! link haskellAssocType GruvboxAqua
line 1362: 
line 1363: hi! link haskellNumber GruvboxPurple
line 1364: hi! link haskellPragma GruvboxPurple
line 1365: 
line 1366: hi! link haskellString GruvboxGreen
line 1367: hi! link haskellChar GruvboxGreen
line 1368: 
line 1369: " }}}
line 1370: " Json: {{{
line 1371: 
line 1372: hi! link jsonKeyword GruvboxGreen
line 1373: hi! link jsonQuote GruvboxGreen
line 1374: hi! link jsonBraces GruvboxFg1
line 1375: hi! link jsonString GruvboxFg1
line 1376: 
line 1377: " }}}
line 1378: 
line 1379: 
line 1380: " Functions -------------------------------------------------------------------
line 1381: " Search Highlighting Cursor {{{
line 1382: 
line 1383: function! GruvboxHlsShowCursor()
line 1386: 
line 1387: function! GruvboxHlsHideCursor()
line 1390: 
line 1391: " }}}
line 1392: 
line 1393: " vim: set sw=2 ts=2 sts=2 et tw=80 ft=vim fdm=marker:
finished sourcing /usr/share/vim/vimfiles/colors/gruvbox.vim
continuing in /usr/share/vim/vim81/syntax/synload.vim
line 20: else
line 21:   runtime! syntax/syncolor.vim
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/syntax/synload.vim
continuing in /usr/share/vim/vim81/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim81/syntax/syntax.vim
continuing in /home/ringu/.vimrc
line 89: 
line 90:   " I like highlighting strings inside C comments.
line 91:   " Revert with ":unlet c_comment_strings".
line 92:   let c_comment_strings=1
line 93: endif
line 94: 
line 95: " Only do this part when compiled with support for autocommands.
line 96: if has("autocmd")
line 97: 
line 98:   " Enable file type detection.
line 99:   " Use the default filetype settings, so that mail gets 'tw' set to 72,
line 100:   " 'cindent' is on in C files, etc.
line 101:   " Also load indent files, to automatically do language-dependent indenting.
line 102:   " Revert with ":filetype off".
line 103:   filetype plugin indent on
Searching for "filetype.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/filetype.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/filetype.vim"
Searching for "/home/ringu/.vim/plugged/ale/filetype.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/filetype.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/filetype.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/filetype.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim81/filetype.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2018 May 04
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/share/vim/vim81/filetype.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/filetype.vim"
Searching for "/home/ringu/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/ale/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/ftplugin.vim"
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"
Searching for "/usr/share/vim/vim81/ftplugin.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/share/vim/vim81/ftplugin.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/ftplugin.vim"
Searching for "/home/ringu/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/indent.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/indent.vim"
Searching for "/home/ringu/.vim/plugged/ale/indent.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/indent.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/indent.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/indent.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/indent.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/indent.vim"
Searching for "/usr/share/vim/vimfiles/indent.vim"
Searching for "/usr/share/vim/vim81/indent.vim"
chdir(/usr/share/vim/vim81)
fchdir() to previous dir
line 103: sourcing "/usr/share/vim/vim81/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
finished sourcing /usr/share/vim/vim81/indent.vim
continuing in /home/ringu/.vimrc
Searching for "/usr/share/vim/vimfiles/after/indent.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/indent.vim"
Searching for "/home/ringu/.vim/after/indent.vim"
line 104: 
line 105:   " Put these in an autocmd group, so that you can revert them with:
line 106:   " ":augroup vimStartup | au! | augroup END"
line 107:   augroup vimStartup
line 108:     au!
line 109: 
line 110:     " When editing a file, always jump to the last known cursor position.
line 111:     " Don't do it when the position is invalid, when inside an event handler
line 112:     " (happens when dropping a file on gvim) and for a commit message (it's
line 113:     " likely a different one than last time).
line 117:     autocmd BufReadPost * if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit' |   exe "normal! g`\"" | endif
line 118: 
line 119:   augroup END
line 120: 
line 121: endif " has("autocmd")
line 122: 
line 123: "press space to auto close tags after </
line 124: :iabbrev </ </<C-X><C-O>
line 125: 
line 126: "nerdtree is ctrl+n
line 127: map <F2> :NERDTreeToggle<CR>
line 128: 
line 129: "autocmd filetype javascript set formatprg=prettier\ --stdin
line 130: 
line 131: "remapping hjkl to jkl;
line 132: noremap ; l
line 133: noremap l k
line 134: noremap k j
line 135: noremap j h
line 136: 
line 137: imap <c-space> <Plug>(asyncomplete_force_refresh)
line 138: autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
line 139: 
line 140: if executable('flow')
line 146:   au User lsp_setup call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })
line 147: endif
line 148: 
line 149: if executable('css-languageserver')
line 154:   au User lsp_setup call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })
line 155: endif
line 156: 
line 157: let g:asyncomplete_smart_completion=1
line 158: let g:asyncomplete_auto_popup=1
line 159: 
line 160: let g:WebDevIconsUnicodeDecorateFolderNodes=1
line 161: let g:WebDevIconsNerdTreeAfterGlyphPadding=' '
line 162: let g:NERDTreeDirArrowExpandable='+'
line 163: let g:NERDTreeDirArrowCollapsible='-'
finished sourcing $HOME/.vimrc
Searching for "pack/*/start/*" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/ringu/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/lightline.vim/plugin/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: plugin/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/06/22 08:49:00.
line 6: " =============================================================================
line 7: 
line 8: if exists('g:loaded_lightline') || v:version < 700
line 9:   finish
line 10: endif
line 11: let g:loaded_lightline = 1
line 12: 
line 13: let s:save_cpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup lightline
line 17:   autocmd!
line 18:   autocmd WinEnter,BufWinEnter,FileType,SessionLoadPost * call lightline#update()
line 19:   autocmd SessionLoadPost * call lightline#highlight()
line 21:   autocmd ColorScheme * if !has('vim_starting') || expand('<amatch>') !=# 'macvim' | call lightline#update() | call lightline#highlight() | endif
line 22:   autocmd CursorMoved,BufUnload * call lightline#update_once()
line 23: augroup END
line 24: 
line 25: let &cpo = s:save_cpo
line 26: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/plugin/lightline.vim
Searching for "/home/ringu/.vim/plugged/vim-surround/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-surround/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-surround/plugin/surround.vim"
line 1: " surround.vim - Surroundings
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: " Version:      2.1
line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
line 5: 
line 6: if exists("g:loaded_surround") || &cp || v:version < 700
line 7:   finish
line 8: endif
line 9: let g:loaded_surround = 1
line 10: 
line 11: " Input functions {{{1
line 12: 
line 13: function! s:getchar()
line 20: 
line 21: function! s:inputtarget()
line 35: 
line 36: function! s:inputreplacement()
line 47: 
line 48: function! s:beep()
line 52: 
line 53: function! s:redraw()
line 57: 
line 58: " }}}1
line 59: 
line 60: " Wrapping functions {{{1
line 61: 
line 62: function! s:extractbefore(str)
line 69: 
line 70: function! s:extractafter(str)
line 77: 
line 78: function! s:fixindent(str,spc)
line 87: 
line 88: function! s:process(string)
line 126: 
line 127: function! s:wrap(string,char,type,removed,special)
line 302: 
line 303: function! s:wrapreg(reg,char,removed,special)
line 309: " }}}1
line 310: 
line 311: function! s:insert(...) " {{{1
line 353: 
line 354: function! s:reindent() " {{{1
line 359: 
line 360: function! s:dosurround(...) " {{{1
line 473: 
line 474: function! s:changesurround(...) " {{{1
line 485: 
line 486: function! s:opfunc(type, ...) abort " {{{1
line 552: 
line 553: function! s:opfunc2(...) abort
line 560: 
line 561: function! s:closematch(str) " {{{1
line 576: 
line 577: nnoremap <silent> <Plug>SurroundRepeat .
line 578: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
line 579: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
line 580: nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
line 581: nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
line 582: nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
line 583: nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
line 584: nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
line 585: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
line 586: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
line 587: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
line 588: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
line 589: 
line 590: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
line 591:   nmap ds  <Plug>Dsurround
line 592:   nmap cs  <Plug>Csurround
line 593:   nmap cS  <Plug>CSurround
line 594:   nmap ys  <Plug>Ysurround
line 595:   nmap yS  <Plug>YSurround
line 596:   nmap yss <Plug>Yssurround
line 597:   nmap ySs <Plug>YSsurround
line 598:   nmap ySS <Plug>YSsurround
line 599:   xmap S   <Plug>VSurround
line 600:   xmap gS  <Plug>VgSurround
line 601:   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
line 602:     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
line 603:       imap    <C-S> <Plug>Isurround
line 604:     endif
line 605:     imap      <C-G>s <Plug>Isurround
line 606:     imap      <C-G>S <Plug>ISurround
line 607:   endif
line 608: endif
line 609: 
line 610: " vim:set ft=vim sw=2 sts=2 et:
finished sourcing /home/ringu/.vim/plugged/vim-surround/plugin/surround.vim
Searching for "/home/ringu/.vim/plugged/auto-pairs/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/auto-pairs/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/auto-pairs/plugin/auto-pairs.vim"
line 1: " Insert or delete brackets, parens, quotes in pairs.
line 2: " Maintainer:^IJiangMiao <jiangfriend@gmail.com>
line 3: " Contributor: camthompson
line 4: " Last Change:  2017-06-17
line 5: " Version: 1.3.3
line 6: " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
line 7: " Repository: https://github.com/jiangmiao/auto-pairs
line 8: " License: MIT
line 9: 
line 10: if exists('g:AutoPairsLoaded') || &cp
line 11:   finish
line 12: end
line 13: let g:AutoPairsLoaded = 1
line 14: 
line 15: if !exists('g:AutoPairs')
line 16:   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
line 17: end
line 18: 
line 19: if !exists('g:AutoPairsParens')
line 20:   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
line 21: end
line 22: 
line 23: if !exists('g:AutoPairsMapBS')
line 24:   let g:AutoPairsMapBS = 1
line 25: end
line 26: 
line 27: " Map <C-h> as the same BS
line 28: if !exists('g:AutoPairsMapCh')
line 29:   let g:AutoPairsMapCh = 1
line 30: end
line 31: 
line 32: if !exists('g:AutoPairsMapCR')
line 33:   let g:AutoPairsMapCR = 1
line 34: end
line 35: 
line 36: if !exists('g:AutoPairsMapSpace')
line 37:   let g:AutoPairsMapSpace = 1
line 38: end
line 39: 
line 40: if !exists('g:AutoPairsCenterLine')
line 41:   let g:AutoPairsCenterLine = 1
line 42: end
line 43: 
line 44: if !exists('g:AutoPairsShortcutToggle')
line 45:   let g:AutoPairsShortcutToggle = '<M-p>'
line 46: end
line 47: 
line 48: if !exists('g:AutoPairsShortcutFastWrap')
line 49:   let g:AutoPairsShortcutFastWrap = '<M-e>'
line 50: end
line 51: 
line 52: if !exists('g:AutoPairsMoveCharacter')
line 53:   let g:AutoPairsMoveCharacter = "()[]{}\"'"
line 54: end
line 55: 
line 56: if !exists('g:AutoPairsShortcutJump')
line 57:   let g:AutoPairsShortcutJump = '<M-n>'
line 58: endif
line 59: 
line 60: " Fly mode will for closed pair to jump to closed pair instead of insert.
line 61: " also support AutoPairsBackInsert to insert pairs where jumped.
line 62: if !exists('g:AutoPairsFlyMode')
line 63:   let g:AutoPairsFlyMode = 0
line 64: endif
line 65: 
line 66: " When skipping the closed pair, look at the current and
line 67: " next line as well.
line 68: if !exists('g:AutoPairsMultilineClose')
line 69:   let g:AutoPairsMultilineClose = 1
line 70: endif
line 71: 
line 72: " Work with Fly Mode, insert pair where jumped
line 73: if !exists('g:AutoPairsShortcutBackInsert')
line 74:   let g:AutoPairsShortcutBackInsert = '<M-b>'
line 75: endif
line 76: 
line 77: if !exists('g:AutoPairsSmartQuotes')
line 78:   let g:AutoPairsSmartQuotes = 1
line 79: endif
line 80: 
line 81: " 7.4.849 support <C-G>U to avoid breaking '.'
line 82: " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
line 83: " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
line 84: if v:version > 704 || v:version == 704 && has("patch849")
line 85:   let s:Go = "\<C-G>U"
line 86: else
line 87:   let s:Go = ""
line 88: endif
line 89: 
line 90: let s:Left = s:Go."\<LEFT>"
line 91: let s:Right = s:Go."\<RIGHT>"
line 92: 
line 93: 
line 94: " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
line 95: let g:AutoPairsClosedPairs = {}
line 96: 
line 97: 
line 98: function! AutoPairsInsert(key)
line 225: 
line 226: function! AutoPairsDelete()
line 291: 
line 292: function! AutoPairsJump()
line 295: " string_chunk cannot use standalone
line 296: let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
line 297: let s:ss_pattern = '\v''' . s:string_chunk . ''''
line 298: let s:ds_pattern = '\v"'  . s:string_chunk . '"'
line 299: 
line 300: func! s:RegexpQuote(str)
line 303: 
line 304: func! s:RegexpQuoteInSquare(str)
line 307: 
line 308: " Search next open or close pair
line 309: func! s:FormatChunk(open, close)
line 320: 
line 321: " Fast wrap the word in brackets
line 322: function! AutoPairsFastWrap()
line 353: 
line 354: function! AutoPairsMap(key)
line 365: 
line 366: function! AutoPairsToggle()
line 376: 
line 377: function! AutoPairsMoveCharacter(key)
line 382: 
line 383: function! AutoPairsReturn()
line 415: 
line 416: function! AutoPairsSpace()
line 426: 
line 427: function! AutoPairsBackInsert()
line 436: 
line 437: function! AutoPairsInit()
line 505: 
line 506: function! s:ExpandMap(map)
line 511: 
line 512: function! AutoPairsTryInit()
line 576: 
line 577: " Always silent the command
line 578: inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
line 579: imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
line 580: 
line 581: 
line 582: au BufEnter * :call AutoPairsTryInit()
finished sourcing /home/ringu/.vim/plugged/auto-pairs/plugin/auto-pairs.vim
Searching for "/home/ringu/.vim/plugged/ale/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/ale/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/ale/plugin/ale.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: Main entry point for the plugin: sets up prefs and autocommands
line 3: "   Preferences can be set in vimrc files and so on to configure ale
line 4: 
line 5: " Sanity Checks
line 6: 
line 7: if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
line 8:     finish
line 9: endif
line 10: 
line 11: " Set a special flag used only by this plugin for preventing doubly
line 12: " loading the script.
line 13: let g:loaded_ale_dont_use_this_in_other_plugins_please = 1
line 14: 
line 15: " A flag for detecting if the required features are set.
line 16: if has('nvim')
line 17:     let s:has_features = has('timers') && has('nvim-0.2.0')
line 18: else
line 19:     " Check if Job and Channel functions are available, instead of the
line 20:     " features. This works better on old MacVim versions.
line 21:     let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
line 22: endif
line 23: 
line 24: if !s:has_features
line 25:     " Only output a warning if editing some special files.
line 26:     if index(['', 'gitcommit'], &filetype) == -1
line 27:         execute 'echoerr ''ALE requires NeoVim >= 0.2.0 or Vim 8 with +timers +job +channel'''
line 28:         execute 'echoerr ''Please update your editor appropriately.'''
line 29:     endif
line 30: 
line 31:     " Stop here, as it won't work.
line 32:     finish
line 33: endif
line 34: 
line 35: " Set this flag so that other plugins can use it, like airline.
line 36: let g:loaded_ale = 1
line 37: 
line 38: " This global variable is used internally by ALE for tracking information for
line 39: " each buffer which linters are being run against.
line 40: let g:ale_buffer_info = {}
line 41: " This global Dictionary tracks data for fixing code. Don't mess with it.
line 42: let g:ale_fix_buffer_data = {}
line 43: 
line 44: " User Configuration
line 45: 
line 46: " This option prevents ALE autocmd commands from being run for particular
line 47: " filetypes which can cause issues.
line 54: let g:ale_filetype_blacklist = [   'dirvish',   'nerdtree',   'qf',   'tags',   'unite',]
line 55: 
line 56: " This Dictionary configures which linters are enabled for which languages.
line 57: let g:ale_linters = get(g:, 'ale_linters', {})
line 58: " This option can be changed to only enable explicitly selected linters.
line 59: let g:ale_linters_explicit = get(g:, 'ale_linters_explicit', 0)
line 60: 
line 61: " This Dictionary configures which functions will be used for fixing problems.
line 62: let g:ale_fixers = get(g:, 'ale_fixers', {})
line 63: 
line 64: " This Dictionary allows users to set up filetype aliases for new filetypes.
line 65: let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})
line 66: 
line 67: " This flag can be set with a number of milliseconds for delaying the
line 68: " execution of a linter when text is changed. The timeout will be set and
line 69: " cleared each time text is changed, so repeated edits won't trigger the
line 70: " jobs for linting until enough time has passed after editing is done.
line 71: let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)
line 72: 
line 73: " This flag can be set to 'never' to disable linting when text is changed.
line 74: " This flag can also be set to 'insert' or 'normal' to lint when text is
line 75: " changed only in insert or normal mode respectively.
line 76: let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'always')
line 77: 
line 78: " This flag can be set to 1 to enable linting when leaving insert mode.
line 79: let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', 0)
line 80: 
line 81: " This flag can be set to 0 to disable linting when the buffer is entered.
line 82: let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', 1)
line 83: 
line 84: " This flag can be set to 1 to enable linting when a buffer is written.
line 85: let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', 1)
line 86: 
line 87: " This flag can be set to 1 to enable linting when the filetype is changed.
line 88: let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', 1)
line 89: 
line 90: " This flag can be set to 1 to enable automatically fixing files on save.
line 91: let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', 0)
line 92: 
line 93: " This flag may be set to 0 to disable ale. After ale is loaded, :ALEToggle
line 94: " should be used instead.
line 95: let g:ale_enabled = get(g:, 'ale_enabled', 1)
line 96: 
line 97: " These flags dictates if ale uses the quickfix or the loclist (loclist is the
line 98: " default, quickfix overrides loclist).
line 99: let g:ale_set_loclist = get(g:, 'ale_set_loclist', 1)
line 100: let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', 0)
line 101: 
line 102: " This flag can be set to 0 to disable setting signs.
line 103: " This is enabled by default only if the 'signs' feature exists.
line 104: let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs'))
line 105: 
line 106: " This flag can be set to 0 to disable setting error highlights.
line 107: let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax'))
line 108: 
line 109: " This flag can be set to 0 to disable echoing when the cursor moves.
line 110: let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', 1)
line 111: 
line 112: " This flag can be set to 1 to automatically show errors in the preview window.
line 113: let g:ale_cursor_detail = get(g:, 'ale_cursor_detail', 0)
line 114: 
line 115: " This flag can be set to 1 to enable virtual text when the cursor moves.
line 116: let g:ale_virtualtext_cursor = get(g:, 'ale_virtualtext_cursor', 0)
line 117: 
line 118: " This flag can be set to 1 to automatically close the preview window upon
line 119: " entering Insert Mode.
line 120: let g:ale_close_preview_on_insert = get(g:, 'ale_close_preview_on_insert', 0)
line 121: 
line 122: " This flag can be set to 0 to disable balloon support.
line 123: let g:ale_set_balloons = get(g:, 'ale_set_balloons', has('balloon_eval') && has('gui_running'))
line 124: 
line 125: " This flag can be set to 0 to disable warnings for trailing whitespace
line 126: let g:ale_warn_about_trailing_whitespace = get(g:, 'ale_warn_about_trailing_whitespace', 1)
line 127: " This flag can be set to 0 to disable warnings for trailing blank lines
line 128: let g:ale_warn_about_trailing_blank_lines = get(g:, 'ale_warn_about_trailing_blank_lines', 1)
line 129: 
line 130: " A flag for enabling or disabling the command history.
line 131: let g:ale_history_enabled = get(g:, 'ale_history_enabled', 1)
line 132: 
line 133: " A flag for storing the full output of commands in the history.
line 134: let g:ale_history_log_output = get(g:, 'ale_history_log_output', 1)
line 135: 
line 136: " Enable automatic completion with LSP servers and tsserver
line 137: let g:ale_completion_enabled = get(g:, 'ale_completion_enabled', 0)
line 138: 
line 139: " Enable automatic detection of pipenv for Python linters.
line 140: let g:ale_python_auto_pipenv = get(g:, 'ale_python_auto_pipenv', 0)
line 141: 
line 142: if g:ale_set_balloons
line 143:     call ale#balloon#Enable()
line 144: endif
line 145: 
line 146: if g:ale_completion_enabled
line 147:     call ale#completion#Enable()
line 148: endif
line 149: 
line 150: " Define commands for moving through warnings and errors.
line 151: command! -bar ALEPrevious :call ale#loclist_jumping#Jump('before', 0)
line 152: command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)
line 153: command! -bar ALENext :call ale#loclist_jumping#Jump('after', 0)
line 154: command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)
line 155: command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)
line 156: command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)
line 157: 
line 158: " A command for showing error details.
line 159: command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()
line 160: 
line 161: " Define commands for turning ALE on or off.
line 162: command! -bar ALEToggle :call ale#toggle#Toggle()
line 163: command! -bar ALEEnable :call ale#toggle#Enable()
line 164: command! -bar ALEDisable :call ale#toggle#Disable()
line 165: command! -bar ALEReset :call ale#toggle#Reset()
line 166: " Commands for turning ALE on or off for a buffer.
line 167: command! -bar ALEToggleBuffer :call ale#toggle#ToggleBuffer(bufnr(''))
line 168: command! -bar ALEEnableBuffer :call ale#toggle#EnableBuffer(bufnr(''))
line 169: command! -bar ALEDisableBuffer :call ale#toggle#DisableBuffer(bufnr(''))
line 170: command! -bar ALEResetBuffer :call ale#toggle#ResetBuffer(bufnr(''))
line 171: " A command to stop all LSP-like clients, including tsserver.
line 172: command! -bar ALEStopAllLSPs :call ale#lsp#reset#StopAllLSPs()
line 173: 
line 174: " A command for linting manually.
line 175: command! -bar ALELint :call ale#Queue(0, 'lint_file')
line 176: 
line 177: " Define a command to get information about current filetype.
line 178: command! -bar ALEInfo :call ale#debugging#Info()
line 179: " The same, but copy output to your clipboard.
line 180: command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboard()
line 181: " Copy ALE information to a file.
line 182: command! -bar -nargs=1 ALEInfoToFile :call ale#debugging#InfoToFile(<f-args>)
line 183: 
line 184: " Fix problems in files.
line 185: command! -bar -nargs=* -complete=customlist,ale#fix#registry#CompleteFixers ALEFix :call ale#fix#Fix(bufnr(''), '', <f-args>)
line 186: " Suggest registered functions to use for fixing problems.
line 187: command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)
line 188: 
line 189: " Go to definition for tsserver and LSP
line 190: command! -bar ALEGoToDefinition :call ale#definition#GoTo({})
line 191: command! -bar ALEGoToDefinitionInTab :call ale#definition#GoTo({'open_in': 'tab'})
line 192: command! -bar ALEGoToDefinitionInSplit :call ale#definition#GoTo({'open_in': 'horizontal-split'})
line 193: command! -bar ALEGoToDefinitionInVSplit :call ale#definition#GoTo({'open_in': 'vertical-split'})
line 194: 
line 195: " Find references for tsserver and LSP
line 196: command! -bar ALEFindReferences :call ale#references#Find()
line 197: 
line 198: " Show summary information for the cursor.
line 199: command! -bar ALEHover :call ale#hover#ShowAtCursor()
line 200: 
line 201: " Show documentation for the cursor.
line 202: command! -bar ALEDocumentation :call ale#hover#ShowDocumentationAtCursor()
line 203: 
line 204: " Search for appearances of a symbol, such as a type name or function name.
line 205: command! -nargs=1 ALESymbolSearch :call ale#symbol#Search(<q-args>)
line 206: 
line 207: command! -bar ALEComplete :call ale#completion#AlwaysGetCompletions(0)
line 208: 
line 209: " <Plug> mappings for commands
line 210: nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>
line 211: nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>
line 212: nnoremap <silent> <Plug>(ale_next) :ALENext<Return>
line 213: nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>
line 214: nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>
line 215: nnoremap <silent> <Plug>(ale_last) :ALELast<Return>
line 216: nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>
line 217: nnoremap <silent> <Plug>(ale_enable) :ALEEnable<Return>
line 218: nnoremap <silent> <Plug>(ale_disable) :ALEDisable<Return>
line 219: nnoremap <silent> <Plug>(ale_reset) :ALEReset<Return>
line 220: nnoremap <silent> <Plug>(ale_toggle_buffer) :ALEToggleBuffer<Return>
line 221: nnoremap <silent> <Plug>(ale_enable_buffer) :ALEEnableBuffer<Return>
line 222: nnoremap <silent> <Plug>(ale_disable_buffer) :ALEDisableBuffer<Return>
line 223: nnoremap <silent> <Plug>(ale_reset_buffer) :ALEResetBuffer<Return>
line 224: nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>
line 225: nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>
line 226: nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>
line 227: nnoremap <silent> <Plug>(ale_go_to_definition) :ALEGoToDefinition<Return>
line 228: nnoremap <silent> <Plug>(ale_go_to_definition_in_tab) :ALEGoToDefinitionInTab<Return>
line 229: nnoremap <silent> <Plug>(ale_go_to_definition_in_split) :ALEGoToDefinitionInSplit<Return>
line 230: nnoremap <silent> <Plug>(ale_go_to_definition_in_vsplit) :ALEGoToDefinitionInVSplit<Return>
line 231: nnoremap <silent> <Plug>(ale_find_references) :ALEFindReferences<Return>
line 232: nnoremap <silent> <Plug>(ale_hover) :ALEHover<Return>
line 233: nnoremap <silent> <Plug>(ale_documentation) :ALEDocumentation<Return>
line 234: inoremap <silent> <Plug>(ale_complete) <C-\><C-O>:ALEComplete<Return>
line 235: 
line 236: " Set up autocmd groups now.
line 237: call ale#events#Init()
Searching for "autoload/ale/events.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/ale/events.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/ale/events.vim"
chdir(/home/ringu/.vim/plugged/ale/autoload/ale)
fchdir() to previous dir
line 237: sourcing "/home/ringu/.vim/plugged/ale/autoload/ale/events.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>
line 2: " Description: ALE functions for autocmd events.
line 3: 
line 4: " Get the number of milliseconds since some vague, but consistent, point in
line 5: " the past.
line 6: "
line 7: " This function can be used for timing execution, etc.
line 8: "
line 9: " The time will be returned as a Number.
line 10: function! ale#events#ClockMilliseconds() abort
line 13: 
line 14: function! ale#events#QuitEvent(buffer) abort
line 18: 
line 19: function! ale#events#QuitRecently(buffer) abort
line 24: 
line 25: function! ale#events#SaveEvent(buffer) abort
line 41: 
line 42: function! ale#events#LintOnEnter(buffer) abort
line 50: 
line 51: function! ale#events#ReadOrEnterEvent(buffer) abort
line 68: 
line 69: function! ale#events#FileTypeEvent(buffer, new_filetype) abort
line 86: 
line 87: function! ale#events#FileChangedEvent(buffer) abort
line 94: 
line 95: function! ale#events#Init() abort
finished sourcing /home/ringu/.vim/plugged/ale/autoload/ale/events.vim
continuing in /home/ringu/.vim/plugged/ale/plugin/ale.vim
calling function ale#events#Init()

line 1:     " This value used to be a Boolean as a Number, and is now a String.
line 2:     let l:text_changed = '' . g:ale_lint_on_text_changed
line 3: 
line 4:     augroup ALEEvents
line 5:         autocmd!
line 6: 
line 7:         " These events always need to be set up.
line 8:         autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
line 9:         autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
line 10: 
line 11:         if g:ale_enabled
line 12:             if l:text_changed is? 'always' || l:text_changed is# '1'
line 13:                 autocmd TextChanged,TextChangedI * call ale#Queue(g:ale_lint_delay)
line 14:             elseif l:text_changed is? 'normal'
line 15:                 autocmd TextChanged * call ale#Queue(g:ale_lint_delay)
line 16:             elseif l:text_changed is? 'insert'
line 17:                 autocmd TextChangedI * call ale#Queue(g:ale_lint_delay)
line 18:             endif
line 19: 
line 20:             if g:ale_lint_on_enter
line 21:                 autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
line 22:                 " Track when the file is changed outside of Vim.
line 23:                 autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
line 24:             endif
line 25: 
line 26:             if g:ale_lint_on_filetype_changed
line 27:                 " Only start linting if the FileType actually changes after
line 28:                 " opening a buffer. The FileType will fire when buffers are opened.
line 29:                 autocmd FileType * call ale#events#FileTypeEvent(   str2nr(expand('<abuf>')),   expand('<amatch>'))
line 33:             endif
line 34: 
line 35:             if g:ale_lint_on_insert_leave
line 36:                 autocmd InsertLeave * call ale#Queue(0)
line 37:             endif
line 38: 
line 39:             if g:ale_echo_cursor || g:ale_cursor_detail
line 40:                 autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
line 41:                 " Look for a warning to echo as soon as we leave Insert mode.
line 42:                 " The script's position variable used when moving the cursor will
line 43:                 " not be changed here.
line 44:                 autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarning() | endif
line 45:             endif
line 46: 
line 47:             if g:ale_virtualtext_cursor
line 48:                 autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
line 49:                 " Look for a warning to echo as soon as we leave Insert mode.
line 50:                 " The script's position variable used when moving the cursor will
line 51:                 " not be changed here.
line 52:                 autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarning() | endif
line 53:             endif
line 54: 
line 55:             if g:ale_close_preview_on_insert
line 56:                 autocmd InsertEnter * if exists('*ale#preview#CloseIfTypeMatches') | call ale#preview#CloseIfTypeMatches('ale-preview') | endif
line 57:             endif
line 58:         endif
line 59:     augroup END
function ale#events#Init returning #0

continuing in /home/ringu/.vim/plugged/ale/plugin/ale.vim

line 238: 
line 239: " Housekeeping
line 240: 
line 241: augroup ALECleanupGroup
line 242:     autocmd!
line 243:     " Clean up buffers automatically when they are unloaded.
line 244:     autocmd BufDelete * if exists('*ale#engine#Cleanup') | call ale#engine#Cleanup(str2nr(expand('<abuf>'))) | endif
line 245:     autocmd QuitPre * call ale#events#QuitEvent(str2nr(expand('<abuf>')))
line 246: 
line 247:     if exists('##VimSuspend')
line 248:       autocmd VimSuspend * if exists('*ale#engine#CleanupEveryBuffer') | call ale#engine#CleanupEveryBuffer() | endif
line 249:     endif
line 250: augroup END
finished sourcing /home/ringu/.vim/plugged/ale/plugin/ale.vim
Searching for "/home/ringu/.vim/plugged/nerdtree/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim"
line 1: " ============================================================================
line 2: " File:        NERD_tree.vim
line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 4: " License:     This program is free software. It comes without any warranty,
line 5: "              to the extent permitted by applicable law. You can redistribute
line 6: "              it and/or modify it under the terms of the Do What The Fuck You
line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: " ============================================================================
line 11: "
line 12: " SECTION: Script init stuff {{{1
line 13: "============================================================
line 14: if exists("loaded_nerd_tree")
line 15:     finish
line 16: endif
line 17: if v:version < 700
line 18:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
line 19:     finish
line 20: endif
line 21: let loaded_nerd_tree = 1
line 22: 
line 23: "for line continuation - i.e dont want C in &cpo
line 24: let s:old_cpo = &cpo
line 25: set cpo&vim
line 26: 
line 27: "Function: s:initVariable() function {{{2
line 28: "This function is used to initialise a given variable to a given value. The
line 29: "variable is only initialised if it does not exist prior
line 30: "
line 31: "Args:
line 32: "var: the name of the var to be initialised
line 33: "value: the value to initialise var to
line 34: "
line 35: "Returns:
line 36: "1 if the var is set, 0 otherwise
line 37: function! s:initVariable(var, value)
line 44: 
line 45: "SECTION: Init variable calls and other random constants {{{2
line 46: call s:initVariable("g:NERDTreeAutoCenter", 1)
calling function <SNR>21_initVariable('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenter = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 47: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
calling function <SNR>21_initVariable('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenterThreshold = '3'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 48: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
calling function <SNR>21_initVariable('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCaseSensitiveSort = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 49: call s:initVariable("g:NERDTreeNaturalSort", 0)
calling function <SNR>21_initVariable('g:NERDTreeNaturalSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNaturalSort = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 50: call s:initVariable("g:NERDTreeSortHiddenFirst", 1)
calling function <SNR>21_initVariable('g:NERDTreeSortHiddenFirst', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortHiddenFirst = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 51: call s:initVariable("g:NERDTreeChDirMode", 0)
calling function <SNR>21_initVariable('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeChDirMode = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 52: call s:initVariable("g:NERDTreeCreatePrefix", "silent")
calling function <SNR>21_initVariable('g:NERDTreeCreatePrefix', 'silent')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCreatePrefix = 'silent'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 53: call s:initVariable("g:NERDTreeMinimalUI", 0)
calling function <SNR>21_initVariable('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMinimalUI = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 54: if !exists("g:NERDTreeIgnore")
line 55:     let g:NERDTreeIgnore = ['\~$']
line 56: endif
line 57: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
calling function <SNR>21_initVariable('g:NERDTreeBookmarksFile', '/home/ringu/.NERDTreeBookmarks')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksFile = '/home/ringu/.NERDTreeBookmarks'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 58: call s:initVariable("g:NERDTreeBookmarksSort", 1)
calling function <SNR>21_initVariable('g:NERDTreeBookmarksSort', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksSort = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 59: call s:initVariable("g:NERDTreeHighlightCursorline", 1)
calling function <SNR>21_initVariable('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHighlightCursorline = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 60: call s:initVariable("g:NERDTreeHijackNetrw", 1)
calling function <SNR>21_initVariable('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHijackNetrw = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 61: call s:initVariable('g:NERDTreeMarkBookmarks', 1)
calling function <SNR>21_initVariable('g:NERDTreeMarkBookmarks', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMarkBookmarks = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 62: call s:initVariable("g:NERDTreeMouseMode", 1)
calling function <SNR>21_initVariable('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMouseMode = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 63: call s:initVariable("g:NERDTreeNotificationThreshold", 100)
calling function <SNR>21_initVariable('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNotificationThreshold = '100'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 64: call s:initVariable("g:NERDTreeQuitOnOpen", 0)
calling function <SNR>21_initVariable('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeQuitOnOpen = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 65: call s:initVariable("g:NERDTreeRespectWildIgnore", 0)
calling function <SNR>21_initVariable('g:NERDTreeRespectWildIgnore', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRespectWildIgnore = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 66: call s:initVariable("g:NERDTreeShowBookmarks", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowBookmarks = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 67: call s:initVariable("g:NERDTreeShowFiles", 1)
calling function <SNR>21_initVariable('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowFiles = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 68: call s:initVariable("g:NERDTreeShowHidden", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowHidden = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 69: call s:initVariable("g:NERDTreeShowLineNumbers", 0)
calling function <SNR>21_initVariable('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowLineNumbers = '0'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 70: call s:initVariable("g:NERDTreeSortDirs", 1)
calling function <SNR>21_initVariable('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortDirs = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 71: 
line 72: if !nerdtree#runningWindows() && !nerdtree#runningCygwin()
Searching for "autoload/nerdtree.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/autoload)
fchdir() to previous dir
line 72: sourcing "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim"
line 1: if exists("g:loaded_nerdtree_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_autoload = 1
line 5: 
line 6: function! nerdtree#version()
line 9: 
line 10: " SECTION: General Functions {{{1
line 11: "============================================================
line 12: 
line 13: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
line 14: "inits a window tree in the current buffer if appropriate
line 15: function! nerdtree#checkForBrowse(dir)
line 26: 
line 27: "FUNCTION: s:reuseWin(dir) {{{2
line 28: "finds a NERDTree buffer with root of dir, and opens it.
line 29: function! s:reuseWin(dir) abort
line 48: 
line 49: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
line 50: " completion function for the bookmark commands
line 51: function! nerdtree#completeBookmarks(A,L,P)
line 54: 
line 55: "FUNCTION: nerdtree#compareNodes(dir) {{{2
line 56: function! nerdtree#compareNodes(n1, n2)
line 59: 
line 60: "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
line 61: function! nerdtree#compareNodesBySortKey(n1, n2)
line 93: 
line 94: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
line 95: " Issue a deprecation warning for a:func. If a second arg is given, use this
line 96: " as the deprecation message
line 97: function! nerdtree#deprecated(func, ...)
line 108: 
line 109: " FUNCTION: nerdtree#exec(cmd) {{{2
line 110: " Same as :exec cmd but with eventignore set for the duration
line 111: " to disable the autocommands used by NERDTree (BufEnter,
line 112: " BufLeave and VimEnter)
line 113: function! nerdtree#exec(cmd)
line 119: 
line 120: " FUNCTION: nerdtree#has_opt(options, name) {{{2
line 121: function! nerdtree#has_opt(options, name)
line 124: 
line 125: " FUNCTION: nerdtree#loadClassFiles() {{{2
line 126: function! nerdtree#loadClassFiles()
line 142: 
line 143: " FUNCTION: nerdtree#postSourceActions() {{{2
line 144: function! nerdtree#postSourceActions()
line 151: 
line 152: "FUNCTION: nerdtree#runningWindows(dir) {{{2
line 153: function! nerdtree#runningWindows()
line 156: 
line 157: "FUNCTION: nerdtree#runningCygwin(dir) {{{2
line 158: function! nerdtree#runningCygwin()
line 161: 
line 162: " SECTION: View Functions {{{1
line 163: "============================================================
line 164: 
line 165: "FUNCTION: nerdtree#echo  {{{2
line 166: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
line 167: "
line 168: "Args:
line 169: "msg: the message to echo
line 170: function! nerdtree#echo(msg)
line 174: 
line 175: "FUNCTION: nerdtree#echoError {{{2
line 176: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
line 177: "Args:
line 178: "msg: the message to echo
line 179: function! nerdtree#echoError(msg)
line 184: 
line 185: "FUNCTION: nerdtree#echoWarning {{{2
line 186: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
line 187: "Args:
line 188: "msg: the message to echo
line 189: function! nerdtree#echoWarning(msg)
line 194: 
line 195: "FUNCTION: nerdtree#renderView {{{2
line 196: function! nerdtree#renderView()
line 199: 
line 200: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/autoload/nerdtree.vim
continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

calling function nerdtree#runningCygwin()

line 1:     return has("win32unix")
function nerdtree#runningCygwin returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 73:     call s:initVariable("g:NERDTreeDirArrowExpandable", "")
calling function <SNR>21_initVariable('g:NERDTreeDirArrowExpandable', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 3:         return 1
line 4:     endif
line 5:     return 0
function <SNR>21_initVariable returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 74:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "")
calling function <SNR>21_initVariable('g:NERDTreeDirArrowCollapsible', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 3:         return 1
line 4:     endif
line 5:     return 0
function <SNR>21_initVariable returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 75: else
line 76:     call s:initVariable("g:NERDTreeDirArrowExpandable", "+")
line 77:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")
line 78: endif
line 79: call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)
calling function <SNR>21_initVariable('g:NERDTreeCascadeOpenSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeOpenSingleChildDir = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 80: call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)
calling function <SNR>21_initVariable('g:NERDTreeCascadeSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeSingleChildDir = '1'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 81: 
line 82: if !exists("g:NERDTreeSortOrder")
line 83:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
line 84: endif
line 85: let g:NERDTreeOldSortOrder = []
line 86: 
line 87: call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")
calling function <SNR>21_initVariable('g:NERDTreeGlyphReadOnly', 'RO')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeGlyphReadOnly = 'RO'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 88: 
line 89: " ASCII 7: bell non-printing character used to delimit items in the tree's nodes.
line 90: call s:initVariable("g:NERDTreeNodeDelimiter", "\x07")
calling function <SNR>21_initVariable('g:NERDTreeNodeDelimiter', '')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNodeDelimiter = '^G'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 91: 
line 92: if !exists('g:NERDTreeStatusline')
line 93: 
line 94:     "the exists() crap here is a hack to stop vim spazzing out when
line 95:     "loading a session that was created with an open nerd tree. It spazzes
line 96:     "because it doesnt store b:NERDTree(its a b: var, and its a hash)
line 97:     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
line 98: 
line 99: endif
line 100: call s:initVariable("g:NERDTreeWinPos", "left")
calling function <SNR>21_initVariable('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinPos = 'left'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 101: call s:initVariable("g:NERDTreeWinSize", 31)
calling function <SNR>21_initVariable('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinSize = '31'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 102: 
line 103: "init the shell commands that will be used to copy nodes, and remove dir trees
line 104: "
line 105: "Note: the space after the command is important
line 106: if nerdtree#runningWindows()
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 107:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
line 108:     call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')
line 109:     call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')
line 110: else
line 111:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
calling function <SNR>21_initVariable('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 112:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
calling function <SNR>21_initVariable('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCopyCmd = 'cp -r '
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 113: endif
line 114: 
line 115: 
line 116: "SECTION: Init variable calls for key mappings {{{2
line 117: call s:initVariable("g:NERDTreeMapActivateNode", "o")
calling function <SNR>21_initVariable('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapActivateNode = 'o'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 118: call s:initVariable("g:NERDTreeMapChangeRoot", "C")
calling function <SNR>21_initVariable('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChangeRoot = 'C'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 119: call s:initVariable("g:NERDTreeMapChdir", "cd")
calling function <SNR>21_initVariable('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChdir = 'cd'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 120: call s:initVariable("g:NERDTreeMapCloseChildren", "X")
calling function <SNR>21_initVariable('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseChildren = 'X'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 121: call s:initVariable("g:NERDTreeMapCloseDir", "x")
calling function <SNR>21_initVariable('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseDir = 'x'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 122: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
calling function <SNR>21_initVariable('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapDeleteBookmark = 'D'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 123: call s:initVariable("g:NERDTreeMapMenu", "m")
calling function <SNR>21_initVariable('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapMenu = 'm'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 124: call s:initVariable("g:NERDTreeMapHelp", "?")
calling function <SNR>21_initVariable('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapHelp = '?'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 125: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpFirstChild = 'K'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 126: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpLastChild = 'J'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 127: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 128: call s:initVariable("g:NERDTreeMapJumpParent", "p")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpParent = 'p'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 129: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 130: call s:initVariable("g:NERDTreeMapJumpRoot", "P")
calling function <SNR>21_initVariable('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpRoot = 'P'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 131: call s:initVariable("g:NERDTreeMapOpenExpl", "e")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenExpl = 'e'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 132: call s:initVariable("g:NERDTreeMapOpenInTab", "t")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTab = 't'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 133: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTabSilent = 'T'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 134: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenRecursively = 'O'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 135: call s:initVariable("g:NERDTreeMapOpenSplit", "i")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenSplit = 'i'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 136: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
calling function <SNR>21_initVariable('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenVSplit = 's'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 137: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
calling function <SNR>21_initVariable('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreview = 'go'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 138: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
calling function <SNR>21_initVariable('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewSplit = 'gi'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 139: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
calling function <SNR>21_initVariable('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewVSplit = 'gs'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 140: call s:initVariable("g:NERDTreeMapQuit", "q")
calling function <SNR>21_initVariable('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapQuit = 'q'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 141: call s:initVariable("g:NERDTreeMapRefresh", "r")
calling function <SNR>21_initVariable('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefresh = 'r'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 142: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
calling function <SNR>21_initVariable('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefreshRoot = 'R'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 143: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleBookmarks = 'B'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 144: call s:initVariable("g:NERDTreeMapToggleFiles", "F")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFiles = 'F'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 145: call s:initVariable("g:NERDTreeMapToggleFilters", "f")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFilters = 'f'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 146: call s:initVariable("g:NERDTreeMapToggleHidden", "I")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleHidden = 'I'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 147: call s:initVariable("g:NERDTreeMapToggleZoom", "A")
calling function <SNR>21_initVariable('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleZoom = 'A'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 148: call s:initVariable("g:NERDTreeMapUpdir", "u")
calling function <SNR>21_initVariable('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdir = 'u'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 149: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
calling function <SNR>21_initVariable('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 150: call s:initVariable("g:NERDTreeMapCWD", "CD")
calling function <SNR>21_initVariable('g:NERDTreeMapCWD', 'CD')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCWD = 'CD'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 151: call s:initVariable("g:NERDTreeMenuDown", "j")
calling function <SNR>21_initVariable('g:NERDTreeMenuDown', 'j')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuDown = 'j'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 152: call s:initVariable("g:NERDTreeMenuUp", "k")
calling function <SNR>21_initVariable('g:NERDTreeMenuUp', 'k')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMenuUp = 'k'
line 3:         return 1
function <SNR>21_initVariable returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 153: 
line 154: "SECTION: Load class files{{{2
line 155: call nerdtree#loadClassFiles()
calling function nerdtree#loadClassFiles()

line 1:     runtime lib/nerdtree/path.vim
Searching for "lib/nerdtree/path.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/path.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim"
line 1: " ============================================================================
line 2: " CLASS: Path
line 3: "
line 4: " The Path class provides an abstracted representation of a file system
line 5: " pathname.  Various operations on pathnames are provided and a number of
line 6: " representations of a given path name can be accessed here.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:Path = {}
line 11: let g:NERDTreePath = s:Path
line 12: 
line 13: " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1
line 14: function! s:Path.AbsolutePathFor(pathStr)
line 31: 
line 32: " FUNCTION: Path.bookmarkNames() {{{1
line 33: function! s:Path.bookmarkNames()
line 39: 
line 40: " FUNCTION: Path.cacheDisplayString() {{{1
line 41: function! s:Path.cacheDisplayString() abort
line 66: 
line 67: " FUNCTION: Path.addDelimiter() {{{1
line 68: function! s:Path.addDelimiter(line)
line 75: 
line 76: " FUNCTION: Path.changeToDir() {{{1
line 77: function! s:Path.changeToDir()
line 90: 
line 91: " FUNCTION: Path.compareTo() {{{1
line 92: "
line 93: " Compares this Path to the given path and returns 0 if they are equal, -1 if
line 94: " this Path is "less than" the given path, or 1 if it is "greater".
line 95: "
line 96: " Args:
line 97: " path: the path object to compare this to
line 98: "
line 99: " Return:
line 100: " 1, -1 or 0
line 101: function! s:Path.compareTo(path)
line 134: 
line 135: " FUNCTION: Path.Create(fullpath) {{{1
line 136: "
line 137: " Factory method.
line 138: "
line 139: " Creates a path object with the given path. The path is also created on the
line 140: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is
line 141: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.
line 142: "
line 143: " Args:
line 144: " fullpath: the full filesystem path to the file/dir to create
line 145: function! s:Path.Create(fullpath)
line 171: 
line 172: " FUNCTION: Path.copy(dest) {{{1
line 173: "
line 174: " Copies the file/dir represented by this Path to the given location
line 175: "
line 176: " Args:
line 177: " dest: the location to copy this dir/file to
line 178: function! s:Path.copy(dest)
line 197: 
line 198: " FUNCTION: Path.CopyingSupported() {{{1
line 199: "
line 200: " returns 1 if copying is supported for this OS
line 201: function! s:Path.CopyingSupported()
line 204: 
line 205: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1
line 206: "
line 207: " returns 1 if copy this path to the given location will cause files to
line 208: " overwritten
line 209: "
line 210: " Args:
line 211: " dest: the location this path will be copied to
line 212: function! s:Path.copyingWillOverwrite(dest)
line 224: 
line 225: " FUNCTION: Path.createParentDirectories(path) {{{1
line 226: "
line 227: " create parent directories for this path if needed
line 228: " without throwing any errors if those directories already exist
line 229: "
line 230: " Args:
line 231: " path: full path of the node whose parent directories may need to be created
line 232: function! s:Path.createParentDirectories(path)
line 238: 
line 239: " FUNCTION: Path.delete() {{{1
line 240: "
line 241: " Deletes the file or directory represented by this path.
line 242: "
line 243: " Throws NERDTree.Path.Deletion exceptions
line 244: function! s:Path.delete()
line 272: 
line 273: " FUNCTION: Path.displayString() {{{1
line 274: "
line 275: " Returns a string that specifies how the path should be represented as a
line 276: " string
line 277: function! s:Path.displayString()
line 284: 
line 285: " FUNCTION: Path.edit() {{{1
line 286: function! s:Path.edit()
line 289: 
line 290: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1
line 291: "
line 292: " If running windows, cache the drive letter for this path
line 293: function! s:Path.extractDriveLetter(fullpath)
line 307: 
line 308: " FUNCTION: Path.exists() {{{1
line 309: " return 1 if this path points to a location that is readable or is a directory
line 310: function! s:Path.exists()
line 314: 
line 315: " FUNCTION: Path._escChars() {{{1
line 316: function! s:Path._escChars()
line 323: 
line 324: " FUNCTION: Path.getDir() {{{1
line 325: "
line 326: " Returns this path if it is a directory, else this paths parent.
line 327: "
line 328: " Return:
line 329: " a Path object
line 330: function! s:Path.getDir()
line 337: 
line 338: " FUNCTION: Path.getParent() {{{1
line 339: "
line 340: " Returns a new path object for this paths parent
line 341: "
line 342: " Return:
line 343: " a new Path object
line 344: function! s:Path.getParent()
line 353: 
line 354: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
line 355: "
line 356: " Gets the last part of this path.
line 357: "
line 358: " Args:
line 359: " dirSlash: if 1 then a trailing slash will be added to the returned value for
line 360: " directory nodes.
line 361: function! s:Path.getLastPathComponent(dirSlash)
line 371: 
line 372: " FUNCTION: Path.getSortOrderIndex() {{{1
line 373: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches
line 374: function! s:Path.getSortOrderIndex()
line 385: 
line 386: " FUNCTION: Path._splitChunks(path) {{{1
line 387: " returns a list of path chunks
line 388: function! s:Path._splitChunks(path)
line 400: 
line 401: " FUNCTION: Path.getSortKey() {{{1
line 402: " returns a key used in compare function for sorting
line 403: function! s:Path.getSortKey()
line 427: 
line 428: " FUNCTION: Path.isHiddenUnder(path) {{{1
line 429: function! s:Path.isHiddenUnder(path)
line 447: 
line 448: " FUNCTION: Path.isUnixHiddenFile() {{{1
line 449: " check for unix hidden files
line 450: function! s:Path.isUnixHiddenFile()
line 453: 
line 454: " FUNCTION: Path.isUnixHiddenPath() {{{1
line 455: " check for unix path with hidden components
line 456: function! s:Path.isUnixHiddenPath()
line 468: 
line 469: " FUNCTION: Path.ignore(nerdtree) {{{1
line 470: " returns true if this path should be ignored
line 471: function! s:Path.ignore(nerdtree)
line 498: 
line 499: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1
line 500: " returns true if this path matches the given ignore pattern
line 501: function! s:Path._ignorePatternMatches(pattern)
line 517: 
line 518: " FUNCTION: Path.isAncestor(path) {{{1
line 519: " return 1 if this path is somewhere above the given path in the filesystem.
line 520: "
line 521: " a:path should be a dir
line 522: function! s:Path.isAncestor(path)
line 531: 
line 532: " FUNCTION: Path.isUnder(path) {{{1
line 533: " return 1 if this path is somewhere under the given path in the filesystem.
line 534: function! s:Path.isUnder(path)
line 543: 
line 544: " FUNCTION: Path.JoinPathStrings(...) {{{1
line 545: function! s:Path.JoinPathStrings(...)
line 552: 
line 553: " FUNCTION: Path.equals() {{{1
line 554: "
line 555: " Determines whether 2 path objects are "equal".
line 556: " They are equal if the paths they represent are the same
line 557: "
line 558: " Args:
line 559: " path: the other path obj to compare this with
line 560: function! s:Path.equals(path)
line 563: 
line 564: " FUNCTION: Path.New(pathStr) {{{1
line 565: function! s:Path.New(pathStr)
line 575: 
line 576: " FUNCTION: Path.Slash() {{{1
line 577: " Return the path separator used by the underlying file system.  Special
line 578: " consideration is taken for the use of the 'shellslash' option on Windows
line 579: " systems.
line 580: function! s:Path.Slash()
line 592: 
line 593: " FUNCTION: Path.Resolve() {{{1
line 594: " Invoke the vim resolve() function and return the result
line 595: " This is necessary because in some versions of vim resolve() removes trailing
line 596: " slashes while in other versions it doesn't.  This always removes the trailing
line 597: " slash
line 598: function! s:Path.Resolve(path)
line 602: 
line 603: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
line 604: "
line 605: "
line 606: " Throws NERDTree.Path.InvalidArguments exception.
line 607: function! s:Path.readInfoFromDisk(fullpath)
line 656: 
line 657: " FUNCTION: Path.refresh(nerdtree) {{{1
line 658: function! s:Path.refresh(nerdtree)
line 663: 
line 664: " FUNCTION: Path.refreshFlags(nerdtree) {{{1
line 665: function! s:Path.refreshFlags(nerdtree)
line 669: 
line 670: " FUNCTION: Path.rename() {{{1
line 671: "
line 672: " Renames this node on the filesystem
line 673: function! s:Path.rename(newPath)
line 692: 
line 693: " FUNCTION: Path.str() {{{1
line 694: " Return a string representation of this Path object.
line 695: "
line 696: " Args:
line 697: " This function takes a single dictionary (optional) with keys and values that
line 698: " specify how the returned pathname should be formatted.
line 699: "
line 700: " The dictionary may have the following keys:
line 701: "  'format'
line 702: "  'escape'
line 703: "  'truncateTo'
line 704: "
line 705: " The 'format' key may have a value of:
line 706: "  'Cd' - a string to be used with ":cd" and similar commands
line 707: "  'Edit' - a string to be used with ":edit" and similar commands
line 708: "  'UI' - a string to be displayed in the NERDTree user interface
line 709: "
line 710: " The 'escape' key, if specified, will cause the output to be escaped with
line 711: " Vim's internal "shellescape()" function.
line 712: "
line 713: " The 'truncateTo' key shortens the length of the path to that given by the
line 714: " value associated with 'truncateTo'. A '<' is prepended.
line 715: function! s:Path.str(...)
line 750: 
line 751: " FUNCTION: Path._strForUI() {{{1
line 752: function! s:Path._strForUI()
line 759: 
line 760: " FUNCTION: Path._strForCd() {{{1
line 761: " Return a string representation of this Path that is suitable for use as an
line 762: " argument to Vim's internal ":cd" command.
line 763: function! s:Path._strForCd()
line 766: 
line 767: " FUNCTION: Path._strForEdit() {{{1
line 768: " Return a string representation of this Path that is suitable for use as an
line 769: " argument to Vim's internal ":edit" command.
line 770: function! s:Path._strForEdit()
line 789: 
line 790: " FUNCTION: Path._strForGlob() {{{1
line 791: function! s:Path._strForGlob()
line 806: 
line 807: " FUNCTION: Path._str() {{{1
line 808: " Return the absolute pathname associated with this Path object.  The pathname
line 809: " returned is appropriate for the underlying file system.
line 810: function! s:Path._str()
line 820: 
line 821: " FUNCTION: Path.strTrunk() {{{1
line 822: " Gets the path without the last segment on the end.
line 823: function! s:Path.strTrunk()
line 826: 
line 827: " FUNCTION: Path.tabnr() {{{1
line 828: " return the number of the first tab that is displaying this file
line 829: "
line 830: " return 0 if no tab was found
line 831: function! s:Path.tabnr()
line 842: 
line 843: " FUNCTION: Path.WinToUnixPath(pathstr){{{1
line 844: " Takes in a windows path and returns the unix equiv
line 845: "
line 846: " A class level method
line 847: "
line 848: " Args:
line 849: " pathstr: the windows path to convert
line 850: function! s:Path.WinToUnixPath(pathstr)
line 868: 
line 869: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/path.vim
continuing in function nerdtree#loadClassFiles
line 2:     runtime lib/nerdtree/menu_controller.vim
Searching for "lib/nerdtree/menu_controller.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/menu_controller.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim"
line 1: "CLASS: MenuController
line 2: "============================================================
line 3: let s:MenuController = {}
line 4: let g:NERDTreeMenuController = s:MenuController
line 5: 
line 6: "FUNCTION: MenuController.New(menuItems) {{{1
line 7: "create a new menu controller that operates on the given menu items
line 8: function! s:MenuController.New(menuItems)
line 17: 
line 18: " FUNCTION: MenuController.showMenu() {{{1
line 19: " Enter the main loop of the NERDTree menu, prompting the user to select
line 20: " a menu item.
line 21: function! s:MenuController.showMenu()
line 49: 
line 50: "FUNCTION: MenuController._echoPrompt() {{{1
line 51: function! s:MenuController._echoPrompt()
line 63: 
line 64: "FUNCTION: MenuController._current(key) {{{1
line 65: "get the MenuItem that is currently selected
line 66: function! s:MenuController._current()
line 69: 
line 70: "FUNCTION: MenuController._handleKeypress(key) {{{1
line 71: "change the selection (if appropriate) and return 1 if the user has made
line 72: "their choice, 0 otherwise
line 73: function! s:MenuController._handleKeypress(key)
line 95: 
line 96: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
line 97: "get indexes to all menu items with the given shortcut
line 98: function! s:MenuController._allIndexesFor(shortcut)
line 109: 
line 110: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
line 111: "get the index to the next menu item with the given shortcut, starts from the
line 112: "current cursor location and wraps around to the top again if need be
line 113: function! s:MenuController._nextIndexFor(shortcut)
line 128: 
line 129: "FUNCTION: MenuController._setCmdheight() {{{1
line 130: "sets &cmdheight to whatever is needed to display the menu
line 131: function! s:MenuController._setCmdheight()
line 134: 
line 135: "FUNCTION: MenuController._saveOptions() {{{1
line 136: "set any vim options that are required to make the menu work (saving their old
line 137: "values)
line 138: function! s:MenuController._saveOptions()
line 144: 
line 145: "FUNCTION: MenuController._restoreOptions() {{{1
line 146: "restore the options we saved in _saveOptions()
line 147: function! s:MenuController._restoreOptions()
line 151: 
line 152: "FUNCTION: MenuController._cursorDown() {{{1
line 153: "move the cursor to the next menu item, skipping separators
line 154: function! s:MenuController._cursorDown()
line 168: 
line 169: "FUNCTION: MenuController._cursorUp() {{{1
line 170: "move the cursor to the previous menu item, skipping separators
line 171: function! s:MenuController._cursorUp()
line 185: 
line 186: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_controller.vim
continuing in function nerdtree#loadClassFiles
line 3:     runtime lib/nerdtree/menu_item.vim
Searching for "lib/nerdtree/menu_item.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/menu_item.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 3: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim"
line 1: "CLASS: MenuItem
line 2: "============================================================
line 3: let s:MenuItem = {}
line 4: let g:NERDTreeMenuItem = s:MenuItem
line 5: 
line 6: "FUNCTION: MenuItem.All() {{{1
line 7: "get all top level menu items
line 8: function! s:MenuItem.All()
line 14: 
line 15: "FUNCTION: MenuItem.AllEnabled() {{{1
line 16: "get all top level menu items that are currently enabled
line 17: function! s:MenuItem.AllEnabled()
line 26: 
line 27: "FUNCTION: MenuItem.Create(options) {{{1
line 28: "make a new menu item and add it to the global list
line 29: function! s:MenuItem.Create(options)
line 54: 
line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1
line 56: "make a new separator menu item and add it to the global list
line 57: function! s:MenuItem.CreateSeparator(options)
line 65: 
line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
line 67: "make a new submenu and add it to global list
line 68: function! s:MenuItem.CreateSubmenu(options)
line 74: 
line 75: "FUNCTION: MenuItem.enabled() {{{1
line 76: "return 1 if this menu item should be displayed
line 77: "
line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was
line 79: "specified
line 80: function! s:MenuItem.enabled()
line 86: 
line 87: "FUNCTION: MenuItem.execute() {{{1
line 88: "perform the action behind this menu item, if this menuitem has children then
line 89: "display a new menu for them, otherwise deletegate off to the menuitem's
line 90: "callback
line 91: function! s:MenuItem.execute()
line 101: 
line 102: "FUNCTION: MenuItem.isSeparator() {{{1
line 103: "return 1 if this menuitem is a separator
line 104: function! s:MenuItem.isSeparator()
line 107: 
line 108: "FUNCTION: MenuItem.isSubmenu() {{{1
line 109: "return 1 if this menuitem is a submenu
line 110: function! s:MenuItem.isSubmenu()
line 113: 
line 114: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/menu_item.vim
continuing in function nerdtree#loadClassFiles
line 4:     runtime lib/nerdtree/key_map.vim
Searching for "lib/nerdtree/key_map.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/key_map.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 4: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim"
line 1: "CLASS: KeyMap
line 2: "============================================================
line 3: let s:KeyMap = {}
line 4: let g:NERDTreeKeyMap = s:KeyMap
line 5: let s:keyMaps = {}
line 6: 
line 7: "FUNCTION: KeyMap.All() {{{1
line 8: function! s:KeyMap.All()
line 14: 
line 15: "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1
line 16: function! s:KeyMap.Compare(keyMap1, keyMap2)
line 28: 
line 29: "FUNCTION: KeyMap.FindFor(key, scope) {{{1
line 30: function! s:KeyMap.FindFor(key, scope)
line 33: 
line 34: "FUNCTION: KeyMap.BindAll() {{{1
line 35: function! s:KeyMap.BindAll()
line 40: 
line 41: "FUNCTION: KeyMap.bind() {{{1
line 42: function! s:KeyMap.bind()
line 59: 
line 60: "FUNCTION: KeyMap.Remove(key, scope) {{{1
line 61: function! s:KeyMap.Remove(key, scope)
line 64: 
line 65: "FUNCTION: KeyMap.invoke() {{{1
line 66: "Call the KeyMaps callback function
line 67: function! s:KeyMap.invoke(...)
line 75: 
line 76: "FUNCTION: KeyMap.Invoke() {{{1
line 77: "Find a keymapping for a:key and the current scope invoke it.
line 78: "
line 79: "Scope is determined as follows:
line 80: "   * if the cursor is on a dir node then "DirNode"
line 81: "   * if the cursor is on a file node then "FileNode"
line 82: "   * if the cursor is on a bookmark then "Bookmark"
line 83: "
line 84: "If a keymap has the scope of "all" then it will be called if no other keymap
line 85: "is found for a:key and the scope.
line 86: function! s:KeyMap.Invoke(key)
line 139: 
line 140: "FUNCTION: KeyMap.Create(options) {{{1
line 141: function! s:KeyMap.Create(options)
line 157: 
line 158: "FUNCTION: KeyMap.Add(keymap) {{{1
line 159: function! s:KeyMap.Add(keymap)
line 162: 
line 163: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim
continuing in function nerdtree#loadClassFiles
line 5:     runtime lib/nerdtree/bookmark.vim
Searching for "lib/nerdtree/bookmark.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/bookmark.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim"
line 1: " ============================================================================
line 2: " CLASS: Bookmark
line 3: "
line 4: " The Bookmark class serves two purposes:
line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.
line 6: "   (2) It provides an interface for client code to query and manipulate the
line 7: "       global list of Bookmark objects within the current Vim session.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Bookmark = {}
line 12: let g:NERDTreeBookmark = s:Bookmark
line 13: 
line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1
line 15: function! s:Bookmark.activate(nerdtree, ...)
line 18: 
line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists
line 21: " with the same name, just update the path for that bookmark
line 22: function! s:Bookmark.AddBookmark(name, path)
line 31: 
line 32: " FUNCTION: Bookmark.Bookmarks() {{{1
line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global
line 34: " variable
line 35: function! s:Bookmark.Bookmarks()
line 41: 
line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1
line 43: " class method that returns 1 if a bookmark with the given name is found, 0
line 44: " otherwise
line 45: function! s:Bookmark.BookmarkExistsFor(name)
line 53: 
line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1
line 55: " Class method that returns the Bookmark object having the specified name.
line 56: " Throws "NERDTree.BookmarkNotFoundError" if no Bookmark is found.
line 57: function! s:Bookmark.BookmarkFor(name)
line 70: 
line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1
line 72: " Class method to return an array of all bookmark names
line 73: function! s:Bookmark.BookmarkNames()
line 80: 
line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
line 82: " Class method to read all bookmarks from the bookmarks file initialize
line 83: " bookmark objects for each one.
line 84: "
line 85: " Args:
line 86: " silent - dont echo an error msg if invalid bookmarks are found
line 87: function! s:Bookmark.CacheBookmarks(silent)
line 119: 
line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1
line 121: " Class method that indicates the relative position of two bookmarks when
line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an
line 123: " option. Supports the "s:Bookmark.SortBookmarksList()" method.
line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)
line 141: 
line 142: " FUNCTION: Bookmark.ClearAll() {{{1
line 143: " Class method to delete all bookmarks.
line 144: function! s:Bookmark.ClearAll()
line 150: 
line 151: " FUNCTION: Bookmark.delete() {{{1
line 152: " Delete this bookmark. If the node for this bookmark is under the current
line 153: " root, then recache bookmarks for its Path object
line 154: function! s:Bookmark.delete()
line 158: 
line 159: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
line 160: " Returns the tree node object associated with this Bookmark.
line 161: " Throws "NERDTree.BookmarkedNodeNotFoundError" if the node is not found.
line 162: "
line 163: " Args:
line 164: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node
line 165: "   if true and from the current tree root if false
line 166: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
line 178: 
line 179: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
line 180: " Class method that returns the tree node object for the Bookmark with the
line 181: " given name. Throws "NERDTree.BookmarkNotFoundError" if a Bookmark with the
line 182: " name does not exist. Throws "NERDTree.BookmarkedNodeNotFoundError" if a
line 183: " tree node for the named Bookmark could not be found.
line 184: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
line 188: 
line 189: " FUNCTION: Bookmark.GetSelected() {{{1
line 190: " returns the Bookmark the cursor is over, or {}
line 191: function! s:Bookmark.GetSelected()
line 203: 
line 204: " FUNCTION: Bookmark.InvalidBookmarks() {{{1
line 205: " Class method to get all invalid bookmark strings read from the bookmarks
line 206: " file
line 207: function! s:Bookmark.InvalidBookmarks()
line 213: 
line 214: " FUNCTION: Bookmark.mustExist() {{{1
line 215: function! s:Bookmark.mustExist()
line 222: 
line 223: " FUNCTION: Bookmark.New(name, path) {{{1
line 224: " Create a new bookmark object with the given name and path object
line 225: function! s:Bookmark.New(name, path)
line 235: 
line 236: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
line 237: "Args:
line 238: "
line 239: "nerdtree: the tree to load open the bookmark in
line 240: "
line 241: "A dictionary containing the following keys (all optional):
line 242: "  'where': Specifies whether the node should be opened in new split/tab or in
line 243: "           the previous window. Can be either 'v' (vertical split), 'h'
line 244: "           (horizontal split), 't' (new tab) or 'p' (previous window).
line 245: "  'reuse': if a window is displaying the file then jump the cursor there
line 246: "  'keepopen': dont close the tree window
line 247: "  'stay': open the file, but keep the cursor in the tree win
line 248: "
line 249: function! s:Bookmark.open(nerdtree, ...)
line 259: 
line 260: " FUNCTION: Bookmark.openInNewTab(options) {{{1
line 261: " Create a new bookmark object with the given name and path object
line 262: function! s:Bookmark.openInNewTab(options)
line 266: 
line 267: " FUNCTION: Bookmark.setPath(path) {{{1
line 268: " makes this bookmark point to the given path
line 269: function! s:Bookmark.setPath(path)
line 272: 
line 273: " FUNCTION: Bookmark.SortBookmarksList() {{{1
line 274: " Class method that sorts the global list of bookmarks alphabetically by name.
line 275: " Note that case-sensitivity is determined by a user option.
line 276: function! s:Bookmark.SortBookmarksList()
line 279: 
line 280: " FUNCTION: Bookmark.str() {{{1
line 281: " Get the string that should be rendered in the view for this bookmark
line 282: function! s:Bookmark.str()
line 297: 
line 298: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
line 299: " Set the root of the given NERDTree to the node for this Bookmark. If a node
line 300: " for this Bookmark does not exist, a new one is initialized.
line 301: function! s:Bookmark.toRoot(nerdtree)
line 312: 
line 313: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
line 314: " Class method that makes the Bookmark with the given name the root of
line 315: " specified NERDTree.
line 316: function! s:Bookmark.ToRoot(name, nerdtree)
line 320: 
line 321: " FUNCTION: Bookmark.validate() {{{1
line 322: function! s:Bookmark.validate()
line 331: 
line 332: " FUNCTION: Bookmark.Write() {{{1
line 333: " Class method to write all bookmarks to the bookmarks file
line 334: function! s:Bookmark.Write()
line 353: 
line 354: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim
continuing in function nerdtree#loadClassFiles
line 6:     runtime lib/nerdtree/tree_file_node.vim
Searching for "lib/nerdtree/tree_file_node.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/tree_file_node.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 6: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeFileNode
line 3: "
line 4: " This class is the parent of the "TreeDirNode" class and is the "Component"
line 5: " part of the composite design pattern between the NERDTree node classes.
line 6: " ============================================================================
line 7: 
line 8: 
line 9: let s:TreeFileNode = {}
line 10: let g:NERDTreeFileNode = s:TreeFileNode
line 11: 
line 12: " FUNCTION: TreeFileNode.activate(...) {{{1
line 13: function! s:TreeFileNode.activate(...)
line 16: 
line 17: " FUNCTION: TreeFileNode.bookmark(name) {{{1
line 18: " bookmark this node with a:name
line 19: function! s:TreeFileNode.bookmark(name)
line 38: 
line 39: " FUNCTION: TreeFileNode.cacheParent() {{{1
line 40: " initializes self.parent if it isnt already
line 41: function! s:TreeFileNode.cacheParent()
line 50: 
line 51: " FUNCTION: TreeFileNode.clearBookmarks() {{{1
line 52: function! s:TreeFileNode.clearBookmarks()
line 60: 
line 61: " FUNCTION: TreeFileNode.copy(dest) {{{1
line 62: function! s:TreeFileNode.copy(dest)
line 73: 
line 74: " FUNCTION: TreeFileNode.delete {{{1
line 75: " Removes this node from the tree and calls the Delete method for its path obj
line 76: function! s:TreeFileNode.delete()
line 80: 
line 81: " FUNCTION: TreeFileNode.displayString() {{{1
line 82: "
line 83: " Returns a string that specifies how the node should be represented as a
line 84: " string
line 85: "
line 86: " Return:
line 87: " a string that can be used in the view to represent this node
line 88: function! s:TreeFileNode.displayString()
line 91: 
line 92: " FUNCTION: TreeFileNode.equals(treenode) {{{1
line 93: "
line 94: " Compares this treenode to the input treenode and returns 1 if they are the
line 95: " same node.
line 96: "
line 97: " Use this method instead of ==  because sometimes when the treenodes contain
line 98: " many children, vim seg faults when doing ==
line 99: "
line 100: " Args:
line 101: " treenode: the other treenode to compare to
line 102: function! s:TreeFileNode.equals(treenode)
line 105: 
line 106: " FUNCTION: TreeFileNode.findNode(path) {{{1
line 107: " Returns self if this node.path.Equals the given path.
line 108: " Returns {} if not equal.
line 109: "
line 110: " Args:
line 111: " path: the path object to compare against
line 112: function! s:TreeFileNode.findNode(path)
line 118: 
line 119: " FUNCTION: TreeFileNode.findSibling(direction) {{{1
line 120: " Find the next or previous sibling of this node.
line 121: "
line 122: " Args:
line 123: " direction: 0 for previous, 1 for next
line 124: "
line 125: " Return:
line 126: " The next/previous TreeFileNode object or an empty dictionary if not found.
line 127: function! s:TreeFileNode.findSibling(direction)
line 155: 
line 156: " FUNCTION: TreeFileNode.getNerdtree(){{{1
line 157: function! s:TreeFileNode.getNerdtree()
line 160: 
line 161: " FUNCTION: TreeFileNode.GetRootForTab(){{{1
line 162: " get the root node for this tab
line 163: function! s:TreeFileNode.GetRootForTab()
line 169: 
line 170: " FUNCTION: TreeFileNode.GetSelected() {{{1
line 171: " If the cursor is currently positioned on a tree node, return the node.
line 172: " Otherwise, return the empty dictionary.
line 173: function! s:TreeFileNode.GetSelected()
line 187: 
line 188: " FUNCTION: TreeFileNode.isVisible() {{{1
line 189: " returns 1 if this node should be visible according to the tree filters and
line 190: " hidden file filters (and their on/off status)
line 191: function! s:TreeFileNode.isVisible()
line 194: 
line 195: " FUNCTION: TreeFileNode.isRoot() {{{1
line 196: function! s:TreeFileNode.isRoot()
line 203: 
line 204: " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
line 205: " Returns a new TreeNode object with the given path and parent
line 206: "
line 207: " Args:
line 208: " path: file/dir that the node represents
line 209: " nerdtree: the tree the node belongs to
line 210: function! s:TreeFileNode.New(path, nerdtree)
line 221: 
line 222: " FUNCTION: TreeFileNode.open() {{{1
line 223: function! s:TreeFileNode.open(...)
line 228: 
line 229: " FUNCTION: TreeFileNode.openSplit() {{{1
line 230: " Open this node in a new window
line 231: function! s:TreeFileNode.openSplit()
line 235: 
line 236: " FUNCTION: TreeFileNode.openVSplit() {{{1
line 237: " Open this node in a new vertical window
line 238: function! s:TreeFileNode.openVSplit()
line 242: 
line 243: " FUNCTION: TreeFileNode.openInNewTab(options) {{{1
line 244: function! s:TreeFileNode.openInNewTab(options)
line 248: 
line 249: " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
line 250: " Places the cursor on the line number this node is rendered on
line 251: "
line 252: " Args:
line 253: " isJump: 1 if this cursor movement should be counted as a jump by vim
line 254: " recurseUpward: try to put the cursor on the parent if the this node isnt
line 255: " visible
line 256: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
line 275: 
line 276: " FUNCTION: TreeFileNode.refresh() {{{1
line 277: function! s:TreeFileNode.refresh()
line 280: 
line 281: " FUNCTION: TreeFileNode.refreshFlags() {{{1
line 282: function! s:TreeFileNode.refreshFlags()
line 285: 
line 286: " FUNCTION: TreeFileNode.rename() {{{1
line 287: " Calls the rename method for this nodes path obj
line 288: function! s:TreeFileNode.rename(newName)
line 301: 
line 302: " FUNCTION: TreeFileNode.renderToString {{{1
line 303: " returns a string representation for this tree to be rendered in the view
line 304: function! s:TreeFileNode.renderToString()
line 307: 
line 308: " Args:
line 309: " depth: the current depth in the tree for this call
line 310: " drawText: 1 if we should actually draw the line for this node (if 0 then the
line 311: " child nodes are rendered only)
line 312: " for each depth in the tree
line 313: function! s:TreeFileNode._renderToString(depth, drawText)
line 346: 
line 347: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim
continuing in function nerdtree#loadClassFiles
line 7:     runtime lib/nerdtree/tree_dir_node.vim
Searching for "lib/nerdtree/tree_dir_node.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/tree_dir_node.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 7: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim"
line 1: " ============================================================================
line 2: " CLASS: TreeDirNode
line 3: "
line 4: " A subclass of NERDTreeFileNode.
line 5: "
line 6: " The 'composite' part of the file/dir composite.
line 7: " ============================================================================
line 8: 
line 9: 
line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)
line 11: let g:NERDTreeDirNode = s:TreeDirNode
line 12: 
line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
line 14: " Class method that returns the highest cached ancestor of the current root.
line 15: function! s:TreeDirNode.AbsoluteTreeRoot()
line 22: 
line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1
line 24: function! s:TreeDirNode.activate(...)
line 38: 
line 39: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
line 40: " Adds the given treenode to the list of children for this node
line 41: "
line 42: " Args:
line 43: " -treenode: the node to add
line 44: " -inOrder: 1 if the new node should be inserted in sorted order
line 45: function! s:TreeDirNode.addChild(treenode, inOrder)
line 53: 
line 54: " FUNCTION: TreeDirNode.close() {{{1
line 55: " Mark this TreeDirNode as closed.
line 56: function! s:TreeDirNode.close()
line 64: 
line 65: " FUNCTION: TreeDirNode.closeChildren() {{{1
line 66: " Recursively close any directory nodes that are descendants of this node.
line 67: function! s:TreeDirNode.closeChildren()
line 75: 
line 76: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
line 77: " Instantiates a new child node for this node with the given path. The new
line 78: " nodes parent is set to this node.
line 79: "
line 80: " Args:
line 81: " path: a Path object that this node will represent/contain
line 82: " inOrder: 1 if the new node should be inserted in sorted order
line 83: "
line 84: " Returns:
line 85: " the newly created node
line 86: function! s:TreeDirNode.createChild(path, inOrder)
line 91: 
line 92: " FUNCTION: TreeDirNode.displayString() {{{1
line 93: " Assemble and return a string that can represent this TreeDirNode object in
line 94: " the NERDTree window.
line 95: function! s:TreeDirNode.displayString()
line 118: 
line 119: " FUNCTION: TreeDirNode.findNode(path) {{{1
line 120: " Will find one of the children (recursively) that has the given path
line 121: "
line 122: " Args:
line 123: " path: a path object
line 124: unlet s:TreeDirNode.findNode
line 125: function! s:TreeDirNode.findNode(path)
line 143: 
line 144: " FUNCTION: TreeDirNode.getCascade() {{{1
line 145: " Return an array of dir nodes (starting from self) that can be cascade opened.
line 146: function! s:TreeDirNode.getCascade()
line 156: 
line 157: " FUNCTION: TreeDirNode.getCascadeRoot() {{{1
line 158: " Return the first directory node in the cascade in which this directory node
line 159: " is rendered.
line 160: function! s:TreeDirNode.getCascadeRoot()
line 182: 
line 183: " FUNCTION: TreeDirNode.getChildCount() {{{1
line 184: " Returns the number of children this node has
line 185: function! s:TreeDirNode.getChildCount()
line 188: 
line 189: " FUNCTION: TreeDirNode.getChild(path) {{{1
line 190: " Returns child node of this node that has the given path or {} if no such node
line 191: " exists.
line 192: "
line 193: " This function doesnt not recurse into child dir nodes
line 194: "
line 195: " Args:
line 196: " path: a path object
line 197: function! s:TreeDirNode.getChild(path)
line 210: 
line 211: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
line 212: " returns the child at the given index
line 213: "
line 214: " Args:
line 215: " indx: the index to get the child from
line 216: " visible: 1 if only the visible children array should be used, 0 if all the
line 217: " children should be searched.
line 218: function! s:TreeDirNode.getChildByIndex(indx, visible)
line 225: 
line 226: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1
line 227: " Returns the index of the child node of this node that has the given path or
line 228: " -1 if no such node exists.
line 229: "
line 230: " This function doesnt not recurse into child dir nodes
line 231: "
line 232: " Args:
line 233: " path: a path object
line 234: function! s:TreeDirNode.getChildIndex(path)
line 256: 
line 257: " FUNCTION: TreeDirNode.getDirChildren() {{{1
line 258: " Return a list of all child nodes from "self.children" that are of type
line 259: " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.
line 260: function! s:TreeDirNode.getDirChildren()
line 263: 
line 264: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1
line 265: " Return a list of strings naming the descendants of the directory in this
line 266: " TreeDirNode object that match the specified glob pattern.
line 267: "
line 268: " Args:
line 269: " pattern: (string) the glob pattern to apply
line 270: " all: (0 or 1) if 1, include "." and ".." if they match "pattern"; if 0,
line 271: "      always exclude them
line 272: "
line 273: " Note: If the pathnames in the result list are below the working directory,
line 274: " they are returned as pathnames relative to that directory. This is because
line 275: " this function, internally, attempts to obey 'wildignore' rules that use
line 276: " relative paths.
line 277: function! s:TreeDirNode._glob(pattern, all)
line 337: 
line 338: " FUNCTION: TreeDirNode.GetSelected() {{{1
line 339: " Returns the current node if it is a dir node, or else returns the current
line 340: " nodes parent
line 341: unlet s:TreeDirNode.GetSelected
line 342: function! s:TreeDirNode.GetSelected()
line 351: 
line 352: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
line 353: " Returns the number of visible children this node has
line 354: function! s:TreeDirNode.getVisibleChildCount()
line 357: 
line 358: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1
line 359: " Returns a list of children to display for this node, in the correct order
line 360: "
line 361: " Return:
line 362: " an array of treenodes
line 363: function! s:TreeDirNode.getVisibleChildren()
line 372: 
line 373: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
line 374: " returns 1 if this node has any childre, 0 otherwise..
line 375: function! s:TreeDirNode.hasVisibleChildren()
line 378: 
line 379: " FUNCTION: TreeDirNode.isCascadable() {{{1
line 380: " true if this dir has only one visible child that is also a dir
line 381: " false if this dir is bookmarked or symlinked. Why? Two reasons:
line 382: "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.
line 383: "  2. If the parent is a symlink or is bookmarked, you end up with unparsable
line 384: "     text, and NERDTree cannot get the path of any child node.
line 385: function! s:TreeDirNode.isCascadable()
line 403: 
line 404: " FUNCTION: TreeDirNode._initChildren() {{{1
line 405: " Removes all childen from this node and re-reads them
line 406: "
line 407: " Args:
line 408: " silent: 1 if the function should not echo any "please wait" messages for
line 409: " large directories
line 410: "
line 411: " Return: the number of child nodes read
line 412: function! s:TreeDirNode._initChildren(silent)
line 444: 
line 445: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
line 446: " Return a new TreeDirNode object with the given path and parent.
line 447: "
line 448: " Args:
line 449: " path: dir that the node represents
line 450: " nerdtree: the tree the node belongs to
line 451: function! s:TreeDirNode.New(path, nerdtree)
line 467: 
line 468: " FUNCTION: TreeDirNode.open([options]) {{{1
line 469: " Open this directory node in the current tree or elsewhere if special options
line 470: " are provided. Return 0 if options were processed. Otherwise, return the
line 471: " number of new cached nodes.
line 472: function! s:TreeDirNode.open(...)
line 502: 
line 503: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1
line 504: " recursive open the dir if it has only one directory child.
line 505: "
line 506: " return the level of opened directories.
line 507: function! s:TreeDirNode.openAlong(...)
line 523: 
line 524: " FUNCTION: TreeDirNode.openExplorer() {{{1
line 525: " Open an explorer window for this node in the previous window. The explorer
line 526: " can be a NERDTree window or a netrw window.
line 527: function! s:TreeDirNode.openExplorer()
line 530: 
line 531: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1
line 532: unlet s:TreeDirNode.openInNewTab
line 533: function! s:TreeDirNode.openInNewTab(options)
line 537: 
line 538: " FUNCTION: TreeDirNode._openInNewTab() {{{1
line 539: function! s:TreeDirNode._openInNewTab()
line 543: 
line 544: " FUNCTION: TreeDirNode.openRecursively() {{{1
line 545: " Open this directory node and any descendant directory nodes whose pathnames
line 546: " are not ignored.
line 547: function! s:TreeDirNode.openRecursively()
line 556: 
line 557: " FUNCTION: TreeDirNode.refresh() {{{1
line 558: function! s:TreeDirNode.refresh()
line 595: 
line 596: " FUNCTION: TreeDirNode.refreshFlags() {{{1
line 597: unlet s:TreeDirNode.refreshFlags
line 598: function! s:TreeDirNode.refreshFlags()
line 604: 
line 605: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1
line 606: function! s:TreeDirNode.refreshDirFlags()
line 609: 
line 610: " FUNCTION: TreeDirNode.reveal(path) {{{1
line 611: " reveal the given path, i.e. cache and open all treenodes needed to display it
line 612: " in the UI
line 613: " Returns the revealed node
line 614: function! s:TreeDirNode.reveal(path, ...)
line 639: 
line 640: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1
line 641: " Remove the given treenode from "self.children".
line 642: " Throws "NERDTree.ChildNotFoundError" if the node is not found.
line 643: "
line 644: " Args:
line 645: " treenode: the node object to remove
line 646: function! s:TreeDirNode.removeChild(treenode)
line 656: 
line 657: " FUNCTION: TreeDirNode.sortChildren() {{{1
line 658: " Sort "self.children" by alphabetical order and directory priority.
line 659: function! s:TreeDirNode.sortChildren()
line 667: 
line 668: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
line 669: " Opens this directory if it is closed and vice versa
line 670: function! s:TreeDirNode.toggleOpen(...)
line 682: 
line 683: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
line 684: " Replaces the child of this with the given node (where the child node's full
line 685: " path matches a:newNode's fullpath). The search for the matching node is
line 686: " non-recursive
line 687: "
line 688: " Arg:
line 689: " newNode: the node to graft into the tree
line 690: function! s:TreeDirNode.transplantChild(newNode)
line 699: 
line 700: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim
continuing in function nerdtree#loadClassFiles
line 8:     runtime lib/nerdtree/opener.vim
Searching for "lib/nerdtree/opener.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/opener.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 8: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim"
line 1: " ============================================================================
line 2: " CLASS: Opener
line 3: "
line 4: " The Opener class defines an API for "opening" operations.
line 5: " ============================================================================
line 6: 
line 7: 
line 8: let s:Opener = {}
line 9: let g:NERDTreeOpener = s:Opener
line 10: 
line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1
line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]]
line 13: " Determine the number of windows open to this buffer number.
line 14: " Care of Yegappan Lakshman.  Thanks!
line 15: "
line 16: " Args:
line 17: " bnum: the subject buffers buffer number
line 18: function! s:Opener._bufInWindows(bnum)
line 34: 
line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1
line 36: " Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
line 37: " if the tree should be closed now.
line 38: "
line 39: " Args:
line 40: " a:newtab - boolean. If set, only close the tree now if we are opening the
line 41: " target in a new tab. This is needed because we have to close tree before we
line 42: " leave the tab
line 43: function! s:Opener._checkToCloseTree(newtab)
line 52: 
line 53: " FUNCTION: s:Opener._firstUsableWindow() {{{1
line 54: " find the window number of the first normal window
line 55: function! s:Opener._firstUsableWindow()
line 69: 
line 70: " FUNCTION: Opener._gotoTargetWin() {{{1
line 71: function! s:Opener._gotoTargetWin()
line 96: 
line 97: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
line 98: " Returns 0 if opening a file from the tree in the given window requires it to
line 99: " be split, 1 otherwise
line 100: "
line 101: " Args:
line 102: " winnumber: the number of the window in question
line 103: function! s:Opener._isWindowUsable(winnumber)
line 127: 
line 128: " FUNCTION: Opener.New(path, opts) {{{1
line 129: " Instantiate a new NERDTreeOpener object.
line 130: " Args:
line 131: " a:path: the path object that is to be opened
line 132: " a:opts: a dictionary containing the following optional keys...
line 133: "   'where': specifies whether the node should be opened in new split, in
line 134: "            a new tab or, in the last window; takes values "v", "h", or "t"
line 135: "   'reuse': if file is already shown in a window, jump there; takes values
line 136: "            "all", "currenttab", or empty
line 137: "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed
line 138: "   'stay': boolean (0 or 1); if true, remain in tree window after opening
line 139: function! s:Opener.New(path, opts)
line 153: 
line 154: " FUNCTION: Opener._newSplit() {{{1
line 155: function! s:Opener._newSplit()
line 213: 
line 214: " FUNCTION: Opener._newVSplit() {{{1
line 215: function! s:Opener._newVSplit()
line 233: 
line 234: " FUNCTION: Opener.open(target) {{{1
line 235: function! s:Opener.open(target)
line 243: 
line 244: " FUNCTION: Opener._openFile() {{{1
line 245: function! s:Opener._openFile()
line 264: 
line 265: " FUNCTION: Opener._openDirectory(node) {{{1
line 266: function! s:Opener._openDirectory(node)
line 285: 
line 286: " FUNCTION: Opener._previousWindow() {{{1
line 287: function! s:Opener._previousWindow()
line 305: 
line 306: " FUNCTION: Opener._restoreCursorPos() {{{1
line 307: function! s:Opener._restoreCursorPos()
line 311: 
line 312: " FUNCTION: Opener._reuseWindow() {{{1
line 313: " put the cursor in the first window we find for this file
line 314: "
line 315: " return 1 if we were successful
line 316: function! s:Opener._reuseWindow()
line 345: 
line 346: " FUNCTION: Opener._saveCursorPos() {{{1
line 347: function! s:Opener._saveCursorPos()
line 351: 
line 352: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/opener.vim
continuing in function nerdtree#loadClassFiles
line 9:     runtime lib/nerdtree/creator.vim
Searching for "lib/nerdtree/creator.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/creator.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 9: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim"
line 1: " ============================================================================
line 2: " CLASS: Creator
line 3: "
line 4: " This class is responsible for creating NERDTree instances.  The new NERDTree
line 5: " may be a tab tree, a window tree, or a mirrored tree.  In the process of
line 6: " creating a NERDTree, it sets up all of the window and buffer options and key
line 7: " mappings etc.
line 8: " ============================================================================
line 9: 
line 10: 
line 11: let s:Creator = {}
line 12: let g:NERDTreeCreator = s:Creator
line 13: 
line 14: " FUNCTION: s:Creator._bindMappings() {{{1
line 15: function! s:Creator._bindMappings()
line 30: 
line 31: " FUNCTION: s:Creator._broadcastInitEvent() {{{1
line 32: function! s:Creator._broadcastInitEvent()
line 35: 
line 36: " FUNCTION: s:Creator.BufNamePrefix() {{{1
line 37: function! s:Creator.BufNamePrefix()
line 40: 
line 41: " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
line 42: function! s:Creator.CreateTabTree(name)
line 46: 
line 47: " FUNCTION: s:Creator.createTabTree(a:name) {{{1
line 48: " name: the name of a bookmark or a directory
line 49: function! s:Creator.createTabTree(name)
line 75: 
line 76: " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
line 77: function! s:Creator.CreateWindowTree(dir)
line 81: 
line 82: " FUNCTION: s:Creator.createWindowTree(dir) {{{1
line 83: function! s:Creator.createWindowTree(dir)
line 108: 
line 109: " FUNCTION: s:Creator._createNERDTree(path) {{{1
line 110: function! s:Creator._createNERDTree(path, type)
line 120: 
line 121: " FUNCTION: s:Creator.CreateMirror() {{{1
line 122: function! s:Creator.CreateMirror()
line 126: 
line 127: " FUNCTION: s:Creator.createMirror() {{{1
line 128: function! s:Creator.createMirror()
line 179: 
line 180: " FUNCTION: s:Creator._createTreeWin() {{{1
line 181: " Initialize the NERDTree window.  Open the window, size it properly, set all
line 182: " local options, etc.
line 183: function! s:Creator._createTreeWin()
line 204: 
line 205: " FUNCTION: s:Creator._isBufHidden(nr) {{{1
line 206: function! s:Creator._isBufHidden(nr)
line 213: 
line 214: " FUNCTION: s:Creator.New() {{{1
line 215: function! s:Creator.New()
line 219: 
line 220: " FUNCTION: s:Creator._nextBufferName() {{{2
line 221: " returns the buffer name for the next nerd tree
line 222: function! s:Creator._nextBufferName()
line 226: 
line 227: " FUNCTION: s:Creator._nextBufferNumber() {{{2
line 228: " the number to add to the nerd tree buffer name to make the buf name unique
line 229: function! s:Creator._nextBufferNumber()
line 238: 
line 239: " FUNCTION: s:Creator._pathForString(str) {{{1
line 240: " find a bookmark or adirectory for the given string
line 241: function! s:Creator._pathForString(str)
line 267: 
line 268: " Function: s:Creator._removeTreeBufForTab()   {{{1
line 269: function! s:Creator._removeTreeBufForTab()
line 284: 
line 285: " FUNCTION: s:Creator._setCommonBufOptions() {{{1
line 286: function! s:Creator._setCommonBufOptions()
line 322: 
line 323: " FUNCTION: s:Creator._setupStatusline() {{{1
line 324: function! s:Creator._setupStatusline()
line 329: 
line 330: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
line 331: function! s:Creator._tabpagevar(tabnr, var)
line 347: 
line 348: " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
line 349: function! s:Creator.ToggleTabTree(dir)
line 353: 
line 354: " FUNCTION: s:Creator.toggleTabTree(dir) {{{1
line 355: " Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
line 356: " closed it is restored or initialized (if it doesnt exist)
line 357: "
line 358: " Args:
line 359: " dir: the full path for the root node (is only used if the NERD tree is being
line 360: " initialized.
line 361: function! s:Creator.toggleTabTree(dir)
line 376: 
line 377: " Function: s:Creator._uniq(list)   {{{1
line 378: " returns a:list without duplicates
line 379: function! s:Creator._uniq(list)
line 388: 
line 389: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/creator.vim
continuing in function nerdtree#loadClassFiles
line 10:     runtime lib/nerdtree/flag_set.vim
Searching for "lib/nerdtree/flag_set.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/flag_set.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 10: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim"
line 1: "CLASS: FlagSet
line 2: "============================================================
line 3: let s:FlagSet = {}
line 4: let g:NERDTreeFlagSet = s:FlagSet
line 5: 
line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
line 7: function! s:FlagSet.addFlag(scope, flag)
line 13: 
line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1
line 15: function! s:FlagSet.clearFlags(scope)
line 18: 
line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1
line 20: function! s:FlagSet._flagsForScope(scope)
line 26: 
line 27: "FUNCTION: FlagSet.New() {{{1
line 28: function! s:FlagSet.New()
line 33: 
line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
line 35: function! s:FlagSet.removeFlag(scope, flag)
line 43: 
line 44: "FUNCTION: FlagSet.renderToString() {{{1
line 45: function! s:FlagSet.renderToString()
line 57: 
line 58: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim
continuing in function nerdtree#loadClassFiles
line 11:     runtime lib/nerdtree/nerdtree.vim
Searching for "lib/nerdtree/nerdtree.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/nerdtree.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 11: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim"
line 1: "CLASS: NERDTree
line 2: "============================================================
line 3: let s:NERDTree = {}
line 4: let g:NERDTree = s:NERDTree
line 5: 
line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1
line 7: function! s:NERDTree.AddPathFilter(callback)
line 10: 
line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1
line 12: function! s:NERDTree.changeRoot(node)
line 32: 
line 33: "FUNCTION: s:NERDTree.Close() {{{1
line 34: "Closes the tab tree window for this tab
line 35: function! s:NERDTree.Close()
line 65: 
line 66: "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
line 67: "Closes the NERD tree window if the close on open option is set
line 68: function! s:NERDTree.CloseIfQuitOnOpen()
line 73: 
line 74: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
line 75: "Places the cursor at the top of the bookmarks table
line 76: function! s:NERDTree.CursorToBookmarkTable()
line 96: 
line 97: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
line 98: "Places the cursor in the nerd tree window
line 99: function! s:NERDTree.CursorToTreeWin()
line 103: 
line 104: " Function: s:NERDTree.ExistsForBuffer()   {{{1
line 105: " Returns 1 if a nerd tree root exists in the current buffer
line 106: function! s:NERDTree.ExistsForBuf()
line 109: 
line 110: " Function: s:NERDTree.ExistsForTab()   {{{1
line 111: " Returns 1 if a nerd tree root exists in the current tab
line 112: function! s:NERDTree.ExistsForTab()
line 120: 
line 121: function! s:NERDTree.ForCurrentBuf()
line 128: 
line 129: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
line 130: function! s:NERDTree.ForCurrentTab()
line 138: 
line 139: "FUNCTION: s:NERDTree.getRoot() {{{1
line 140: function! s:NERDTree.getRoot()
line 143: 
line 144: "FUNCTION: s:NERDTree.GetWinNum() {{{1
line 145: "gets the nerd tree window number for this tab
line 146: function! s:NERDTree.GetWinNum()
line 153: 
line 154: "FUNCTION: s:NERDTree.IsOpen() {{{1
line 155: function! s:NERDTree.IsOpen()
line 158: 
line 159: "FUNCTION: s:NERDTree.isTabTree() {{{1
line 160: function! s:NERDTree.isTabTree()
line 163: 
line 164: "FUNCTION: s:NERDTree.isWinTree() {{{1
line 165: function! s:NERDTree.isWinTree()
line 168: 
line 169: "FUNCTION: s:NERDTree.MustBeOpen() {{{1
line 170: function! s:NERDTree.MustBeOpen()
line 175: 
line 176: "FUNCTION: s:NERDTree.New() {{{1
line 177: function! s:NERDTree.New(path, type)
line 184: 
line 185: "FUNCTION: s:NERDTree.PathFilters() {{{1
line 186: function! s:NERDTree.PathFilters()
line 192: 
line 193: "FUNCTION: s:NERDTree.previousBuf() {{{1
line 194: function! s:NERDTree.previousBuf()
line 197: 
line 198: function! s:NERDTree.setPreviousBuf(bnum)
line 201: 
line 202: "FUNCTION: s:NERDTree.render() {{{1
line 203: "A convenience function - since this is called often
line 204: function! s:NERDTree.render()
line 207: 
line 208: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim
continuing in function nerdtree#loadClassFiles
line 12:     runtime lib/nerdtree/ui.vim
Searching for "lib/nerdtree/ui.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/ui.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 12: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim"
line 1: " ============================================================================
line 2: " CLASS: UI
line 3: " ============================================================================
line 4: 
line 5: 
line 6: let s:UI = {}
line 7: let g:NERDTreeUI = s:UI
line 8: 
line 9: " FUNCTION: s:UI.centerView() {{{2
line 10: " centers the nerd tree window around the cursor (provided the nerd tree
line 11: " options permit)
line 12: function! s:UI.centerView()
line 22: 
line 23: " FUNCTION: s:UI._dumpHelp  {{{1
line 24: " prints out the quick help
line 25: function! s:UI._dumpHelp()
line 128: 
line 129: 
line 130: " FUNCTION: s:UI.new(nerdtree) {{{1
line 131: function! s:UI.New(nerdtree)
line 142: 
line 143: " FUNCTION: s:UI.getPath(ln) {{{1
line 144: " Return the "Path" object for the node that is rendered on the given line
line 145: " number.  If the "up a dir" line is selected, return the "Path" object for
line 146: " the parent of the root.  Return the empty dictionary if the given line
line 147: " does not reference a tree node.
line 148: function! s:UI.getPath(ln)
line 196: 
line 197: " FUNCTION: s:UI.getLineNum(node) {{{1
line 198: " Return the line number where the given node is rendered.  Return -1 if the
line 199: " given node is not visible.
line 200: function! s:UI.getLineNum(node)
line 245: 
line 246: " FUNCTION: s:UI.getRootLineNum(){{{1
line 247: " gets the line number of the root node
line 248: function! s:UI.getRootLineNum()
line 255: 
line 256: " FUNCTION: s:UI.getShowBookmarks() {{{1
line 257: function! s:UI.getShowBookmarks()
line 260: 
line 261: " FUNCTION: s:UI.getShowFiles() {{{1
line 262: function! s:UI.getShowFiles()
line 265: 
line 266: " FUNCTION: s:UI.getShowHelp() {{{1
line 267: function! s:UI.getShowHelp()
line 270: 
line 271: " FUNCTION: s:UI.getShowHidden() {{{1
line 272: function! s:UI.getShowHidden()
line 275: 
line 276: " FUNCTION: s:UI._indentLevelFor(line) {{{1
line 277: function! s:UI._indentLevelFor(line)
line 285: 
line 286: " FUNCTION: s:UI.IndentWid() {{{1
line 287: function! s:UI.IndentWid()
line 290: 
line 291: " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
line 292: function! s:UI.isIgnoreFilterEnabled()
line 295: 
line 296: " FUNCTION: s:UI.isMinimal() {{{1
line 297: function! s:UI.isMinimal()
line 300: 
line 301: " FUNCTION: s:UI.MarkupReg() {{{1
line 302: function! s:UI.MarkupReg()
line 305: 
line 306: " FUNCTION: s:UI._renderBookmarks {{{1
line 307: function! s:UI._renderBookmarks()
line 326: 
line 327: " FUNCTION: s:UI.restoreScreenState() {{{1
line 328: "
line 329: " Sets the screen state back to what it was when nerdtree#saveScreenState was last
line 330: " called.
line 331: "
line 332: " Assumes the cursor is in the NERDTree window
line 333: function! s:UI.restoreScreenState()
line 346: 
line 347: " FUNCTION: s:UI.saveScreenState() {{{1
line 348: " Saves the current cursor position in the current buffer and the window
line 349: " scroll position
line 350: function! s:UI.saveScreenState()
line 359: 
line 360: " FUNCTION: s:UI.setShowHidden(val) {{{1
line 361: function! s:UI.setShowHidden(val)
line 364: 
line 365: " FUNCTION: s:UI._stripMarkup(line){{{1
line 366: " find the filename in the given line, and return it.
line 367: "
line 368: " Args:
line 369: " line: the subject line
line 370: function! s:UI._stripMarkup(line)
line 374: 
line 375: " FUNCTION: s:UI.render() {{{1
line 376: function! s:UI.render()
line 427: 
line 428: 
line 429: " FUNCTION: UI.renderViewSavingPosition {{{1
line 430: " Renders the tree and ensures the cursor stays on the current node or the
line 431: " current nodes parent if it is no longer available upon re-rendering
line 432: function! s:UI.renderViewSavingPosition()
line 447: 
line 448: " FUNCTION: s:UI.toggleHelp() {{{1
line 449: function! s:UI.toggleHelp()
line 452: 
line 453: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
line 454: " toggles the use of the NERDTreeIgnore option
line 455: function! s:UI.toggleIgnoreFilter()
line 460: 
line 461: " FUNCTION: s:UI.toggleShowBookmarks() {{{1
line 462: " Toggle the visibility of the Bookmark table.
line 463: function! s:UI.toggleShowBookmarks()
line 481: 
line 482: " FUNCTION: s:UI.toggleShowFiles() {{{1
line 483: " toggles the display of hidden files
line 484: function! s:UI.toggleShowFiles()
line 489: 
line 490: " FUNCTION: s:UI.toggleShowHidden() {{{1
line 491: " toggles the display of hidden files
line 492: function! s:UI.toggleShowHidden()
line 497: 
line 498: " FUNCTION: s:UI.toggleZoom() {{{1
line 499: " zoom (maximize/minimize) the NERDTree window
line 500: function! s:UI.toggleZoom()
line 510: 
line 511: " FUNCTION: s:UI.UpDirLine() {{{1
line 512: function! s:UI.UpDirLine()
line 515: 
line 516: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/ui.vim
continuing in function nerdtree#loadClassFiles
line 13:     runtime lib/nerdtree/event.vim
Searching for "lib/nerdtree/event.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/event.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 13: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim"
line 1: "CLASS: Event
line 2: "============================================================
line 3: let s:Event = {}
line 4: let g:NERDTreeEvent = s:Event
line 5: 
line 6: function! s:Event.New(nerdtree, subject, action, params) abort
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/event.vim
continuing in function nerdtree#loadClassFiles
line 14:     runtime lib/nerdtree/notifier.vim
Searching for "lib/nerdtree/notifier.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/ale/lib/nerdtree/notifier.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 14: sourcing "/home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim"
line 1: "CLASS: Notifier
line 2: "============================================================
line 3: let s:Notifier = {}
line 4: 
line 5: function! s:Notifier.AddListener(event, funcname)
line 13: 
line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
line 21: 
line 22: function! s:Notifier.GetListenersMap()
line 28: 
line 29: function! s:Notifier.GetListenersForEvent(name)
line 33: 
line 34: let g:NERDTreePathNotifier = deepcopy(s:Notifier)
finished sourcing /home/ringu/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim
continuing in function nerdtree#loadClassFiles
function nerdtree#loadClassFiles returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 156: 
line 157: " SECTION: Commands {{{1
line 158: "============================================================
line 159: call nerdtree#ui_glue#setupCommands()
Searching for "autoload/nerdtree/ui_glue.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/nerdtree/ui_glue.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree)
fchdir() to previous dir
line 159: sourcing "/home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim"
line 1: if exists("g:loaded_nerdtree_ui_glue_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_ui_glue_autoload = 1
line 5: 
line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
line 7: function! nerdtree#ui_glue#createDefaultBindings()
line 73: 
line 74: 
line 75: "SECTION: Interface bindings {{{1
line 76: "============================================================
line 77: 
line 78: "FUNCTION: s:activateAll() {{{1
line 79: "handle the user activating the updir line
line 80: function! s:activateAll()
line 85: 
line 86: " FUNCTION: s:activateDirNode(directoryNode) {{{1
line 87: function! s:activateDirNode(directoryNode)
line 96: 
line 97: "FUNCTION: s:activateFileNode() {{{1
line 98: "handle the user activating a tree node
line 99: function! s:activateFileNode(node)
line 102: 
line 103: "FUNCTION: s:activateBookmark() {{{1
line 104: "handle the user activating a bookmark
line 105: function! s:activateBookmark(bm)
line 108: 
line 109: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
line 110: " Associate the current node with the given name
line 111: function! nerdtree#ui_glue#bookmarkNode(...)
line 128: 
line 129: " FUNCTION: s:chCwd(node) {{{1
line 130: function! s:chCwd(node)
line 137: 
line 138: " FUNCTION: s:chRoot(node) {{{1
line 139: " changes the current root to the selected one
line 140: function! s:chRoot(node)
line 143: 
line 144: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
line 145: " Change the NERDTree root to match the current working directory.
line 146: function! nerdtree#ui_glue#chRootCwd()
line 149: 
line 150: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
line 151: function! nerdtree#ui_glue#clearBookmarks(bookmarks)
line 166: 
line 167: " FUNCTION: s:closeChildren(node) {{{1
line 168: " closes all childnodes of the current node
line 169: function! s:closeChildren(node)
line 174: 
line 175: " FUNCTION: s:closeCurrentDir(node) {{{1
line 176: " Close the parent directory of the current node.
line 177: function! s:closeCurrentDir(node)
line 199: 
line 200: " FUNCTION: s:closeTreeWindow() {{{1
line 201: " close the tree window
line 202: function! s:closeTreeWindow()
line 213: 
line 214: " FUNCTION: s:deleteBookmark(bookmark) {{{1
line 215: " Prompt the user to confirm the deletion of the selected bookmark.
line 216: function! s:deleteBookmark(bookmark)
line 239: 
line 240: " FUNCTION: s:displayHelp() {{{1
line 241: " toggles the help display
line 242: function! s:displayHelp()
line 247: 
line 248: " FUNCTION: s:findAndRevealPath(pathStr) {{{1
line 249: function! s:findAndRevealPath(pathStr)
line 294: 
line 295: "FUNCTION: s:handleLeftClick() {{{1
line 296: "Checks if the click should open the current node
line 297: function! s:handleLeftClick()
line 330: 
line 331: " FUNCTION: s:handleMiddleMouse() {{{1
line 332: function! s:handleMiddleMouse()
line 351: 
line 352: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
line 353: "this is needed since I cant figure out how to invoke dict functions from a
line 354: "key map
line 355: function! nerdtree#ui_glue#invokeKeyMap(key)
line 358: 
line 359: " FUNCTION: s:jumpToFirstChild(node) {{{1
line 360: function! s:jumpToFirstChild(node)
line 363: 
line 364: " FUNCTION: s:jumpToLastChild(node) {{{1
line 365: function! s:jumpToLastChild(node)
line 368: 
line 369: " FUNCTION: s:jumpToChild(node, last) {{{2
line 370: " Jump to the first or last child node at the same file system level.
line 371: "
line 372: " Args:
line 373: " node: the node on which the cursor currently sits
line 374: " last: 1 (true) if jumping to last child, 0 (false) if jumping to first
line 375: function! s:jumpToChild(node, last)
line 390: 
line 391: " FUNCTION: s:jumpToParent(node) {{{1
line 392: " Move the cursor to the parent of the specified node.  For a cascade, move to
line 393: " the parent of the cascade's first node.  At the root node, do nothing.
line 394: function! s:jumpToParent(node)
line 409: 
line 410: " FUNCTION: s:jumpToRoot() {{{1
line 411: " moves the cursor to the root node
line 412: function! s:jumpToRoot()
line 416: 
line 417: " FUNCTION: s:jumpToNextSibling(node) {{{1
line 418: function! s:jumpToNextSibling(node)
line 421: 
line 422: " FUNCTION: s:jumpToPrevSibling(node) {{{1
line 423: function! s:jumpToPrevSibling(node)
line 426: 
line 427: " FUNCTION: s:jumpToSibling(node, forward) {{{2
line 428: " Move the cursor to the next or previous node at the same file system level.
line 429: "
line 430: " Args:
line 431: " node: the node on which the cursor currently sits
line 432: " forward: 0 to jump to previous sibling, 1 to jump to next sibling
line 433: function! s:jumpToSibling(node, forward)
line 444: 
line 445: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
line 446: " Open the Bookmark that has the specified name. This function provides the
line 447: " implementation for the ":OpenBookmark" command.
line 448: function! nerdtree#ui_glue#openBookmark(name)
line 461: 
line 462: " FUNCTION: s:openHSplit(target) {{{1
line 463: function! s:openHSplit(target)
line 466: 
line 467: " FUNCTION: s:openVSplit(target) {{{1
line 468: function! s:openVSplit(target)
line 471: 
line 472: " FUNCTION: s:openExplorer(node) {{{1
line 473: function! s:openExplorer(node)
line 476: 
line 477: " FUNCTION: s:openInNewTab(target) {{{1
line 478: function! s:openInNewTab(target)
line 482: 
line 483: " FUNCTION: s:openInNewTabSilent(target) {{{1
line 484: function! s:openInNewTabSilent(target)
line 488: 
line 489: " FUNCTION: s:openNodeRecursively(node) {{{1
line 490: function! s:openNodeRecursively(node)
line 497: 
line 498: "FUNCTION: s:previewNodeCurrent(node) {{{1
line 499: function! s:previewNodeCurrent(node)
line 502: 
line 503: "FUNCTION: s:previewNodeHSplit(node) {{{1
line 504: function! s:previewNodeHSplit(node)
line 507: 
line 508: "FUNCTION: s:previewNodeVSplit(node) {{{1
line 509: function! s:previewNodeVSplit(node)
line 512: 
line 513: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
line 514: " put the cursor on the node associate with the given name
line 515: function! nerdtree#ui_glue#revealBookmark(name)
line 523: 
line 524: " FUNCTION: s:refreshRoot() {{{1
line 525: " Reloads the current root. All nodes below this will be lost and the root dir
line 526: " will be reloaded.
line 527: function! s:refreshRoot()
line 541: 
line 542: " FUNCTION: s:refreshCurrent(node) {{{1
line 543: " refreshes the root for the current node
line 544: function! s:refreshCurrent(node)
line 556: 
line 557: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
line 558: function! nerdtree#ui_glue#setupCommands()
line 569: 
line 570: " Function: s:SID()   {{{1
line 571: function s:SID()
line 577: 
line 578: " FUNCTION: s:showMenu(node) {{{1
line 579: function! s:showMenu(node)
line 583: 
line 584: " FUNCTION: s:toggleIgnoreFilter() {{{1
line 585: function! s:toggleIgnoreFilter()
line 588: 
line 589: " FUNCTION: s:toggleShowBookmarks() {{{1
line 590: function! s:toggleShowBookmarks()
line 593: 
line 594: " FUNCTION: s:toggleShowFiles() {{{1
line 595: function! s:toggleShowFiles()
line 598: 
line 599: " FUNCTION: s:toggleShowHidden() {{{1
line 600: " toggles the display of hidden files
line 601: function! s:toggleShowHidden()
line 604: 
line 605: " FUNCTION: s:toggleZoom() {{{1
line 606: function! s:toggleZoom()
line 609: 
line 610: " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1
line 611: " Move the NERDTree up one level.
line 612: "
line 613: " Args:
line 614: " preserveState: if 1, the current root is left open when the new tree is
line 615: " rendered; if 0, the current root node is closed
line 616: function! nerdtree#ui_glue#upDir(preserveState)
line 638: 
line 639: " FUNCTION: s:upDirCurrentRootOpen() {{{1
line 640: function! s:upDirCurrentRootOpen()
line 643: 
line 644: " FUNCTION: s:upDirCurrentRootClosed() {{{1
line 645: function! s:upDirCurrentRootClosed()
line 648: 
line 649: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim
continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#ui_glue#setupCommands()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
line 6:     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')
line 7:     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()
line 8:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
line 9:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
function nerdtree#ui_glue#setupCommands returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 160: 
line 161: " SECTION: Auto commands {{{1
line 162: "============================================================
line 163: augroup NERDTree
line 164:     "Save the cursor position whenever we close the nerd tree
line 165:     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"
calling function 185()

line 1:     return 'NERD_tree_'
function 185 returning 'NERD_tree_'

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 165: autocmd BufLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
line 166: 
line 167:     "disallow insert mode in the NERDTree
line 168:     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
calling function 185()

line 1:     return 'NERD_tree_'
function 185 returning 'NERD_tree_'

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 168: autocmd BufEnter NERD_tree_* stopinsert
line 169: augroup END
line 170: 
line 171: if g:NERDTreeHijackNetrw
line 172:     augroup NERDTreeHijackNetrw
line 173:         autocmd VimEnter * silent! autocmd! FileExplorer
line 174:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
line 175:     augroup END
line 176: endif
line 177: 
line 178: " SECTION: Public API {{{1
line 179: "============================================================
line 180: function! NERDTreeAddMenuItem(options)
line 183: 
line 184: function! NERDTreeAddMenuSeparator(...)
line 188: 
line 189: function! NERDTreeAddSubmenu(options)
line 192: 
line 193: function! NERDTreeAddKeyMap(options)
line 196: 
line 197: function! NERDTreeRender()
line 200: 
line 201: function! NERDTreeFocus()
line 208: 
line 209: function! NERDTreeCWD()
line 233: 
line 234: function! NERDTreeAddPathFilter(callback)
line 237: 
line 238: " SECTION: Post Source Actions {{{1
line 239: call nerdtree#postSourceActions()
calling function nerdtree#postSourceActions()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)
calling function nerdtree#postSourceActions[1]..86(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i != ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13:                 let path = fnamemodify(path, ':p')
line 14: 
line 15:                 try
line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
line 17:                     call add(g:NERDTreeBookmarks, bookmark)
line 18:                 catch /^NERDTree.InvalidArgumentsError/
line 19:                     call add(g:NERDTreeInvalidBookmarks, i)
line 20:                     let invalidBookmarksFound += 1
line 21:                 endtry
line 22:             endif
line 23:         endfor
line 24:         if invalidBookmarksFound
line 25:             call s:Bookmark.Write()
line 26:             if !a:silent
line 27:                 call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
line 28:             endif
line 29:         endif
line 30:     endif
function nerdtree#postSourceActions[1]..86 returning #0

continuing in function nerdtree#postSourceActions

line 2:     call nerdtree#ui_glue#createDefaultBindings()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings()

line 1:     let s = '<SNR>' . s:SID() . '_'
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>37_SID()

line 1:     if !exists("s:sid")
line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
line 3:     endif
line 4:     return s:sid
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>37_SID returning '37'

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 2: 
line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>37_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>37_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[4]..72('<MiddleMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>37_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>37_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[4]..72('<LeftRelease>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>37_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>37_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>37_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>37_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>37_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>37_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[4]..72('<2-LeftMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...7_activateAll', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 9: 
line 10: 
line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>37_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>37_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_activateDirNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>37_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>37_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_activateFileNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>37_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>37_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_activateBookmark', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 14:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78({'key': 'o', 'scope': 'all', 'callback': '<SNR>37_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[4]..72('o', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_activateAll', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 15: 
line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap({'key': 'i', 'scope': 'Node', 'callback': '<SNR>37_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78({'key': 'i', 'scope': 'Node', 'callback': '<SNR>37_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[4]..72('i', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_openHSplit', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap({'key': 's', 'scope': 'Node', 'callback': '<SNR>37_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78({'key': 's', 'scope': 'Node', 'callback': '<SNR>37_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[4]..72('s', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_openVSplit', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 18: 
line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Node', 'callback': '<SNR>37_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78({'key': 'go', 'scope': 'Node', 'callback': '<SNR>37_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[4]..72('go', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_previewNodeCurrent', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 20:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>37_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>37_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[4]..72('gs', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_previewNodeVSplit', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 21:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>37_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>37_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[4]..72('gi', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_previewNodeHSplit', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[21]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 22: 
line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>37_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>37_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[4]..72('O', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_openNodeRecursively', 'key': 'O'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 24: 
line 25:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap({'key': 'u', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78({'key': 'u', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[4]..72('u', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...37_upDirCurrentRootClosed', 'key': 'u'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[25]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap({'key': 'U', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78({'key': 'U', 'scope': 'all', 'callback': '<SNR>37_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[4]..72('U', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...R>37_upDirCurrentRootOpen', 'key': 'U'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap({'key': 'C', 'scope': 'Node', 'callback': '<SNR>37_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78({'key': 'C', 'scope': 'Node', 'callback': '<SNR>37_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[4]..72('C', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...allback': '<SNR>37_chRoot', 'key': 'C'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 28: 
line 29:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>37_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>37_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[4]..72('cd', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...allback': '<SNR>37_chCwd', 'key': 'cd'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[29]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 30: 
line 31:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap({'key': 'q', 'scope': 'all', 'callback': '<SNR>37_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78({'key': 'q', 'scope': 'all', 'callback': '<SNR>37_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[4]..72('q', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_closeTreeWindow', 'key': 'q'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[31]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 32: 
line 33:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[4]..72('CD', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 34: 
line 35:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap({'key': 'R', 'scope': 'all', 'callback': '<SNR>37_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78({'key': 'R', 'scope': 'all', 'callback': '<SNR>37_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[4]..72('R', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_refreshRoot', 'key': 'R'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[35]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap({'key': 'r', 'scope': 'Node', 'callback': '<SNR>37_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78({'key': 'r', 'scope': 'Node', 'callback': '<SNR>37_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[4]..72('r', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...: '<SNR>37_refreshCurrent', 'key': 'r'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 37: 
line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap({'key': '?', 'scope': 'all', 'callback': '<SNR>37_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78({'key': '?', 'scope': 'all', 'callback': '<SNR>37_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[4]..72('?', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ck': '<SNR>37_displayHelp', 'key': '?'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 39:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap({'key': 'A', 'scope': 'all', 'callback': '<SNR>37_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78({'key': 'A', 'scope': 'all', 'callback': '<SNR>37_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[4]..72('A', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_toggleZoom', 'key': 'A'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[39]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap({'key': 'I', 'scope': 'all', 'callback': '<SNR>37_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78({'key': 'I', 'scope': 'all', 'callback': '<SNR>37_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[4]..72('I', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_toggleShowHidden', 'key': 'I'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 41:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap({'key': 'f', 'scope': 'all', 'callback': '<SNR>37_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78({'key': 'f', 'scope': 'all', 'callback': '<SNR>37_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[4]..72('f', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_toggleIgnoreFilter', 'key': 'f'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[41]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap({'key': 'F', 'scope': 'all', 'callback': '<SNR>37_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78({'key': 'F', 'scope': 'all', 'callback': '<SNR>37_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[4]..72('F', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_toggleShowFiles', 'key': 'F'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap({'key': 'B', 'scope': 'all', 'callback': '<SNR>37_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78({'key': 'B', 'scope': 'all', 'callback': '<SNR>37_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[4]..72('B', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...NR>37_toggleShowBookmarks', 'key': 'B'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 44: 
line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap({'key': 'x', 'scope': 'Node', 'callback': '<SNR>37_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78({'key': 'x', 'scope': 'Node', 'callback': '<SNR>37_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[4]..72('x', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_closeCurrentDir', 'key': 'x'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>37_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>37_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[4]..72('X', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...': '<SNR>37_closeChildren', 'key': 'X'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 47: 
line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap({'key': 'm', 'scope': 'Node', 'callback': '<SNR>37_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78({'key': 'm', 'scope': 'Node', 'callback': '<SNR>37_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[4]..72('m', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...lback': '<SNR>37_showMenu', 'key': 'm'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 49: 
line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap({'key': 'p', 'scope': 'Node', 'callback': '<SNR>37_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78({'key': 'p', 'scope': 'Node', 'callback': '<SNR>37_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[4]..72('p', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_jumpToParent', 'key': 'p'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap({'key': 'K', 'scope': 'Node', 'callback': '<SNR>37_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78({'key': 'K', 'scope': 'Node', 'callback': '<SNR>37_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[4]..72('K', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...'<SNR>37_jumpToFirstChild', 'key': 'K'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[51]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap({'key': 'J', 'scope': 'Node', 'callback': '<SNR>37_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78({'key': 'J', 'scope': 'Node', 'callback': '<SNR>37_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[4]..72('J', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun... '<SNR>37_jumpToLastChild', 'key': 'J'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap({'key': 'P', 'scope': 'all', 'callback': '<SNR>37_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78({'key': 'P', 'scope': 'all', 'callback': '<SNR>37_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[4]..72('P', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...ack': '<SNR>37_jumpToRoot', 'key': 'P'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 54:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>37_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>37_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[4]..72('<C-j>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...>37_jumpToNextSibling', 'key': '<C-j>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[54]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>37_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>37_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[4]..72('<C-k>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...>37_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 56: 
line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Node', 'callback': '<SNR>37_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78({'key': 't', 'scope': 'Node', 'callback': '<SNR>37_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[4]..72('t', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Node', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78({'key': 'T', 'scope': 'Node', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[4]..72('T', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[4]..72('t', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>37_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[4]..72('T', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...SNR>37_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 61: 
line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>37_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>37_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[4]..72('e', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...k': '<SNR>37_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 63: 
line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>37_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>37_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[4]..72('D', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[4]..72 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[14]..79({'All': function('70'), 'BindAll': fun...: '<SNR>37_deleteBookmark', 'key': 'D'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78[14]..79 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..78 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings returning #0

continuing in function nerdtree#postSourceActions

line 3: 
line 4:     "load all nerdtree plugins
line 5:     runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/ale/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim"
line 1: " ============================================================================
line 2: " File:        exec_menuitem.vim
line 3: " Description: plugin for NERD Tree that provides an execute file menu item
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_exec_menuitem")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_exec_menuitem = 1
line 16: 
line 21: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning []

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeExecFile', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim

line 22: 
line 23: function! NERDTreeExecFileActive()
line 27: 
line 28: function! NERDTreeExecFile()
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/exec_menuitem.vim
continuing in function nerdtree#postSourceActions
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim"
line 1: " ============================================================================
line 2: " File:        fs_menu.vim
line 3: " Description: plugin for the NERD Tree that provides a file system menu
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_fs_menu")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_fs_menu = 1
line 16: 
line 17: "Automatically delete the buffer after deleting or renaming a file
line 18: if !exists("g:NERDTreeAutoDeleteBuffer")
line 19:     let g:NERDTreeAutoDeleteBuffer = 0
line 20: endif
line 21: 
line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeExecFile', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...TreeAddNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...reeAddNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeMoveNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeMoveNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...eDeleteNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 25: 
line 26: if has("gui_mac") || has("gui_macvim") || has("mac")
line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
line 30: endif
line 31: 
line 32: if executable("xdg-open")
line 33:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeRevealFileLinux'...veal the current node in file manager'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...DeleteNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...alFileLinux', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 34:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeExecuteFileLinux...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...lFileLinux', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...teFileLinux', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 35: endif
line 36: 
line 37: if g:NERDTreePath.CopyingSupported()
calling function 9()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
function 9 returning #1

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 38:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eFileLinux', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeCopyNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 39: endif
line 40: 
line 41: if has("unix") || has("osx")
line 42:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..63({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..63[20]..61()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..63[20]..61 returning [{'All': function('61'), 'isActiveCall...eeCopyNode', 'Create': function('63')}]

continuing in function NERDTreeAddMenuItem[1]..63

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..63 returning {'All': function('61'), 'isActiveCallb...reeListNode', 'Create': function('63')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim

line 43: else
line 44:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
line 45: endif
line 46: 
line 47: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
line 48: "prints out the given msg and, if the user responds by pushing 'y' then the
line 49: "buffer with the given bufnum is deleted
line 50: "
line 51: "Args:
line 52: "bufnum: the buffer that may be deleted
line 53: "msg: a message that will be echoed to the user asking them if they wish to
line 54: "     del the buffer
line 55: function! s:promptToDelBuffer(bufnum, msg)
line 85: 
line 86: "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1
line 87: "The buffer with the given bufNum is replaced with a new one
line 88: "
line 89: "Args:
line 90: "bufNum: the buffer that may be deleted
line 91: "newNodeName: the name given to the renamed node
line 92: "isDirectory: determines how to do the create the new filenames
line 93: function! s:renameBuffer(bufNum, newNodeName, isDirectory)
line 113: "FUNCTION: NERDTreeAddNode(){{{1
line 114: function! NERDTreeAddNode()
line 147: 
line 148: "FUNCTION: NERDTreeMoveNode(){{{1
line 149: function! NERDTreeMoveNode()
line 198: 
line 199: " FUNCTION: NERDTreeDeleteNode() {{{1
line 200: function! NERDTreeDeleteNode()
line 243: 
line 244: " FUNCTION: NERDTreeListNode() {{{1
line 245: function! NERDTreeListNode()
line 265: 
line 266: " FUNCTION: NERDTreeListNodeWin32() {{{1
line 267: function! NERDTreeListNodeWin32()
line 283: 
line 284: " FUNCTION: NERDTreeCopyNode() {{{1
line 285: function! NERDTreeCopyNode()
line 325: 
line 326: " FUNCTION: NERDTreeQuickLook() {{{1
line 327: function! NERDTreeQuickLook()
line 333: 
line 334: " FUNCTION: NERDTreeRevealInFinder() {{{1
line 335: function! NERDTreeRevealInFinder()
line 341: 
line 342: " FUNCTION: NERDTreeExecuteFile() {{{1
line 343: function! NERDTreeExecuteFile()
line 349: 
line 350: " FUNCTION: NERDTreeRevealFileLinux() {{{1
line 351: function! NERDTreeRevealFileLinux()
line 358: 
line 359: " FUNCTION: NERDTreeExecuteFileLinux() {{{1
line 360: function! NERDTreeExecuteFileLinux()
line 366: 
line 367: " vim: set sw=4 sts=4 et fdm=marker:
line 368: 
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/fs_menu.vim
continuing in function nerdtree#postSourceActions
chdir(/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim"
line 1: " ============================================================================
line 2: " File:        vcs.vim
line 3: " Description: NERDTree plugin that provides a command to open on the root of
line 4: "              a version control system repository.
line 5: " Maintainer:  Phil Runninger
line 6: " License:     This program is free software. It comes without any warranty,
line 7: "              to the extent permitted by applicable law. You can redistribute
line 8: "              it and/or modify it under the terms of the Do What The Fuck You
line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 11: "
line 12: " ============================================================================
line 13: command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')
line 14: 
line 15: " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1
line 16: function! s:CreateTabTreeVCS(name)
line 21: 
line 22: " FUNCTION: s:FindParentVCSRoot(a:path) {{{1
line 23: " Finds the root version control system folder of the given path. If a:path is
line 24: " not part of a repository, return the original path.
line 25: function! s:FindParentVCSRoot(path)
line 38: 
finished sourcing /home/ringu/.vim/plugged/nerdtree/nerdtree_plugin/vcs.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/ringu/.vim/plugged/emmet-vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim"
line 1: " Version: 0.10.0
line 2: " Webpage: https://github.com/ryanoasis/vim-devicons
line 3: " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
line 4: " License: see LICENSE
line 5: 
line 6: " @todo fix duplicate global variable initialize here:
line 7: if !exists('g:webdevicons_enable')
line 8:   let g:webdevicons_enable = 1
line 9: endif
line 10: 
line 11: if !exists('g:webdevicons_enable_nerdtree')
line 12:   let g:webdevicons_enable_nerdtree = 1
line 13: endif
line 14: 
line 15: if !exists('g:DevIconsEnableFoldersOpenClose')
line 16:   let g:DevIconsEnableFoldersOpenClose = 0
line 17: endif
line 18: 
line 19: if !exists('g:DevIconsEnableFolderPatternMatching')
line 20:   let g:DevIconsEnableFolderPatternMatching = 1
line 21: endif
line 22: 
line 23: if !exists('g:DevIconsEnableFolderExtensionPatternMatching')
line 24:   let g:DevIconsEnableFolderExtensionPatternMatching = 0
line 25: endif
line 26: 
line 27: " end @todo duplicate global variables
line 28: 
line 29: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 30: " actual font patcher)
line 31: if !exists('g:webdevicons_gui_glyph_fix')
line 32:   if has('gui_running')
line 33:     let g:webdevicons_gui_glyph_fix = 1
line 34:   else
line 35:     let g:webdevicons_gui_glyph_fix = 0
line 36:   endif
line 37: endif
line 38: 
line 39: if !exists('g:DevIconsEnableNERDTreeRedraw')
line 40:   if has('gui_running')
line 41:     let g:DevIconsEnableNERDTreeRedraw = 1
line 42:   else
line 43:     let g:DevIconsEnableNERDTreeRedraw = 0
line 44:   endif
line 45: endif
line 46: 
line 47: if g:webdevicons_enable_nerdtree == 1
line 48:   if !exists('g:loaded_nerd_tree')
line 50:      echohl WarningMsg | echomsg 'vim-webdevicons requires NERDTree to be loaded before vim-webdevicons.'
line 50:  echomsg 'vim-webdevicons requires NERDTree to be loaded before vim-webdevicons.'
line 51:   endif
line 52: 
line 53:   if exists('g:loaded_nerd_tree') && g:loaded_nerd_tree == 1 && !exists('g:NERDTreePathNotifier')
line 54:      let g:webdevicons_enable_nerdtree = 0
line 56:      echohl WarningMsg | echomsg 'vim-webdevicons requires a newer version of NERDTree to show glyphs in NERDTree - consider updating NERDTree.'
line 56:  echomsg 'vim-webdevicons requires a newer version of NERDTree to show glyphs in NERDTree - consider updating NERDTree.'
line 57:   endif
line 58: 
line 59:   " @todo I don't even want this to execute UNLESS the user has the
line 60:   " 'nerdtree-git-plugin' INSTALLED (not LOADED)
line 61:   " As it currently functions this warning will display even if the user does
line 62:   " not have nerdtree-git-plugin not just if it isn't loaded yet 
line 63:   " (not what we want)
line 64:   "if !exists('g:loaded_nerdtree_git_status')
line 65:   "   echohl WarningMsg |
line 66:   "     \ echomsg 'vim-webdevicons works better when 'nerdtree-git-plugin' is loaded before vim-webdevicons (small refresh issues otherwise).'
line 67:   "endif
line 68: endif
line 69: 
line 70: if !exists('g:webdevicons_enable_airline_tabline')
line 71:   let g:webdevicons_enable_airline_tabline = 1
line 72: endif
line 73: 
line 74: if !exists('g:webdevicons_enable_airline_statusline')
line 75:   let g:webdevicons_enable_airline_statusline = 1
line 76: endif
line 77: 
line 78: function! s:SetupListeners()
line 83: 
line 84: " util like helpers
line 85: " scope: local
line 86: function! s:Refresh()
line 90: 
line 91: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 92: " actual font patcher)
line 93: 
line 94: " NERDTree-C
line 95: " scope: global
line 96: function! WebDevIconsNERDTreeChangeRootHandler(node)
line 104: 
line 105: " NERDTree-u
line 106: " scope: global
line 107: function! WebDevIconsNERDTreeUpDirCurrentRootClosedHandler()
line 113: 
line 114: function! WebDevIconsNERDTreeDirUpdateFlags(node, glyph)
line 151: 
line 152: function! WebDevIconsNERDTreeDirClose(node)
line 157: 
line 158: function! WebDevIconsNERDTreeDirOpen(node)
line 163: 
line 164: function! WebDevIconsNERDTreeDirOpenRecursively(node)
line 172: 
line 173: function! WebDevIconsNERDTreeDirCloseRecursively(node)
line 181: 
line 182: function! WebDevIconsNERDTreeDirCloseChildren(node)
line 189: 
line 190: " NERDTreeMapActivateNode and <2-LeftMouse>
line 191: " handle the user activating a tree node
line 192: " scope: global
line 193: function! WebDevIconsNERDTreeMapActivateNode(node)
line 209: 
line 210: function! WebDevIconsNERDTreeMapOpenRecursively(node)
line 223: 
line 224: function! WebDevIconsNERDTreeMapCloseChildren(node)
line 236: 
line 237: function! WebDevIconsNERDTreeMapCloseDir(node)
line 262: 
line 263: function! WebDevIconsNERDTreeMapUpdirKeepOpen()
line 273: 
line 274: if g:webdevicons_enable == 1 && g:webdevicons_enable_nerdtree == 1
line 275:   call s:SetupListeners()
calling function <SNR>41_SetupListeners()

line 1:   call g:NERDTreePathNotifier.AddListener('init', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[1]..263('init', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[1]..263[1]..266('init')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[1]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[1]..263[1]..266[1]..265 returning {}

continuing in function <SNR>41_SetupListeners[1]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[1]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[1]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[1]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[1]..263[3]..265 returning {}

continuing in function <SNR>41_SetupListeners[1]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[1]..263 returning #0

continuing in function <SNR>41_SetupListeners

line 2:   call g:NERDTreePathNotifier.AddListener('refresh', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[2]..263('refresh', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[2]..263[1]..266('refresh')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[2]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[2]..263[1]..266[1]..265 returning {'init': ['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[2]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[2]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[2]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[2]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[2]..263[3]..265 returning {'init': ['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[2]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[2]..263 returning #0

continuing in function <SNR>41_SetupListeners

line 3:   call g:NERDTreePathNotifier.AddListener('refreshFlags', 'NERDTreeWebDevIconsRefreshListener')
calling function <SNR>41_SetupListeners[3]..263('refreshFlags', 'NERDTreeWebDevIconsRefreshListener')

line 1:     let listeners = s:Notifier.GetListenersForEvent(a:event)
calling function <SNR>41_SetupListeners[3]..263[1]..266('refreshFlags')

line 1:     let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[3]..263[1]..266[1]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[3]..263[1]..266[1]..265 returning {'init': ['NERDTreeWebDevIconsRefreshL...['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[3]..263[1]..266

line 2:     return get(listenersMap, a:name, [])
function <SNR>41_SetupListeners[3]..263[1]..266 returning []

continuing in function <SNR>41_SetupListeners[3]..263

line 2:     if listeners == []
line 3:         let listenersMap = s:Notifier.GetListenersMap()
calling function <SNR>41_SetupListeners[3]..263[3]..265()

line 1:     if !exists("s:refreshListenersMap")
line 2:         let s:refreshListenersMap = {}
line 3:     endif
line 4:     return s:refreshListenersMap
function <SNR>41_SetupListeners[3]..263[3]..265 returning {'init': ['NERDTreeWebDevIconsRefreshL...['NERDTreeWebDevIconsRefreshListener']}

continuing in function <SNR>41_SetupListeners[3]..263

line 4:         let listenersMap[a:event] = listeners
line 5:     endif
line 6:     call add(listeners, a:funcname)
function <SNR>41_SetupListeners[3]..263 returning #0

continuing in function <SNR>41_SetupListeners

function <SNR>41_SetupListeners returning #0

continuing in /home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim

line 276: 
line 277:   if g:DevIconsEnableFoldersOpenClose
line 278: 
line 279:     " These overrides are needed because we cannot
line 280:     " simply use AddListener for reliably updating
line 281:     " the folder open/close glyphs because the event
line 282:     " path has no access to the 'isOpen' property
line 283:     " some of these are a little more brittle/fragile
line 284:     " than others
line 285:     " TODO FIXME better way to reliably update
line 286:     " open/close glyphs in NERDTreeWebDevIconsRefreshListener
line 287: 
line 288:     " NERDTreeMapActivateNode
line 293:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'callback': 'WebDevIconsNERDTreeMapActivateNode', 'override': 1, 'scope': 'DirNode' })
line 294: 
line 295:     " NERDTreeMapOpenRecursively
line 300:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'callback': 'WebDevIconsNERDTreeMapOpenRecursively', 'override': 1, 'scope': 'DirNode' })
line 301: 
line 302:     " NERDTreeMapCloseChildren
line 307:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'callback': 'WebDevIconsNERDTreeMapCloseChildren', 'override': 1, 'scope': 'DirNode' })
line 308: 
line 309:     " NERDTreeMapCloseChildren
line 314:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'callback': 'WebDevIconsNERDTreeMapCloseDir', 'override': 1, 'scope': 'Node' })
line 315: 
line 316:     " <2-LeftMouse>
line 321:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'callback': 'WebDevIconsNERDTreeMapActivateNode', 'override': 1, 'scope': 'DirNode' })
line 322: 
line 323:     " NERDTreeMapUpdirKeepOpen
line 328:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'callback': 'WebDevIconsNERDTreeMapUpdirKeepOpen', 'override': 1, 'scope': 'all' })
line 329: 
line 330:   endif
line 331: 
line 332:   " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 333:   " actual font patcher)
line 334:   if g:webdevicons_gui_glyph_fix ==# 1
line 340:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'callback': 'WebDevIconsNERDTreeChangeRootHandler', 'override': 1, 'quickhelpText': "change tree root to the\n\"    selected dir\n\"    plus devicons redraw\n\"    hack fix", 'scope': 'Node' })
line 341: 
line 347:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'callback': 'WebDevIconsNERDTreeUpDirCurrentRootClosedHandler', 'override': 1, 'quickhelpText': "move tree root up a dir\n\"    plus devicons redraw\n\"    hack fix", 'scope': 'all' })
line 348:   endif
line 349: 
line 350: endif
line 351: 
line 352: " modeline syntax:
line 353: " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:
finished sourcing /home/ringu/.vim/plugged/vim-devicons/nerdtree_plugin/webdevicons.vim
continuing in function nerdtree#postSourceActions
Searching for "/home/ringu/.vim/plugged/fzf.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vim81/nerdtree_plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/nerdtree_plugin/**/*.vim"
Searching for "/home/ringu/.vim/after/nerdtree_plugin/**/*.vim"
function nerdtree#postSourceActions returning #0

continuing in /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim

line 240: 
line 241: "reset &cpo back to users setting
line 242: let &cpo = s:old_cpo
line 243: 
line 244: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /home/ringu/.vim/plugged/nerdtree/plugin/NERD_tree.vim
Searching for "/home/ringu/.vim/plugged/emmet-vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/emmet-vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim"
line 1: "=============================================================================
line 2: " File: emmet.vim
line 3: " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
line 4: " Last Change: 26-Jul-2015.
line 5: " Version: 0.86
line 6: " WebPage: http://github.com/mattn/emmet-vim
line 7: " Description: vim plugins for HTML and CSS hi-speed coding.
line 8: " SeeAlso: http://emmet.io/
line 9: " Usage:
line 10: "
line 11: "   This is vim script support expanding abbreviation like emmet.
line 12: "   ref: http://emmet.io/
line 13: "
line 14: "   Type abbreviation
line 15: "      +-------------------------------------
line 16: "      | html:5_
line 17: "      +-------------------------------------
line 18: "   "_" is a cursor position. and type "<c-y>," (Ctrl+y and Comma)
line 19: "   NOTE: Don't worry about key map. you can change it easily.
line 20: "      +-------------------------------------
line 21: "      | <!DOCTYPE HTML>
line 22: "      | <html lang="en">
line 23: "      | <head>
line 24: "      |     <title></title>
line 25: "      |     <meta charset="UTF-8">
line 26: "      | </head>
line 27: "      | <body>
line 28: "      |      _
line 29: "      | </body>
line 30: "      | </html>
line 31: "      +-------------------------------------
line 32: "   Type following
line 33: "      +-------------------------------------
line 34: "      | div#foo$*2>div.bar
line 35: "      +-------------------------------------
line 36: "   And type "<c-y>,"
line 37: "      +-------------------------------------
line 38: "      |<div id="foo1">
line 39: "      |    <div class="bar">_</div>
line 40: "      |</div>
line 41: "      |<div id="foo2">
line 42: "      |    <div class="bar"></div>
line 43: "      |</div>
line 44: "      +-------------------------------------
line 45: "
line 46: " Tips:
line 47: "
line 48: "   You can customize behavior of expanding with overriding config.
line 49: "   This configuration will be marged at loading plugin.
line 50: "
line 51: "     let g:user_emmet_settings = {
line 52: "     \  'indentation' : '  ',
line 53: "     \  'perl' : {
line 54: "     \    'aliases' : {
line 55: "     \      'req' : 'require '
line 56: "     \    },
line 57: "     \    'snippets' : {
line 58: "     \      'use' : "use strict\nuse warnings\n\n",
line 59: "     \      'warn' : "warn \"|\";",
line 60: "     \    }
line 61: "     \  }
line 62: "     \}
line 63: "
line 64: "   You can set language attribute in html using 'emmet_settings.lang'.
line 65: "
line 66: " GetLatestVimScripts: 2981 1 :AutoInstall: emmet.vim
line 67: " script type: plugin
line 68: 
line 69: if &compatible || v:version < 702 || (exists('g:loaded_emmet_vim') && g:loaded_emmet_vim)
line 70:   finish
line 71: endif
line 72: let g:loaded_emmet_vim = 1
line 73: 
line 74: let s:save_cpo = &cpoptions
line 75: set cpoptions&vim
line 76: 
line 77: if !exists('g:emmet_html5')
line 78:   let g:emmet_html5 = 1
line 79: endif
line 80: 
line 81: if !exists('g:emmet_docroot')
line 82:   let g:emmet_docroot = {}
line 83: endif
line 84: 
line 85: if !exists('g:emmet_debug')
line 86:   let g:emmet_debug = 0
line 87: endif
line 88: 
line 89: if !exists('g:emmet_curl_command')
line 90:   let g:emmet_curl_command = 'curl -s -L -A Mozilla/5.0'
line 91: endif
line 92: 
line 93: if !exists('g:user_emmet_leader_key')
line 94:   let g:user_emmet_leader_key = '<c-y>'
line 95: endif
line 96: 
line 97: function! s:install_plugin(mode, buffer)
line 163: 
line 164: command! -nargs=0 -bar EmmetInstall call <SID>install_plugin(get(g:, 'user_emmet_mode', 'a'), 1)
line 165: 
line 166: if get(g:, 'user_emmet_install_global', 1)
line 167:   call s:install_plugin(get(g:, 'user_emmet_mode', 'a'), 0)
calling function <SNR>42_install_plugin('a', 0)

line 1:   let buffer = a:buffer ? '<buffer>' : ''
line 2:   let items = [ {'mode': 'i', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(3,"")<cr>'}, {'mode': 'v', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(2,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': ':call emmet#expandAbbr(1,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>'}, {'mode': 'n', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '
line 39: 
line 40:   let only_plug = get(g:, 'emmet_install_only_plug', 0)
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-abbr) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(3,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(2,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-word) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-word) :call emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-update-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-update-tag) :call emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-inward) <esc>:call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-outword) <esc>:call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next) <esc>:call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next) :call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev) <esc>:call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev) :call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next-item) <esc>:call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next-item) :call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev-item) <esc>:call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev-item) :call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-image-size) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-image-size) :call emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-toggle-comment) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-toggle-comment) :call emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-split-join-tag) <esc>:call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-split-join-tag) :call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-remove-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-remove-tag) :call emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-url) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-url) :call emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-summary) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-summary) :call emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-merge-lines) :call emmet#mergeLines()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>m <plug>(emmet-merge-lines)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-code-pretty) :call emmet#codePretty()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>c <plug>(emmet-code-pretty)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 57: 
line 58:   if exists('g:user_emmet_complete_tag') && g:user_emmet_complete_tag
line 59:     if get(g:, 'user_emmet_install_global', 1)
line 60:       set omnifunc=emmet#completeTag
line 61:     else
line 62:       setlocal omnifunc=emmet#completeTag
line 63:     endif
line 64:   endif
function <SNR>42_install_plugin returning #0

continuing in /home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim

line 168: endif
line 169: 
line 170: if get(g:, 'user_emmet_install_command', 1)
line 171:   command! -nargs=1 Emmet call emmet#expandAbbr(4, <q-args>)
line 172: endif
line 173: 
line 174: let &cpoptions = s:save_cpo
line 175: unlet s:save_cpo
line 176: 
line 177: " vim:set et:
finished sourcing /home/ringu/.vim/plugged/emmet-vim/plugin/emmet.vim
Searching for "/home/ringu/.vim/plugged/vim-devicons/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-devicons/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim"
line 1: " Version: 0.10.0
line 2: " Webpage: https://github.com/ryanoasis/vim-devicons
line 3: " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
line 4: " License: see LICENSE
line 5: 
line 6: let s:version = '0.10.0'
line 7: let s:plugin_home = expand('<sfile>:p:h:h')
line 8: 
line 9: " set scriptencoding after 'encoding' and when using multibyte chars
line 10: scriptencoding utf-8
line 11: 
line 12: " standard fix/safety: line continuation (avoiding side effects) {{{1
line 13: "========================================================================
line 14: let s:save_cpo = &cpo
line 15: set cpo&vim
line 16: 
line 17: " standard loading / not loading {{{1
line 18: "========================================================================
line 19: 
line 20: if exists('g:loaded_webdevicons')
line 21:   finish
line 22: endif
line 23: 
line 24: let g:loaded_webdevicons = 1
line 25: 
line 26: " config enable / disable settings {{{1
line 27: "========================================================================
line 28: 
line 29: if !exists('g:webdevicons_enable')
line 30:   let g:webdevicons_enable = 1
line 31: endif
line 32: 
line 33: if !exists('g:webdevicons_enable_nerdtree')
line 34:   let g:webdevicons_enable_nerdtree = 1
line 35: endif
line 36: 
line 37: if !exists('g:webdevicons_enable_unite')
line 38:   let g:webdevicons_enable_unite = 1
line 39: endif
line 40: 
line 41: if !exists('g:webdevicons_enable_denite')
line 42:   let g:webdevicons_enable_denite = 1
line 43: endif
line 44: 
line 45: if !exists('g:webdevicons_enable_vimfiler')
line 46:   let g:webdevicons_enable_vimfiler = 1
line 47: endif
line 48: 
line 49: if !exists('g:webdevicons_enable_ctrlp')
line 50:   let g:webdevicons_enable_ctrlp = 1
line 51: endif
line 52: 
line 53: if !exists('g:webdevicons_enable_airline_tabline')
line 54:   let g:webdevicons_enable_airline_tabline = 1
line 55: endif
line 56: 
line 57: if !exists('g:webdevicons_enable_airline_statusline')
line 58:   let g:webdevicons_enable_airline_statusline = 1
line 59: endif
line 60: 
line 61: if !exists('g:webdevicons_enable_airline_statusline_fileformat_symbols')
line 62:   let g:webdevicons_enable_airline_statusline_fileformat_symbols = 1
line 63: endif
line 64: 
line 65: if !exists('g:webdevicons_enable_flagship_statusline')
line 66:   let g:webdevicons_enable_flagship_statusline = 1
line 67: endif
line 68: 
line 69: if !exists('g:webdevicons_enable_flagship_statusline_fileformat_symbols')
line 70:   let g:webdevicons_enable_flagship_statusline_fileformat_symbols = 1
line 71: endif
line 72: 
line 73: if !exists('g:webdevicons_conceal_nerdtree_brackets')
line 74:   let g:webdevicons_conceal_nerdtree_brackets = 1
line 75: endif
line 76: 
line 77: if !exists('g:DevIconsAppendArtifactFix')
line 78:   if has('gui_running')
line 79:     let g:DevIconsAppendArtifactFix = 1
line 80:   else
line 81:     let g:DevIconsAppendArtifactFix = 0
line 82:   endif
line 83: endif
line 84: 
line 85: if !exists('g:DevIconsArtifactFixChar')
line 86:   let g:DevIconsArtifactFixChar = " "
line 87: endif
line 88: 
line 89: " config options {{{1
line 90: "========================================================================
line 91: 
line 92: if !exists('g:WebDevIconsUnicodeDecorateFileNodes')
line 93:   let g:WebDevIconsUnicodeDecorateFileNodes = 1
line 94: endif
line 95: 
line 96: " whether to show default folder glyphs on directories:
line 97: if !exists('g:WebDevIconsUnicodeDecorateFolderNodes')
line 98:   let g:WebDevIconsUnicodeDecorateFolderNodes = 0
line 99: endif
line 100: 
line 101: if !exists('g:DevIconsEnableFoldersOpenClose')
line 102:   let g:DevIconsEnableFoldersOpenClose = 0
line 103: endif
line 104: 
line 105: if !exists('g:DevIconsEnableFolderPatternMatching')
line 106:   let g:DevIconsEnableFolderPatternMatching = 1
line 107: endif
line 108: 
line 109: if !exists('g:DevIconsEnableFolderExtensionPatternMatching')
line 110:   let g:DevIconsEnableFolderExtensionPatternMatching = 0
line 111: endif
line 112: 
line 113: " whether to try to match folder notes with any exact file node matches
line 114: " default is to match but requires WebDevIconsUnicodeDecorateFolderNodes set
line 115: " to 1:
line 116: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesExactMatches')
line 117:   let g:WebDevIconsUnicodeDecorateFolderNodesExactMatches = 1
line 118: endif
line 119: 
line 120: if !exists('g:WebDevIconsUnicodeGlyphDoubleWidth')
line 121:   let g:WebDevIconsUnicodeGlyphDoubleWidth = 1
line 122: endif
line 123: 
line 124: if !exists('g:WebDevIconsNerdTreeBeforeGlyphPadding')
line 125:   let g:WebDevIconsNerdTreeBeforeGlyphPadding = ' '
line 126: endif
line 127: 
line 128: if !exists('g:WebDevIconsNerdTreeAfterGlyphPadding')
line 129:   let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
line 130: endif
line 131: 
line 132: if !exists('g:WebDevIconsNerdTreeGitPluginForceVAlign')
line 133:   let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
line 134: endif
line 135: 
line 136: " fix for refreshing NERDTree flags upon creating new files
line 137: if !exists('g:NERDTreeUpdateOnCursorHold')
line 138:   let g:NERDTreeUpdateOnCursorHold = 1
line 139: endif
line 140: 
line 141: " config defaults {{{1
line 142: "========================================================================
line 143: 
line 144: if !exists('g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol')
line 145:   let g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol = ''
line 146: endif
line 147: 
line 148: if !exists('g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol')
line 149:   let g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol = ''
line 150: endif
line 151: 
line 152: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol')
line 153:   if g:DevIconsEnableFoldersOpenClose
line 154:     " use new glyph
line 155:     let g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol = ''
line 156:   else
line 157:     " use older glyph
line 158:     let g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol = ''
line 159:   endif
line 160: endif
line 161: 
line 162: if !exists('g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol')
line 163:   let g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol =  ''
line 164: endif
line 165: 
line 166: if !exists('g:DevIconsDefaultFolderOpenSymbol')
line 167:   let g:DevIconsDefaultFolderOpenSymbol = ''
line 168: endif
line 169: 
line 170: " functions {{{1
line 171: "========================================================================
line 172: 
line 173: " local functions {{{2
line 174: "========================================================================
line 175: 
line 176: " scope: local
line 177: function s:isDarwin()
line 205: 
line 206: " scope: local
line 207: function! s:strip(input)
line 210: 
line 211: " scope: local
line 212: function! s:setDictionaries()
line 389: 
line 390: " scope: local
line 391: function! s:setSyntax()
line 402: 
line 403: " scope: local
line 404: " stole solution/idea from nerdtree-git-plugin :)
line 405: function! s:setCursorHold()
line 412: 
line 413: " scope: local
line 414: " stole solution/idea from nerdtree-git-plugin :)
line 415: function! s:CursorHoldUpdate()
line 441: 
line 442: " scope: local
line 443: function! s:hardRefreshNerdTree()
line 449: 
line 450: " scope: local
line 451: function! s:softRefreshNerdTree()
line 457: 
line 458: " for vim-flagship plugin {{{3
line 459: "========================================================================
line 460: 
line 461: " scope: local
line 462: function! s:initializeFlagship()
line 477: 
line 478: " for unite plugin {{{3
line 479: "========================================================================
line 480: 
line 481: " scope: local
line 482: function! s:initializeUnite()
line 519: 
line 520: " for denite plugin {{{3
line 521: "========================================================================
line 522: 
line 523: " scope: local
line 524: function! s:initializeDenite()
line 529: 
line 530: " for vimfiler plugin {{{3
line 531: "========================================================================
line 532: 
line 533: " scope: local
line 534: function! s:initializeVimfiler()
line 542: 
line 543: " for ctrlp plugin {{{3
line 544: "========================================================================
line 545: 
line 546: " scope: local
line 547: " Initialize for up to date ctrlp fork: ctrlpvim/ctrlp.vim
line 548: " Support for kien/ctrlp.vim deprecated since v0.7.0
line 549: " @TODO implementation for CtrlP buffer and find file mode
line 550: function! s:initializeCtrlP()
line 574: 
line 575: " local initialization {{{2
line 576: "========================================================================
line 577: 
line 578: " scope: local
line 579: function! s:initialize()
line 589: 
line 590: " had some issues with VimEnter, for now using:
line 591: call s:initialize()
calling function <SNR>43_initialize()

line 1:   call s:setDictionaries()
calling function <SNR>43_initialize[1]..<SNR>43_setDictionaries()

line 1: 
line 2:   let s:file_node_extensions = { 'styl'     : '', 'sass'     : '', 'scss'     : '', 'htm'      : '', 'html'     : '', 'slim'     : '', 'ejs'      : '', 'css'      : '', 'less'     : '', 'md'       : '', 'markdown' : '', 'rmd'      : '', 'json'     : '', 'js'       : '', 'jsx'      : '', 'rb'       : '', 'php'      : '', 'py'       : '', 'pyc'      : '', 'pyo'      : '', 'pyd'      : '', 'coffee'   : '', 'mustache' : '', 'hbs'      : '', 'conf'     : '', 'ini'      : '', 'yml'      : '', 'yaml'     : '', 'bat'      : '', 'jpg'      : '', 'jpeg'     : '', 'bmp'      : '', 'png'      : '', 'gif'      : '', 'ico'      : '', 'twig'     : '', 'cpp'      : '', 'c++'      : '', 'cxx'      : '', 'cc'       : '', 'cp'       : '', 'c'        : '', 'h'        : '', 'hpp'      : '', 'hxx'      : '', 'hs'       : '', 'lhs'      : '', 'lua'      : '', 'java'     : '', 'sh
line 100: 
line 101:   let s:file_node_exact_matches = { 'exact-match-case-sensitive-1.txt' : '1', 'exact-match-case-sensitive-2'     : '2', 'gruntfile.coffee'                 : '', 'gruntfile.js'                     : '', 'gruntfile.ls'                     : '', 'gulpfile.coffee'                  : '', 'gulpfile.js'                      : '', 'gulpfile.ls'                      : '', 'dropbox'                          : '', '.ds_store'                        : '', '.gitconfig'                       : '', '.gitignore'                       : '', '.bashrc'                          : '', '.zshrc'                           : '', '.vimrc'                           : '', '.gvimrc'                          : '', '_vimrc'                           : '', '_gvimrc'                          : '', '.bashprofile'                     : '', 'favicon.ico'                      : '', 'license'                          : '', 'node_modules'                     : '', 'react.jsx'   
line 129: 
line 130:   let s:file_node_pattern_matches = { '.*jquery.*\.js$'       : '', '.*angular.*\.js$'      : '', '.*backbone.*\.js$'     : '', '.*require.*\.js$'      : '', '.*materialize.*\.js$'  : '', '.*materialize.*\.css$' : '', '.*mootools.*\.js$'     : '', '.*vimrc.*'             : '', 'Vagrantfile$'          : ''}
line 141: 
line 142:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols')
line 143:     let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = {}
line 144:   endif
line 145: 
line 146:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesExactSymbols')
line 147:     " do not remove: exact-match-case-sensitive-*
line 148:     let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols = {}
line 149:   endif
line 150: 
line 151:   if !exists('g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols')
line 152:     let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols = {}
line 153:   endif
line 154: 
line 155:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 156:   for [key, val] in items(s:file_node_extensions)
line 157:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
line 158:       let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
line 159:     endif
line 160:   endfor
line 161: 
line 162:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 163:   for [key, val] in items(s:file_node_exact_matches)
line 164:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
line 165:       let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
line 166:     endif
line 167:   endfor
line 168: 
line 169:   " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 170:   for [key, val] in items(s:file_node_pattern_matches)
line 171:     if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
line 172:       let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
line 173:     endif
line 174:   endfor
line 175: 
function <SNR>43_initialize[1]..<SNR>43_setDictionaries returning #0

continuing in function <SNR>43_initialize

line 2:   call s:setSyntax()
calling function <SNR>43_initialize[2]..<SNR>43_setSyntax()

line 1:   if g:webdevicons_enable_nerdtree == 1 && g:webdevicons_conceal_nerdtree_brackets == 1
line 2:     augroup webdevicons_conceal_nerdtree_brackets
line 3:       au!
line 4:       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=ALL
line 5:       autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=ALL
line 6:       autocmd FileType nerdtree setlocal conceallevel=3
line 7:       autocmd FileType nerdtree setlocal concealcursor=nvic
line 8:     augroup END
line 9:   endif
function <SNR>43_initialize[2]..<SNR>43_setSyntax returning #0

continuing in function <SNR>43_initialize

line 3:   call s:setCursorHold()
calling function <SNR>43_initialize[3]..<SNR>43_setCursorHold()

line 1:   if g:webdevicons_enable_nerdtree
line 2:     augroup webdevicons_cursor_hold
line 3:       autocmd CursorHold * silent! call s:CursorHoldUpdate()
line 4:     augroup END
line 5:   endif
function <SNR>43_initialize[3]..<SNR>43_setCursorHold returning #0

continuing in function <SNR>43_initialize

line 4:   call s:initializeFlagship()
calling function <SNR>43_initialize[4]..<SNR>43_initializeFlagship()

line 1:   if exists('g:loaded_flagship')
line 2:     if g:webdevicons_enable_flagship_statusline
line 3:       augroup webdevicons_flagship_filetype
line 4:         autocmd User Flags call Hoist('buffer', 'WebDevIconsGetFileTypeSymbol')
line 5:       augroup END
line 6:     endif
line 7: 
line 8:     if g:webdevicons_enable_flagship_statusline_fileformat_symbols
line 9:       augroup webdevicons_flagship_filesymbol
line 10:         autocmd User Flags call Hoist('buffer', 'WebDevIconsGetFileFormatSymbol')
line 11:       augroup END
line 12:     endif
line 13:   endif
function <SNR>43_initialize[4]..<SNR>43_initializeFlagship returning #0

continuing in function <SNR>43_initialize

line 5:   call s:initializeUnite()
calling function <SNR>43_initialize[5]..<SNR>43_initializeUnite()

line 1:   if exists('g:loaded_unite') && g:webdevicons_enable_unite
line 2:     let s:filters = {   'name' : 'devicons_unite_converter',}
line 5: 
line 6:     function! s:filters.filter(candidates, context)
line 30: 
line 31:     call unite#define_filter(s:filters)
line 32:     unlet s:filters
line 33: 
line 34:     call unite#custom#source('file,file_rec,buffer,file_rec/async,file_rec/neovim,file_rec/neovim2,file_rec/git', 'converters', 'devicons_unite_converter')
line 35:   endif
function <SNR>43_initialize[5]..<SNR>43_initializeUnite returning #0

continuing in function <SNR>43_initialize

line 6:   call s:initializeDenite()
calling function <SNR>43_initialize[6]..<SNR>43_initializeDenite()

line 1:   if exists('g:loaded_denite') && g:webdevicons_enable_denite
line 2:     call denite#custom#source('file_rec,file_mru,file_old,buffer,directory_rec,directory_mru', 'converters', ['devicons_denite_converter'])
line 3:   endif
function <SNR>43_initialize[6]..<SNR>43_initializeDenite returning #0

continuing in function <SNR>43_initialize

line 7:   call s:initializeVimfiler()
calling function <SNR>43_initialize[7]..<SNR>43_initializeVimfiler()

line 1:   if exists('g:loaded_vimfiler') && g:webdevicons_enable_vimfiler
line 2:     call vimfiler#custom#profile('default', 'context', { 'columns' : 'devicons:size:time', 'explorer_columns': 'devicons' })
line 6:   endif
function <SNR>43_initialize[7]..<SNR>43_initializeVimfiler returning #0

continuing in function <SNR>43_initialize

line 8:   call s:initializeCtrlP()
calling function <SNR>43_initialize[8]..<SNR>43_initializeCtrlP()

line 1:   let l:ctrlp_warning_message = 'vim-devicons: https://github.com/kien/ctrlp.vim is deprecated since v0.7.0, please use https://github.com/ctrlpvim/ctrlp.vim'
line 2:   let l:ctrlp_warned_file = s:plugin_home . '/status_warned_ctrlp'
line 3: 
line 4:   if exists('g:loaded_ctrlp') && g:webdevicons_enable_ctrlp
line 5:     let l:forkedCtrlp = exists('g:ctrlp_mruf_map_string')
line 6: 
line 7:     if l:forkedCtrlp
line 8:       if !exists('g:ctrlp_formatline_func')
line 9:         " logic for ctrlpvim/ctrlp.vim:
line 10:         let g:ctrlp_formatline_func = 's:formatline(s:curtype() == "buf" ? v:val : WebDevIconsGetFileTypeSymbol(v:val) . " " . v:val) '
line 11:       endif
line 12:     elseif empty(glob(l:ctrlp_warned_file))
line 13:       " logic for kien/ctrlp.vim:
line 14:       echohl WarningMsg | echomsg l:ctrlp_warning_message
line 14:  echomsg l:ctrlp_warning_message
line 16:       " only warn first time, do not warn again:
line 17:       try
line 18:         execute writefile(['File automatically generated after warning about CtrlP once', l:ctrlp_warning_message], l:ctrlp_warned_file)
line 19:       catch
line 20:       endtry
line 21:     endif
line 22:   endif
function <SNR>43_initialize[8]..<SNR>43_initializeCtrlP returning #0

continuing in function <SNR>43_initialize

function <SNR>43_initialize returning #0

continuing in /home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim

line 592: 
line 593: " public functions {{{2
line 594: "========================================================================
line 595: 
line 596: " scope: public
line 597: function! webdevicons#version()
line 600: 
line 601: " scope: public
line 602: " allow the first version of refresh to now call softRefresh
line 603: function! webdevicons#refresh()
line 606: 
line 607: " scope: public
line 608: function! webdevicons#hardRefresh()
line 612: 
line 613: " scope: public
line 614: function! webdevicons#softRefresh()
line 618: 
line 619: " a:1 (bufferName), a:2 (isDirectory)
line 620: " scope: public
line 621: function! WebDevIconsGetFileTypeSymbol(...)
line 668: 
line 669: " scope: local
line 670: " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
line 671: " actual font patcher)
line 672: function! s:DevIconsGetArtifactFix()
line 681: 
line 682: " scope: public
line 683: function! WebDevIconsGetFileFormatSymbol(...)
line 707: 
line 708: " for airline plugin {{{3
line 709: "========================================================================
line 710: 
line 711: " scope: public
line 712: function! AirlineWebDevIcons(...)
line 721: 
line 722: if g:webdevicons_enable == 1 && exists('g:loaded_airline') && g:loaded_airline == 1 && g:webdevicons_enable_airline_statusline
line 723:   call airline#add_statusline_func('AirlineWebDevIcons')
line 724: endif
line 725: 
line 726: if g:webdevicons_enable == 1 && g:webdevicons_enable_airline_tabline
line 727:   " Store original formatter.
line 728:   if exists('g:airline#extensions#tabline#formatter')
line 729:     let g:_webdevicons_airline_orig_formatter = g:airline#extensions#tabline#formatter
line 730:   else
line 731:     let g:_webdevicons_airline_orig_formatter = 'default'
line 732:   endif
line 733:   let g:airline#extensions#tabline#formatter = 'webdevicons'
line 734: endif
line 735: 
line 736: " for nerdtree plugin {{{3
line 737: "========================================================================
line 738: 
line 739: " scope: public
line 740: function! NERDTreeWebDevIconsRefreshListener(event)
line 821: 
line 822: " standard fix/safety: line continuation (avoiding side effects) {{{1
line 823: "========================================================================
line 824: let &cpo = s:save_cpo
line 825: unlet s:save_cpo
line 826: 
line 827: " modeline syntax:
line 828: " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:
finished sourcing /home/ringu/.vim/plugged/vim-devicons/plugin/webdevicons.vim
Searching for "/home/ringu/.vim/plugged/fzf.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/fzf.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim"
line 1: " Copyright (c) 2015 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: let s:cpo_save = &cpo
line 25: set cpo&vim
line 26: let s:is_win = has('win32') || has('win64')
line 27: 
line 28: function! s:defs(commands)
line 41: 
line 64: call s:defs(['command!      -bang -nargs=? -complete=dir Files       call fzf#vim#files(<q-args>, <bang>0)','command!      -bang -nargs=? GitFiles                  call fzf#vim#gitfiles(<q-args>, <bang>0)','command!      -bang -nargs=? GFiles                    call fzf#vim#gitfiles(<q-args>, <bang>0)','command! -bar -bang -nargs=? -complete=buffer Buffers  call fzf#vim#buffers(<q-args>, <bang>0)','command!      -bang -nargs=* Lines                     call fzf#vim#lines(<q-args>, <bang>0)','command!      -bang -nargs=* BLines                    call fzf#vim#buffer_lines(<q-args>, <bang>0)','command! -bar -bang Colors                             call fzf#vim#colors(<bang>0)','command!      -bang -nargs=+ -complete=dir Locate      call fzf#vim#locate(<q-args>, <bang>0)','command!      -bang -nargs=* Ag                        call fzf#vim#ag(<q-args>, <bang>0)','command!      -bang -nargs=* Rg                        call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case "
calling function <SNR>44_defs(['command!      -bang -nargs=? -comple...    call s:history(<q-args>, <bang>0)'])

line 1:   let prefix = get(g:, 'fzf_command_prefix', '')
line 2:   if prefix =~# '^[^A-Z]'
line 3:     echoerr 'g:fzf_command_prefix must start with an uppercase letter'
line 4:     return
line 5:   endif
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? -complete=dir Files       call fzf#vim#files(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GitFiles                  call fzf#vim#gitfiles(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=? GFiles                    call fzf#vim#gitfiles(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang -nargs=? -complete=buffer Buffers  call fzf#vim#buffers(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Lines                     call fzf#vim#lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BLines                    call fzf#vim#buffer_lines(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Colors                             call fzf#vim#colors(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=+ -complete=dir Locate      call fzf#vim#locate(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Ag                        call fzf#vim#ag(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Rg                        call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ".shellescape(<q-args>), 1, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* Tags                      call fzf#vim#tags(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* BTags                     call fzf#vim#buffer_tags(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Snippets                           call fzf#vim#snippets(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Commands                           call fzf#vim#commands(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Marks                              call fzf#vim#marks(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Helptags                           call fzf#vim#helptags(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Windows                            call fzf#vim#windows(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Commits                            call fzf#vim#commits(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang BCommits                           call fzf#vim#buffer_commits(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Maps                               call fzf#vim#maps("n", <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command! -bar -bang Filetypes                          call fzf#vim#filetypes(<bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 9: command!      -bang -nargs=* History                   call s:history(<q-args>, <bang>0)
line 10:     endif
line 11:   endfor
line 6:   for command in a:commands
line 7:     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
line 8:     if 2 != exists(name)
line 9:       execute substitute(command, '\ze\C[A-Z]', prefix, '')
line 10:     endif
line 11:   endfor
function <SNR>44_defs returning #0

continuing in /home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim

line 65: 
line 66: function! s:history(arg, bang)
line 76: 
line 77: function! fzf#complete(...)
line 80: 
line 81: if (has('nvim') || has('terminal') && has('patch-8.0.995')) && (get(g:, 'fzf_statusline', 1) || get(g:, 'fzf_nvim_statusline', 1))
line 82:   function! s:fzf_restore_colors()
line 98: 
line 99:   function! s:fzf_vim_term()
line 109: 
line 110:   augroup _fzf_statusline
line 111:     autocmd!
line 112:     autocmd FileType fzf call s:fzf_vim_term()
line 113:   augroup END
line 114: endif
line 115: 
line 116: if !exists('g:fzf#vim#buffers')
line 117:   let g:fzf#vim#buffers = {}
line 118: endif
line 119: 
line 120: augroup fzf_buffers
line 121:   autocmd!
line 122:   if exists('*reltimefloat')
line 123:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
line 124:   else
line 125:     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = localtime()
line 126:   endif
line 127:   autocmd BufDelete * silent! call remove(g:fzf#vim#buffers, expand('<abuf>'))
line 128: augroup END
line 129: 
line 130: inoremap <expr> <plug>(fzf-complete-word)        fzf#vim#complete#word()
line 131: if s:is_win
line 132:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path('dir /s/b')
line 133:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path('dir /s/b/a:-d')
line 134: else
line 135:   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'")
line 136:   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -type f -print -o -type l -print \| sed 's:^..::'")
line 137: endif
line 138: inoremap <expr> <plug>(fzf-complete-file-ag)     fzf#vim#complete#path('ag -l -g ""')
line 139: inoremap <expr> <plug>(fzf-complete-line)        fzf#vim#complete#line()
line 140: inoremap <expr> <plug>(fzf-complete-buffer-line) fzf#vim#complete#buffer_line()
line 141: 
line 142: nnoremap <silent> <plug>(fzf-maps-n) :<c-u>call fzf#vim#maps('n', 0)<cr>
line 143: inoremap <silent> <plug>(fzf-maps-i) <c-o>:call fzf#vim#maps('i', 0)<cr>
line 144: xnoremap <silent> <plug>(fzf-maps-x) :<c-u>call fzf#vim#maps('x', 0)<cr>
line 145: onoremap <silent> <plug>(fzf-maps-o) <c-c>:<c-u>call fzf#vim#maps('o', 0)<cr>
line 146: 
line 147: let &cpo = s:cpo_save
line 148: unlet s:cpo_save
line 149: 
finished sourcing /home/ringu/.vim/plugged/fzf.vim/plugin/fzf.vim
Searching for "/home/ringu/.vim/plugged/fugitive.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/fugitive.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim"
line 1: " fugitive.vim - A Git wrapper so awesome, it should be illegal
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.2
line 4: " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
line 5: 
line 6: if exists('g:loaded_fugitive') || &cp
line 7:   finish
line 8: endif
line 9: let g:loaded_fugitive = 1
line 10: 
line 11: if !exists('g:fugitive_git_executable')
line 12:   let g:fugitive_git_executable = 'git'
line 13: endif
line 14: 
line 15: " Section: Utility
line 16: 
line 17: function! s:function(name) abort
line 20: 
line 21: function! s:sub(str,pat,rep) abort
line 24: 
line 25: function! s:gsub(str,pat,rep) abort
line 28: 
line 29: function! s:winshell() abort
line 32: 
line 33: function! s:shellesc(arg) abort
line 42: 
line 43: function! s:fnameescape(file) abort
line 50: 
line 51: function! s:throw(string) abort
line 55: 
line 56: function! s:warn(str) abort
line 62: 
line 63: function! s:shellslash(path) abort
line 70: 
line 71: let s:git_versions = {}
line 72: 
line 73: function! fugitive#git_version(...) abort
line 79: 
line 80: function! s:recall() abort
line 97: 
line 98: function! s:add_methods(namespace, method_names) abort
line 103: 
line 104: let s:commands = []
line 105: function! s:command(definition) abort
line 108: 
line 109: function! s:define_commands() abort
line 114: 
line 115: augroup fugitive_utility
line 116:   autocmd!
line 117:   autocmd User Fugitive call s:define_commands()
line 118: augroup END
line 119: 
line 120: let s:abstract_prototype = {}
line 121: 
line 122: " Section: Initialization
line 123: 
line 124: function! fugitive#is_git_dir(path) abort
line 128: 
line 129: function! fugitive#extract_git_dir(path) abort
line 176: 
line 177: function! fugitive#detect(path) abort
line 218: 
line 219: augroup fugitive
line 220:   autocmd!
line 221:   autocmd BufNewFile,BufReadPost * call fugitive#detect(expand('<amatch>:p'))
line 222:   autocmd FileType           netrw call fugitive#detect(expand('%:p'))
line 223:   autocmd User NERDTreeInit,NERDTreeNewRoot call fugitive#detect(b:NERDTreeRoot.path.str())
line 224:   autocmd VimEnter * if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 225:   autocmd CmdWinEnter * call fugitive#detect(expand('#:p'))
line 226:   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 227: augroup END
line 228: 
line 229: " Section: Repository
line 230: 
line 231: let s:repo_prototype = {}
line 232: let s:repos = {}
line 233: let s:worktree_for_dir = {}
line 234: let s:dir_for_worktree = {}
line 235: 
line 236: function! s:repo(...) abort
line 249: 
line 250: function! fugitive#repo(...) abort
line 253: 
line 254: function! s:repo_dir(...) dict abort
line 257: 
line 258: function! s:configured_tree(git_dir) abort
line 277: 
line 278: function! s:repo_tree(...) dict abort
line 290: 
line 291: function! s:repo_bare() dict abort
line 298: 
line 299: function! s:repo_translate(spec) dict abort
line 343: 
line 344: function! s:repo_head(...) dict abort
line 359: 
line 360: call s:add_methods('repo',['dir','tree','bare','translate','head'])
calling function <SNR>45_add_methods('repo', ['dir', 'tree', 'bare', 'translate', 'head'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_dir')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_dir')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_tree')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_bare')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_bare')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_translate')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_translate')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_head')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_head')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 361: 
line 362: function! s:repo_git_command(...) dict abort
line 366: 
line 367: function! s:repo_git_chomp(...) dict abort
line 370: 
line 371: function! s:repo_git_chomp_in_tree(...) dict abort
line 381: 
line 382: function! s:repo_rev_parse(rev) dict abort
line 389: 
line 390: call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])
calling function <SNR>45_add_methods('repo', ['git_command', 'git_chomp', 'git_chomp_in_tree', 'rev_parse'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_command')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_command')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_chomp')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_chomp')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_git_chomp_in_tree')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_git_chomp_in_tree')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_rev_parse')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_rev_parse')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 391: 
line 392: function! s:repo_dirglob(base) dict abort
line 398: 
line 399: function! s:repo_superglob(base) dict abort
line 436: 
line 437: call s:add_methods('repo',['dirglob','superglob'])
calling function <SNR>45_add_methods('repo', ['dirglob', 'superglob'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_dirglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_dirglob')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_superglob')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_superglob')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 438: 
line 439: function! s:repo_config(conf) dict abort
line 442: 
line 443: function! s:repo_user() dict abort
line 448: 
line 449: function! s:repo_aliases() dict abort
line 458: 
line 459: call s:add_methods('repo',['config', 'user', 'aliases'])
calling function <SNR>45_add_methods('repo', ['config', 'user', 'aliases'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_config')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_config')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_user')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_user')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_aliases')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_aliases')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 460: 
line 461: function! s:repo_keywordprg() dict abort
line 469: 
line 470: call s:add_methods('repo',['keywordprg'])
calling function <SNR>45_add_methods('repo', ['keywordprg'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_keywordprg')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_keywordprg')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 471: 
line 472: " Section: Buffer
line 473: 
line 474: let s:buffer_prototype = {}
line 475: 
line 476: function! s:buffer(...) abort
line 484: 
line 485: function! fugitive#buffer(...) abort
line 488: 
line 489: function! s:buffer_getvar(var) dict abort
line 492: 
line 493: function! s:buffer_setvar(var,value) dict abort
line 496: 
line 497: function! s:buffer_getline(lnum) dict abort
line 500: 
line 501: function! s:buffer_repo() dict abort
line 504: 
line 505: function! s:buffer_type(...) dict abort
line 529: 
line 530: if has('win32')
line 531: 
line 532:   function! s:buffer_spec() dict abort
line 540: 
line 541: else
line 542: 
line 543:   function! s:buffer_spec() dict abort
line 547: 
line 548: endif
line 549: 
line 550: function! s:buffer_name() dict abort
line 553: 
line 554: function! s:buffer_commit() dict abort
line 557: 
line 558: function! s:buffer_path(...) dict abort
line 569: 
line 570: function! s:buffer_rev() dict abort
line 584: 
line 585: function! s:buffer_sha1() dict abort
line 592: 
line 593: function! s:buffer_expand(rev) dict abort
line 610: 
line 611: function! s:buffer_containing_commit() dict abort
line 620: 
line 621: function! s:buffer_up(...) dict abort
line 644: 
line 645: call s:add_methods('buffer',['getvar','setvar','getline','repo','type','spec','name','commit','path','rev','sha1','expand','containing_commit','up'])
calling function <SNR>45_add_methods('buffer', ['getvar', 'setvar', 'getline', 'repo'...', 'expand', 'containing_commit', 'up'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_getvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_getvar')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_setvar')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_setvar')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_getline')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_getline')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_repo')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_repo')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_type')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_type')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_spec')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_spec')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_name')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_name')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_commit')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_path')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_path')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_rev')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_rev')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_sha1')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_sha1')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_expand')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_expand')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_containing_commit')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_containing_commit')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_up')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_up')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 646: 
line 647: " Section: Git
line 648: 
line 649: call s:command("-bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...e Git :execute s:Git(<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 650: 
line 651: function! s:ExecuteInTree(cmd) abort
line 661: 
line 662: function! s:Git(bang, args) abort
line 675: 
line 676: function! fugitive#git_commands() abort
line 682: 
line 683: function! s:GitComplete(A, L, P) abort
line 691: 
line 692: " Section: Gcd, Glcd
line 693: 
line 694: function! s:DirComplete(A,L,P) abort
line 698: 
line 699: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>45_command('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 700: call s:command("-bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`")
calling function <SNR>45_command('-bar -bang -nargs=? -complete=customl...r(<q-args>) : s:repo().tree(<q-args>)`')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 701: 
line 702: " Section: Gstatus
line 703: 
line 704: call s:command("-bar Gstatus :execute s:Status()")
calling function <SNR>45_command('-bar Gstatus :execute s:Status()')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 705: augroup fugitive_status
line 706:   autocmd!
line 707:   if !has('win32')
line 708:     autocmd FocusGained,ShellCmdPost * call fugitive#reload_status()
line 709:   endif
line 710: augroup END
line 711: 
line 712: function! s:Status() abort
line 723: 
line 724: function! fugitive#reload_status() abort
line 756: 
line 757: function! s:stage_info(lnum) abort
line 782: 
line 783: function! s:StageNext(count) abort
line 789: 
line 790: function! s:StagePrevious(count) abort
line 800: 
line 801: function! s:StageReloadSeek(target,lnum1,lnum2) abort
line 812: 
line 813: function! s:StageUndo() abort
line 834: 
line 835: function! s:StageDiff(diff) abort
line 853: 
line 854: function! s:StageDiffEdit() abort
line 876: 
line 877: function! s:StageToggle(lnum1,lnum2) abort
line 941: 
line 942: function! s:StagePatch(lnum1,lnum2) abort
line 987: 
line 988: " Section: Gcommit
line 989: 
line 990: call s:command("-nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)")
calling function <SNR>45_command('-nargs=? -complete=customlist,s:Commi...te Gcommit :execute s:Commit(<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 991: 
line 992: function! s:Commit(args, ...) abort
line 1074: 
line 1075: function! s:CommitComplete(A,L,P) abort
line 1083: 
line 1084: function! s:FinishCommit() abort
line 1092: 
line 1093: " Section: Gmerge, Gpull
line 1094: 
line 1096: call s:command("-nargs=? -bang -complete=custom,s:RevisionComplete Gmerge " . "execute s:Merge('merge', <bang>0, <q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rev... s:Merge(''merge'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1098: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpull " . "execute s:Merge('pull --progress', <bang>0, <q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...'pull --progress'', <bang>0, <q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1099: 
line 1100: function! s:RevisionComplete(A, L, P) abort
line 1104: 
line 1105: function! s:RemoteComplete(A, L, P) abort
line 1116: 
line 1117: function! fugitive#cwindow() abort
line 1127: 
line 1134: let s:common_efm = '' . '%+Egit:%.%#,' . '%+Eusage:%.%#,' . '%+Eerror:%.%#,' . '%+Efatal:%.%#,' . '%-G%.%#%\e[K%.%#,' . '%-G%.%#%\r%.%\+'
line 1135: 
line 1136: function! s:Merge(cmd, bang, args) abort
line 1211: 
line 1212: " Section: Ggrep, Glog
line 1213: 
line 1214: if !exists('g:fugitive_summary_format')
line 1215:   let g:fugitive_summary_format = '%s'
line 1216: endif
line 1217: 
line 1218: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...cute s:Grep(''grep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1219: call s:command("-bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)")
calling function <SNR>45_command('-bang -nargs=? -complete=customlist,s...ute s:Grep(''lgrep'',<bang>0,<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1220: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1221: call s:command("-bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -range=0 -complet...grep<bang>'',<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1222: 
line 1223: function! s:Grep(cmd,bang,arg) abort
line 1261: 
line 1262: function! s:Log(cmd, line1, line2, ...) abort
line 1299: 
line 1300: " Section: Gedit, Gpedit, Gsplit, Gvsplit, Gtabedit, Gread
line 1301: 
line 1302: function! s:Edit(cmd,bang,...) abort
line 1378: 
line 1379: function! s:EditComplete(A,L,P) abort
line 1382: 
line 1383: function! s:EditRunComplete(A,L,P) abort
line 1390: 
line 1391: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1392: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...cute s:Edit(''edit<bang>'',0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1393: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ute s:Edit(''pedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1394: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ute s:Edit(''split'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1395: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...te s:Edit(''vsplit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1396: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...e s:Edit(''tabedit'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1397: call s:command("-bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -count -complete=... : <count>).''read'',<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1398: 
line 1399: " Section: Gwrite, Gwq
line 1400: 
line 1401: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...ite :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1402: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl... Gw :execute s:Write(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1403: call s:command("-bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)")
calling function <SNR>45_command('-bar -bang -nargs=* -complete=customl...te Gwq :execute s:Wq(<bang>0,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1404: 
line 1405: function! s:Write(force,...) abort
line 1541: 
line 1542: function! s:Wq(force,...) abort
line 1554: 
line 1555: augroup fugitive_commit
line 1556:   autocmd!
line 1557:   autocmd VimLeavePre,BufDelete COMMIT_EDITMSG execute s:sub(s:FinishCommit(), '^echoerr (.*)', 'echohl ErrorMsg|echo \1|echohl NONE')
line 1558: augroup END
line 1559: 
line 1560: " Section: Gpush, Gfetch
line 1561: 
line 1562: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...spatch(''<bang>'', ''push ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1563: call s:command("-nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)")
calling function <SNR>45_command('-nargs=? -bang -complete=custom,s:Rem...patch(''<bang>'', ''fetch ''.<q-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1564: 
line 1565: function! s:Dispatch(bang, args)
line 1588: 
line 1589: " Section: Gdiff
line 1590: 
line 1591: call s:command("-bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)")
calling function <SNR>45_command('-bang -bar -nargs=* -complete=customl...e Gdiff :execute s:Diff('''',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1592: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)")
calling function <SNR>45_command('-bar -nargs=* -complete=customlist,s:...ute s:Diff(''keepalt vert '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1593: call s:command("-bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)")
calling function <SNR>45_command('-bar -nargs=* -complete=customlist,s:...:execute s:Diff(''keepalt '',<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1594: 
line 1595: augroup fugitive_diff
line 1596:   autocmd!
line 1600:   autocmd BufWinLeave * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 1604:   autocmd BufWinEnter * if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
line 1605: augroup END
line 1606: 
line 1607: function! s:can_diffoff(buf) abort
line 1612: 
line 1613: function! fugitive#can_diffoff(buf) abort
line 1616: 
line 1617: function! s:diff_modifier(count) abort
line 1629: 
line 1630: function! s:diff_window_count() abort
line 1637: 
line 1638: function! s:diff_restore() abort
line 1652: 
line 1653: function! s:diffthis() abort
line 1659: 
line 1660: function! s:diffoff() abort
line 1668: 
line 1669: function! s:diffoff_all(dir) abort
line 1682: 
line 1683: function! s:buffer_compare_age(commit) dict abort
line 1702: 
line 1703: call s:add_methods('buffer',['compare_age'])
calling function <SNR>45_add_methods('buffer', ['compare_age'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:buffer_compare_age')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_buffer_compare_age')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 1704: 
line 1705: function! s:Diff(vert,...) abort
line 1769: 
line 1770: " Section: Gmove, Gremove
line 1771: 
line 1772: function! s:Move(force,destination) abort
line 1805: 
line 1806: function! s:MoveComplete(A,L,P) abort
line 1815: 
line 1816: function! s:Remove(force) abort
line 1837: 
line 1838: augroup fugitive_remove
line 1839:   autocmd!
line 1843:   autocmd User Fugitive if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 1844: augroup END
line 1845: 
line 1846: " Section: Gblame
line 1847: 
line 1848: augroup fugitive_blame
line 1849:   autocmd!
line 1850:   autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame
line 1851:   autocmd FileType fugitiveblame setlocal nomodeline | if exists('b:git_dir') | let &l:keywordprg = s:repo().keywordprg() | endif
line 1852:   autocmd Syntax fugitiveblame call s:BlameSyntax()
line 1853:   autocmd User Fugitive if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 1854:   autocmd ColorScheme,GUIEnter * call s:RehighlightBlame()
line 1855: augroup END
line 1856: 
line 1857: function! s:linechars(pattern) abort
line 1866: 
line 1867: function! s:Blame(bang,line1,line2,count,args) abort
line 1982: 
line 1983: function! s:BlameCommit(cmd) abort
line 2023: 
line 2024: function! s:BlameJump(suffix) abort
line 2057: 
line 2058: let s:hash_colors = {}
line 2059: 
line 2060: function! s:BlameSyntax() abort
line 2108: 
line 2109: function! s:RehighlightBlame() abort
line 2118: 
line 2119: " Section: Gbrowse
line 2120: 
line 2121: call s:command("-bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)")
calling function <SNR>45_command('-bar -bang -range -nargs=* -complete=...owse(<bang>0,<line1>,<count>,<f-args>)')

line 1:   let s:commands += [a:definition]
function <SNR>45_command returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2122: 
line 2123: function! s:Browse(bang,line1,count,...) abort
line 2234: 
line 2235: function! s:github_url(opts, ...) abort
line 2296: 
line 2297: function! s:instaweb_url(opts) abort
line 2337: 
line 2338: if !exists('g:fugitive_browse_handlers')
line 2339:   let g:fugitive_browse_handlers = []
line 2340: endif
line 2341: 
line 2343: call extend(g:fugitive_browse_handlers, [s:function('s:github_url'), s:function('s:instaweb_url')])
calling function <SNR>45_function('s:github_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_function returning function('<SNR>45_github_url')

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

calling function <SNR>45_function('s:instaweb_url')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_function returning function('<SNR>45_instaweb_url')

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2344: 
line 2345: " Section: File access
line 2346: 
line 2347: function! s:ReplaceCmd(cmd,...) abort
line 2386: 
line 2387: function! s:BufReadIndex() abort
line 2462: 
line 2463: function! s:FileRead() abort
line 2479: 
line 2480: function! s:BufReadIndexFile() abort
line 2500: 
line 2501: function! s:BufWriteIndexFile() abort
line 2533: 
line 2534: function! s:BufReadObject() abort
line 2615: 
line 2616: augroup fugitive_files
line 2617:   autocmd!
line 2624:   autocmd BufReadCmd  index{,.lock} if fugitive#is_git_dir(expand('<amatch>:p:h')) |   exe s:BufReadIndex() | elseif filereadable(expand('<amatch>')) |   read <amatch> |   1delete | endif
line 2625:   autocmd FileReadCmd fugitive://**//[0-3]/**          exe s:FileRead()
line 2626:   autocmd BufReadCmd  fugitive://**//[0-3]/**          exe s:BufReadIndexFile()
line 2627:   autocmd BufWriteCmd fugitive://**//[0-3]/**          exe s:BufWriteIndexFile()
line 2628:   autocmd BufReadCmd  fugitive://**//[0-9a-f][0-9a-f]* exe s:BufReadObject()
line 2629:   autocmd FileReadCmd fugitive://**//[0-9a-f][0-9a-f]* exe s:FileRead()
line 2633:   autocmd FileType git if exists('b:git_dir') |  call s:JumpInit() | endif
line 2634: augroup END
line 2635: 
line 2636: " Section: Temp files
line 2637: 
line 2638: if !exists('s:temp_files')
line 2639:   let s:temp_files = {}
line 2640: endif
line 2641: 
line 2642: augroup fugitive_temp
line 2643:   autocmd!
line 2652:   autocmd BufNewFile,BufReadPost * if has_key(s:temp_files,tolower(expand('<afile>:p'))) |   let b:git_dir = s:temp_files[tolower(expand('<afile>:p'))].dir |   let b:git_type = 'temp' |   let b:git_args = s:temp_files[tolower(expand('<afile>:p'))].args |   call fugitive#detect(expand('<afile>:p')) |   setlocal bufhidden=delete nobuflisted |   nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>| endif
line 2653: augroup END
line 2654: 
line 2655: " Section: Go to file
line 2656: 
line 2657: function! s:JumpInit() abort
line 2675: 
line 2676: function! s:GF(mode) abort
line 2847: 
line 2848: " Section: Statusline
line 2849: 
line 2850: function! s:repo_head_ref() dict abort
line 2856: 
line 2857: call s:add_methods('repo',['head_ref'])
calling function <SNR>45_add_methods('repo', ['head_ref'])

line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
calling function <SNR>45_add_methods[2]..<SNR>45_function('s:repo_head_ref')

line 1:   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '<SNR>\d\+_'),''))
function <SNR>45_add_methods[2]..<SNR>45_function returning function('<SNR>45_repo_head_ref')

continuing in function <SNR>45_add_methods

line 3:   endfor
line 1:   for name in a:method_names
line 2:     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
line 3:   endfor
function <SNR>45_add_methods returning #0

continuing in /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim

line 2858: 
line 2859: function! fugitive#statusline(...) abort
line 2874: 
line 2875: function! fugitive#head(...) abort
line 2882: 
line 2883: " Section: Folding
line 2884: 
line 2885: function! fugitive#foldtext() abort
line 2923: 
line 2924: augroup fugitive_foldtext
line 2925:   autocmd!
line 2929:   autocmd User Fugitive if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 2930: augroup END
finished sourcing /home/ringu/.vim/plugged/fugitive.vim/plugin/fugitive.vim
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim"
line 1: scriptencoding utf-8
line 2: 
line 3: if exists('g:loaded_gitgutter') || !has('signs') || &cp
line 4:   finish
line 5: endif
line 6: let g:loaded_gitgutter = 1
line 7: 
line 8: " Initialisation {{{
line 9: 
line 10: if v:version < 703 || (v:version == 703 && !has("patch105"))
line 11:   call gitgutter#utility#warn('requires Vim 7.3.105')
line 12:   finish
line 13: endif
line 14: 
line 15: function! s:set(var, default) abort
line 24: 
line 25: call s:set('g:gitgutter_enabled',                     1)
calling function <SNR>46_set('g:gitgutter_enabled', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_enabled = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 26: call s:set('g:gitgutter_max_signs',                 500)
calling function <SNR>46_set('g:gitgutter_max_signs', 500)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_max_signs = 500
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 27: call s:set('g:gitgutter_signs',                       1)
calling function <SNR>46_set('g:gitgutter_signs', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_signs = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 28: call s:set('g:gitgutter_highlight_lines',             0)
calling function <SNR>46_set('g:gitgutter_highlight_lines', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_highlight_lines = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 29: call s:set('g:gitgutter_sign_column_always',          0)
calling function <SNR>46_set('g:gitgutter_sign_column_always', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_sign_column_always = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 30: if g:gitgutter_sign_column_always && exists('&signcolumn')
line 31:   " Vim 7.4.2201.
line 32:   set signcolumn=yes
line 33:   let g:gitgutter_sign_column_always = 0
line 34:   call gitgutter#utility#warn('please replace "let g:gitgutter_sign_column_always=1" with "set signcolumn=yes"')
line 35: endif
line 36: call s:set('g:gitgutter_override_sign_column_highlight', 1)
calling function <SNR>46_set('g:gitgutter_override_sign_column_highlight', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 37: call s:set('g:gitgutter_sign_added',                   '+')
calling function <SNR>46_set('g:gitgutter_sign_added', '+')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_added = '+'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 38: call s:set('g:gitgutter_sign_modified',                '~')
calling function <SNR>46_set('g:gitgutter_sign_modified', '~')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified = '~'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 39: call s:set('g:gitgutter_sign_removed',                 '_')
calling function <SNR>46_set('g:gitgutter_sign_removed', '_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed = '_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 40: 
line 41: if gitgutter#utility#supports_overscore_sign()
Searching for "autoload/gitgutter/utility.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter/utility.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 41: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim"
line 1: function! gitgutter#utility#supports_overscore_sign()
line 8: 
line 9: function! gitgutter#utility#setbufvar(buffer, varname, val)
line 23: 
line 24: function! gitgutter#utility#getbufvar(buffer, varname, ...)
line 34: 
line 35: function! gitgutter#utility#warn(message) abort
line 41: 
line 42: function! gitgutter#utility#warn_once(bufnr, message, key) abort
line 51: 
line 52: " Returns truthy when the buffer's file should be processed; and falsey when it shouldn't.
line 53: " This function does not and should not make any system calls.
line 54: function! gitgutter#utility#is_active(bufnr) abort
line 62: 
line 63: function! s:not_git_dir(bufnr) abort
line 66: 
line 67: function! s:is_file_buffer(bufnr) abort
line 70: 
line 71: " From tpope/vim-fugitive
line 72: function! s:winshell()
line 75: 
line 76: " From tpope/vim-fugitive
line 77: function! gitgutter#utility#shellescape(arg) abort
line 86: 
line 87: function! gitgutter#utility#file(bufnr)
line 90: 
line 91: " Not shellescaped
line 92: function! gitgutter#utility#extension(bufnr) abort
line 95: 
line 96: function! gitgutter#utility#system(cmd, ...) abort
line 105: 
line 106: " Path of file relative to repo root.
line 107: "
line 108: " *     empty string - not set
line 109: " * non-empty string - path
line 110: " *               -1 - pending
line 111: " *               -2 - not tracked by git
line 112: function! gitgutter#utility#repo_path(bufnr, shellesc) abort
line 116: 
line 117: function! gitgutter#utility#set_repo_path(bufnr) abort
line 154: 
line 155: if has('nvim') && !has('nvim-0.2.0')
line 156:   function! s:not_tracked_by_git(bufnr)
line 159: endif
line 160: 
line 161: function! s:set_path(bufnr, path)
line 169: 
line 170: function! gitgutter#utility#cd_cmd(bufnr, cmd) abort
line 174: 
line 175: function! s:unc_path(bufnr)
line 178: 
line 179: function! s:use_known_shell() abort
line 186: 
line 187: function! s:restore_shell() abort
line 192: 
line 193: function! s:abs_path(bufnr, shellesc)
line 197: 
line 198: function! s:dir(bufnr) abort
line 201: 
line 202: " Not shellescaped.
line 203: function! s:filename(bufnr) abort
line 206: 
line 207: function! s:exists_file(bufnr) abort
line 210: 
line 211: " Get rid of any trailing new line or SOH character.
line 212: "
line 213: " git ls-files -z produces output with null line termination.
line 214: " Vim's system() replaces any null characters in the output
line 215: " with SOH (start of header), i.e. ^A.
line 216: function! s:strip_trailing_new_line(line) abort
line 219: 
line 220: function! gitgutter#utility#windows()
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim
continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
calling function gitgutter#utility#supports_overscore_sign()

line 1:   if gitgutter#utility#windows()
calling function gitgutter#utility#supports_overscore_sign[1]..gitgutter#utility#windows()

line 1:   return has('win64') || has('win32') || has('win16')
function gitgutter#utility#supports_overscore_sign[1]..gitgutter#utility#windows returning #0

continuing in function gitgutter#utility#supports_overscore_sign

line 2:     return &encoding ==? 'utf-8'
line 3:   else
line 4:     return &termencoding ==? &encoding || &termencoding == ''
function gitgutter#utility#supports_overscore_sign returning #1

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 42:   call s:set('g:gitgutter_sign_removed_first_line', '')
calling function <SNR>46_set('g:gitgutter_sign_removed_first_line', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed_first_line = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 43: else
line 44:   call s:set('g:gitgutter_sign_removed_first_line', '_^')
line 45: endif
line 46: 
line 47: call s:set('g:gitgutter_sign_removed_above_and_below', '[')
calling function <SNR>46_set('g:gitgutter_sign_removed_above_and_below', '[')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_removed_above_and_below = '['
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 48: call s:set('g:gitgutter_sign_modified_removed',       '~_')
calling function <SNR>46_set('g:gitgutter_sign_modified_removed', '~_')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_sign_modified_removed = '~_'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 49: call s:set('g:gitgutter_git_args',                      '')
calling function <SNR>46_set('g:gitgutter_git_args', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_git_args = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 50: call s:set('g:gitgutter_diff_args',                     '')
calling function <SNR>46_set('g:gitgutter_diff_args', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_diff_args = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 51: call s:set('g:gitgutter_diff_base',                     '')
calling function <SNR>46_set('g:gitgutter_diff_base', '')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_diff_base = ''
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 52: call s:set('g:gitgutter_map_keys',                       1)
calling function <SNR>46_set('g:gitgutter_map_keys', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_map_keys = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 53: call s:set('g:gitgutter_terminal_reports_focus',         1)
calling function <SNR>46_set('g:gitgutter_terminal_reports_focus', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_terminal_reports_focus = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 54: call s:set('g:gitgutter_async',                          1)
calling function <SNR>46_set('g:gitgutter_async', 1)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_async = 1
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 55: call s:set('g:gitgutter_log',                            0)
calling function <SNR>46_set('g:gitgutter_log', 0)

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 5: let g:gitgutter_log = 0
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 56: 
line 57: call s:set('g:gitgutter_git_executable', 'git')
calling function <SNR>46_set('g:gitgutter_git_executable', 'git')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_git_executable = 'git'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 58: if !executable(g:gitgutter_git_executable)
line 59:   call gitgutter#utility#warn('cannot find git. Please set g:gitgutter_git_executable.')
line 60: endif
line 61: 
line 62: let default_grep = 'grep'
line 63: call s:set('g:gitgutter_grep', default_grep)
calling function <SNR>46_set('g:gitgutter_grep', 'grep')

line 1:   if !exists(a:var)
line 2:     if type(a:default)
line 3:       execute 'let' a:var '=' string(a:default)
line 3: let g:gitgutter_grep = 'grep'
line 4:     else
line 5:       execute 'let' a:var '=' a:default
line 6:     endif
line 7:   endif
function <SNR>46_set returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 64: if !empty(g:gitgutter_grep)
line 65:   if executable(split(g:gitgutter_grep)[0])
line 66:     if $GREP_OPTIONS =~# '--color=always'
line 67:       let g:gitgutter_grep .= ' --color=never'
line 68:     endif
line 69:   else
line 70:     if g:gitgutter_grep !=# default_grep
line 71:       call gitgutter#utility#warn('cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
line 72:     endif
line 73:     let g:gitgutter_grep = ''
line 74:   endif
line 75: endif
line 76: 
line 77: call gitgutter#highlight#define_sign_column_highlight()
Searching for "autoload/gitgutter/highlight.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter/highlight.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter)
fchdir() to previous dir
line 77: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim"
line 1: function! gitgutter#highlight#line_disable() abort
line 12: 
line 13: function! gitgutter#highlight#line_enable() abort
line 25: 
line 26: function! gitgutter#highlight#line_toggle() abort
line 33: 
line 34: 
line 35: function! gitgutter#highlight#define_sign_column_highlight() abort
line 42: 
line 43: function! gitgutter#highlight#define_highlights() abort
line 70: 
line 71: function! gitgutter#highlight#define_signs() abort
line 84: 
line 85: function! s:define_sign_text() abort
line 93: 
line 94: function! gitgutter#highlight#define_sign_text_highlights() abort
line 115: 
line 116: function! s:define_sign_line_highlights() abort
line 133: 
line 134: function! s:get_background_colors(group) abort
line 148: 
line 149: function! s:match_highlight(highlight, pattern) abort
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim
continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
calling function gitgutter#highlight#define_sign_column_highlight()

line 1:   if g:gitgutter_override_sign_column_highlight
line 2:     highlight! link SignColumn LineNr
line 3:   else
line 4:     highlight default link SignColumn LineNr
line 5:   endif
function gitgutter#highlight#define_sign_column_highlight returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 78: call gitgutter#highlight#define_highlights()
calling function gitgutter#highlight#define_highlights()

line 1:   let [guibg, ctermbg] = s:get_background_colors('SignColumn')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors('SignColumn')

line 1:   redir => highlight
line 2:   silent execute 'silent highlight ' . a:group
line 2: silent highlight SignColumn
SignColumn     xxx term=standout ctermbg=237 guibg=#3c3836
	Last set from /usr/share/vim/vimfiles/colors/gruvbox.vim line 417
line 3:   redir END
line 4: 
line 5:   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
line 6:   if len(link_matches) > 0 " follow the link
line 7:     return s:get_background_colors(link_matches[1])
line 8:   endif
line 9: 
line 10:   let ctermbg = s:match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[10]..<SNR>48_match_highlight('
line 2:   silent execute ''silent h...vbox.vim line 417
line 3:   redir END', 'ctermbg=\([0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[10]..<SNR>48_match_highlight returning '237'

continuing in function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors

line 11:   let guibg   = s:match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
calling function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[11]..<SNR>48_match_highlight('
line 2:   silent execute ''silent h...vbox.vim line 417
line 3:   redir END', 'guibg=\([#0-9A-Za-z]\+\)')

line 1:   let matches = matchlist(a:highlight, a:pattern)
line 2:   if len(matches) == 0
line 3:     return 'NONE'
line 4:   endif
line 5:   return matches[1]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors[11]..<SNR>48_match_highlight returning '#3c3836'

continuing in function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors

line 12:   return [guibg, ctermbg]
function gitgutter#highlight#define_highlights[1]..<SNR>48_get_background_colors returning ['#3c3836', '237']

continuing in function gitgutter#highlight#define_highlights

line 2: 
line 3:   " Highlights used by the signs.
line 4: 
line 5:   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
line 5: highlight GitGutterAddDefault    guifg=#009900 guibg=#3c3836 ctermfg=2 ctermbg=237
line 6:   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
line 6: highlight GitGutterChangeDefault guifg=#bbbb00 guibg=#3c3836 ctermfg=3 ctermbg=237
line 7:   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
line 7: highlight GitGutterDeleteDefault guifg=#ff2222 guibg=#3c3836 ctermfg=1 ctermbg=237
line 8:   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
line 9: 
line 10:   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 10: highlight GitGutterAddInvisible    guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 11:   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 11: highlight GitGutterChangeInvisible guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 12:   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
line 12: highlight GitGutterDeleteInvisible guifg=bg guibg=#3c3836 ctermfg=237 ctermbg=237
line 13:   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
line 14: 
line 15:   highlight default link GitGutterAdd          GitGutterAddDefault
line 16:   highlight default link GitGutterChange       GitGutterChangeDefault
line 17:   highlight default link GitGutterDelete       GitGutterDeleteDefault
line 18:   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
line 19: 
line 20:   " Highlights used for the whole line.
line 21: 
line 22:   highlight default link GitGutterAddLine          DiffAdd
line 23:   highlight default link GitGutterChangeLine       DiffChange
line 24:   highlight default link GitGutterDeleteLine       DiffDelete
line 25:   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
function gitgutter#highlight#define_highlights returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 79: call gitgutter#highlight#define_signs()
calling function gitgutter#highlight#define_signs()

line 1:   sign define GitGutterLineAdded
line 2:   sign define GitGutterLineModified
line 3:   sign define GitGutterLineRemoved
line 4:   sign define GitGutterLineRemovedFirstLine
line 5:   sign define GitGutterLineRemovedAboveAndBelow
line 6:   sign define GitGutterLineModifiedRemoved
line 7:   sign define GitGutterDummy
line 8: 
line 9:   call s:define_sign_text()
calling function gitgutter#highlight#define_signs[9]..<SNR>48_define_sign_text()

line 1:   execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
line 1: sign define GitGutterLineAdded                 text=+
line 2:   execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
line 2: sign define GitGutterLineModified              text=~
line 3:   execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
line 3: sign define GitGutterLineRemoved               text=_
line 4:   execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
line 4: sign define GitGutterLineRemovedFirstLine      text=
line 5:   execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
line 5: sign define GitGutterLineRemovedAboveAndBelow  text=[
line 6:   execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed
line 6: sign define GitGutterLineModifiedRemoved       text=~_
function gitgutter#highlight#define_signs[9]..<SNR>48_define_sign_text returning #0

continuing in function gitgutter#highlight#define_signs

line 10:   call gitgutter#highlight#define_sign_text_highlights()
calling function gitgutter#highlight#define_signs[10]..gitgutter#highlight#define_sign_text_highlights()

line 1:   " Once a sign's text attribute has been defined, it cannot be undefined or
line 2:   " set to an empty value.  So to make signs' text disappear (when toggling
line 3:   " off or disabling) we make them invisible by setting their foreground colours
line 4:   " to the background's.
line 5:   if g:gitgutter_signs
line 6:     sign define GitGutterLineAdded                 texthl=GitGutterAdd
line 7:     sign define GitGutterLineModified              texthl=GitGutterChange
line 8:     sign define GitGutterLineRemoved               texthl=GitGutterDelete
line 9:     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
line 10:     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
line 11:     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
line 12:   else
line 13:     sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
line 14:     sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
line 15:     sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
line 16:     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
line 17:     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
line 18:     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
line 19:   endif
function gitgutter#highlight#define_signs[10]..gitgutter#highlight#define_sign_text_highlights returning #0

continuing in function gitgutter#highlight#define_signs

line 11:   call s:define_sign_line_highlights()
calling function gitgutter#highlight#define_signs[11]..<SNR>48_define_sign_line_highlights()

line 1:   if g:gitgutter_highlight_lines
line 2:     sign define GitGutterLineAdded                 linehl=GitGutterAddLine
line 3:     sign define GitGutterLineModified              linehl=GitGutterChangeLine
line 4:     sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
line 5:     sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
line 6:     sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
line 7:     sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
line 8:   else
line 9:     sign define GitGutterLineAdded                 linehl=
line 10:     sign define GitGutterLineModified              linehl=
line 11:     sign define GitGutterLineRemoved               linehl=
line 12:     sign define GitGutterLineRemovedFirstLine      linehl=
line 13:     sign define GitGutterLineRemovedAboveAndBelow  linehl=
line 14:     sign define GitGutterLineModifiedRemoved       linehl=
line 15:   endif
function gitgutter#highlight#define_signs[11]..<SNR>48_define_sign_line_highlights returning #0

continuing in function gitgutter#highlight#define_signs

function gitgutter#highlight#define_signs returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 80: 
line 81: " Prevent infinite loop where:
line 82: " - executing a job in the foreground launches a new window which takes the focus;
line 83: " - when the job finishes, focus returns to gvim;
line 84: " - the FocusGained event triggers a new job (see below).
line 85: if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
calling function gitgutter#utility#windows()

line 1:   return has('win64') || has('win32') || has('win16')
function gitgutter#utility#windows returning #0

continuing in /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim

line 86:   set noshelltemp
line 87: endif
line 88: 
line 89: " }}}
line 90: 
line 91: " Primary functions {{{
line 92: 
line 93: command! -bar GitGutterAll call gitgutter#all(1)
line 94: command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
line 95: 
line 96: command! -bar GitGutterDisable call gitgutter#disable()
line 97: command! -bar GitGutterEnable  call gitgutter#enable()
line 98: command! -bar GitGutterToggle  call gitgutter#toggle()
line 99: 
line 100: command! -bar GitGutterBufferDisable call gitgutter#buffer_disable()
line 101: command! -bar GitGutterBufferEnable  call gitgutter#buffer_enable()
line 102: command! -bar GitGutterBufferToggle  call gitgutter#buffer_toggle()
line 103: 
line 104: " }}}
line 105: 
line 106: " Line highlights {{{
line 107: 
line 108: command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
line 109: command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
line 110: command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
line 111: 
line 112: " }}}
line 113: 
line 114: " Signs {{{
line 115: 
line 116: command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
line 117: command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
line 118: command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
line 119: 
line 120: " }}}
line 121: 
line 122: " Hunks {{{
line 123: 
line 124: command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
line 125: command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
line 126: 
line 127: command! -bar GitGutterStageHunk   call gitgutter#hunk#stage()
line 128: command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
line 129: command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
line 130: 
line 131: " Hunk text object
line 132: onoremap <silent> <Plug>GitGutterTextObjectInnerPending :<C-U>call gitgutter#hunk#text_object(1)<CR>
line 133: onoremap <silent> <Plug>GitGutterTextObjectOuterPending :<C-U>call gitgutter#hunk#text_object(0)<CR>
line 134: xnoremap <silent> <Plug>GitGutterTextObjectInnerVisual  :<C-U>call gitgutter#hunk#text_object(1)<CR>
line 135: xnoremap <silent> <Plug>GitGutterTextObjectOuterVisual  :<C-U>call gitgutter#hunk#text_object(0)<CR>
line 136: 
line 137: 
line 138: " Returns the git-diff hunks for the file or an empty list if there
line 139: " aren't any hunks.
line 140: "
line 141: " The return value is a list of lists.  There is one inner list per hunk.
line 142: "
line 143: "   [
line 144: "     [from_line, from_count, to_line, to_count],
line 145: "     [from_line, from_count, to_line, to_count],
line 146: "     ...
line 147: "   ]
line 148: "
line 149: " where:
line 150: "
line 151: " `from`  - refers to the staged file
line 152: " `to`    - refers to the working tree's file
line 153: " `line`  - refers to the line number where the change starts
line 154: " `count` - refers to the number of lines the change covers
line 155: function! GitGutterGetHunks()
line 159: 
line 160: " Returns an array that contains a summary of the hunk status for the current
line 161: " window.  The format is [ added, modified, removed ], where each value
line 162: " represents the number of lines added/modified/removed respectively.
line 163: function! GitGutterGetHunkSummary()
line 166: 
line 167: " }}}
line 168: 
line 169: command! -bar GitGutterDebug call gitgutter#debug#debug()
line 170: 
line 171: " Maps {{{
line 172: 
line 173: nnoremap <silent> <expr> <Plug>GitGutterNextHunk &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
line 174: nnoremap <silent> <expr> <Plug>GitGutterPrevHunk &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
line 175: 
line 176: nnoremap <silent> <Plug>GitGutterStageHunk   :GitGutterStageHunk<CR>
line 177: nnoremap <silent> <Plug>GitGutterUndoHunk    :GitGutterUndoHunk<CR>
line 178: nnoremap <silent> <Plug>GitGutterPreviewHunk :GitGutterPreviewHunk<CR>
line 179: 
line 180: " }}}
line 181: 
line 182: function! s:on_bufenter()
line 191: 
line 192: " Autocommands {{{
line 193: 
line 194: augroup gitgutter
line 195:   autocmd!
line 196: 
line 197:   autocmd TabEnter * let t:gitgutter_didtabenter = 1
line 198: 
line 199:   autocmd BufEnter * call s:on_bufenter()
line 200: 
line 201:   autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
line 202:   autocmd FileChangedShellPost   * call gitgutter#process_buffer(bufnr(''), 1)
line 203: 
line 204:   " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
line 205:   "
line 206:   "   vim -o file1 file2
line 207:   autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
line 208: 
line 209:   autocmd FocusGained,ShellCmdPost * call gitgutter#all(1)
line 210:   autocmd WinLeave * if bufname('') =~ '^term://' | call gitgutter#all(1) | endif
line 211: 
line 212:   if exists('##VimResume')
line 213:     autocmd VimResume * call gitgutter#all(1)
line 214:   endif
line 215: 
line 216:   autocmd ColorScheme * call gitgutter#highlight#define_sign_column_highlight() | call gitgutter#highlight#define_highlights()
line 217: 
line 218:   " Disable during :vimgrep
line 219:   autocmd QuickFixCmdPre  *vimgrep* let g:gitgutter_enabled = 0
line 220:   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = 1
line 221: augroup END
line 222: 
line 223: " }}}
line 224: 
line 225: " vim:set et sw=2 fdm=marker:
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim
Searching for "/home/ringu/.vim/plugged/indentLine/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/asyncomplete.vim/plugin/asyncomplete.vim"
line 1: if exists('g:asyncomplete_loaded')
line 2:     finish
line 3: endif
line 4: let g:asyncomplete_loaded = 1
line 5: 
line 6: let s:has_lua = has('lua') || has('nvim-0.2.2')
line 7: 
line 8: if get(g:, 'asyncomplete_enable_for_all', 1)
line 9:     augroup asyncomplete_enable
line 10:         au!
line 11:         au BufEnter * if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif
line 12:     augroup END
line 13: endif
line 14: 
line 15: let g:asyncomplete_auto_popup = get(g:, 'asyncomplete_auto_popup', 1)
line 16: let g:asyncomplete_completion_delay = get(g:, 'asyncomplete_completion_delay', 100)
line 17: let g:asyncomplete_default_refresh_pattern = get(g:, 'asyncomplete_default_refresh_pattern', '\(\k\+$\|\.$\|>$\|:$\)')
line 18: let g:asyncomplete_log_file = get(g:, 'asyncomplete_log_file', '')
line 19: let g:asyncomplete_smart_completion = get(g:, 'asyncomplete_smart_completion', s:has_lua && exists('##TextChangedP'))
line 20: let g:asyncomplete_remove_duplicates = get(g:, 'asyncomplete_remove_duplicates', 0)
line 21: 
line 22: " Setting it to true may slow/hang vim especially on slow are sources such as asyncomplete-lsp.vim
line 23: " use asyncomplete_force_refersh to retrive the latest autocomplete results instead.
line 24: let g:asyncomplete_force_refresh_on_context_changed = get(g:, 'asyncomplete_force_refresh_on_context_changed', 0)
line 25: 
line 26: " imap <c-space> <Plug>(asyncomplete_force_refresh)
line 27: inoremap <silent> <expr> <Plug>(asyncomplete_force_refresh) asyncomplete#force_refresh()
finished sourcing /home/ringu/.vim/plugged/asyncomplete.vim/plugin/asyncomplete.vim
Searching for "/home/ringu/.vim/plugged/async.vim/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/vim-lsp/plugin/lsp.vim"
line 1: if exists('g:lsp_loaded')
line 2:     finish
line 3: endif
line 4: let g:lsp_loaded = 1
line 5: 
line 6: let g:lsp_auto_enable = get(g:, 'lsp_auto_enable', 1)
line 7: let g:lsp_async_completion = get(g:, 'lsp_async_completion', 0)
line 8: let g:lsp_log_file = get(g:, 'lsp_log_file', '')
line 9: let g:lsp_log_verbose = get(g:, 'lsp_log_verbose', 1)
line 10: let g:lsp_debug_servers = get(g:, 'lsp_debug_servers', [])
line 11: let g:lsp_signs_enabled = get(g:, 'lsp_signs_enabled', 0)
line 12: let g:lsp_signs_error = get(g:, 'lsp_signs_error', {})
line 13: let g:lsp_signs_warning = get(g:, 'lsp_signs_warning', {})
line 14: let g:lsp_signs_information = get(g:, 'lsp_signs_information', {})
line 15: let g:lsp_signs_hint = get(g:, 'lsp_signs_hint', {})
line 16: let g:lsp_diagnostics_enabled = get(g:, 'lsp_diagnostics_enabled', 1)
line 17: let g:lsp_diagnostics_echo_cursor = get(g:, 'lsp_diagnostics_echo_cursor', 0)
line 18: let g:lsp_diagnostics_echo_delay = get(g:, 'lsp_diagnostics_echo_delay', 500)
line 19: let g:lsp_next_sign_id = get(g:, 'lsp_next_sign_id', 6999)
line 20: let g:lsp_preview_keep_focus = get(g:, 'lsp_preview_keep_focus', 1)
line 21: 
line 22: if g:lsp_auto_enable
line 23:     augroup lsp_auto_enable
line 24:         autocmd!
line 25:         autocmd VimEnter * call lsp#enable()
line 26:     augroup END
line 27: endif
line 28: 
line 29: command! LspCodeAction call lsp#ui#vim#code_action()
line 30: command! LspDefinition call lsp#ui#vim#definition()
line 31: command! LspDocumentSymbol call lsp#ui#vim#document_symbol()
line 32: command! LspDocumentDiagnostics call lsp#ui#vim#diagnostics#document_diagnostics()
line 33: command! -nargs=? -complete=customlist,lsp#utils#empty_complete LspHover call lsp#ui#vim#hover#get_hover_under_cursor()
line 34: command! LspNextError call lsp#ui#vim#signs#next_error()
line 35: command! LspPreviousError call lsp#ui#vim#signs#previous_error()
line 36: command! LspReferences call lsp#ui#vim#references()
line 37: command! LspRename call lsp#ui#vim#rename()
line 38: command! LspWorkspaceSymbol call lsp#ui#vim#workspace_symbol()
line 39: command! LspDocumentFormat call lsp#ui#vim#document_format()
line 40: command! LspDocumentFormatSync call lsp#ui#vim#document_format_sync()
line 41: command! -range LspDocumentRangeFormat call lsp#ui#vim#document_range_format()
line 42: command! LspImplementation call lsp#ui#vim#implementation()
line 43: command! LspTypeDefinition call lsp#ui#vim#type_definition()
line 44: command! -nargs=0 LspStatus echo lsp#get_server_status()
line 45: 
line 46: nnoremap <expr> <plug>(lsp-code-action) [lsp#ui#vim#code_action(),''][1]
line 47: nnoremap <expr> <plug>(lsp-definition) [lsp#ui#vim#definition(), ''][1]
line 48: nnoremap <expr> <plug>(lsp-document-symbol) [lsp#ui#vim#document_symbol(),''][1]
line 49: nnoremap <expr> <plug>(lsp-document-diagnostics) [lsp#ui#vim#diagnostics#document_diagnostics(),''][1]
line 50: nnoremap <expr> <plug>(lsp-hover) [lsp#ui#vim#hover#get_hover_under_cursor(),''][1]
line 51: nnoremap <expr> <plug>(lsp-next-error) [lsp#ui#vim#signs#next_error(),''][1]
line 52: nnoremap <expr> <plug>(lsp-previous-error) [lsp#ui#vim#signs#previous_error(),''][1]
line 53: nnoremap <expr> <plug>(lsp-references) [lsp#ui#vim#references(),''][1]
line 54: nnoremap <expr> <plug>(lsp-rename) [lsp#ui#vim#rename(),''][1]
line 55: nnoremap <expr> <plug>(lsp-workspace-symbol) [lsp#ui#vim#workspace_symbol(),''][1]
line 56: nnoremap <expr> <plug>(lsp-document-format) [lsp#ui#vim#document_format(),''][1]
line 57: vnoremap <expr> <plug>(lsp-document-format) [lsp#ui#vim#document_range_format(),''][1]
line 58: nnoremap <expr> <plug>(lsp-implementation) [lsp#ui#vim#implementation(),''][1]
line 59: nnoremap <expr> <plug>(lsp-type-definition) [lsp#ui#vim#type_definition(),''][1]
line 60: nnoremap <expr> <plug>(lsp-status) [execute("echo lsp#get_server_status()",1),''][1]
finished sourcing /home/ringu/.vim/plugged/vim-lsp/plugin/lsp.vim
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/asyncomplete-lsp.vim"
line 1: if exists('g:asyncomplete_lsp_loaded')
line 2:     finish
line 3: endif
line 4: let g:asyncomplete_lsp_loaded = 1
line 5: 
line 6: let s:servers = {} " { server_name: 1 }
line 7: 
line 8: au User lsp_server_init call s:server_initialized()
line 9: au User lsp_server_exit call s:server_exited()
line 10: 
line 11: function! s:server_initialized() abort
line 42: 
line 43: function! s:server_exited() abort
line 55: 
line 56: function! s:generate_asyncomplete_name(server_name) abort
line 59: 
line 60: function! s:completor(server_name, opt, ctx) abort
line 70: 
line 71: function! s:handle_completion(server_name, opt, ctx, data) abort
finished sourcing /home/ringu/.vim/plugged/asyncomplete-lsp.vim/plugin/asyncomplete-lsp.vim
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
chdir(/usr/share/vim/vimfiles/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vimfiles/plugin/fzf.vim"
line 1: " Copyright (c) 2017 Junegunn Choi
line 2: "
line 3: " MIT License
line 4: "
line 5: " Permission is hereby granted, free of charge, to any person obtaining
line 6: " a copy of this software and associated documentation files (the
line 7: " "Software"), to deal in the Software without restriction, including
line 8: " without limitation the rights to use, copy, modify, merge, publish,
line 9: " distribute, sublicense, and/or sell copies of the Software, and to
line 10: " permit persons to whom the Software is furnished to do so, subject to
line 11: " the following conditions:
line 12: "
line 13: " The above copyright notice and this permission notice shall be
line 14: " included in all copies or substantial portions of the Software.
line 15: "
line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
line 23: 
line 24: if exists('g:loaded_fzf')
line 25:   finish
line 26: endif
line 27: let g:loaded_fzf = 1
line 28: 
line 29: let s:is_win = has('win32') || has('win64')
line 30: if s:is_win && &shellslash
line 31:   set noshellslash
line 32:   let s:base_dir = expand('<sfile>:h:h')
line 33:   set shellslash
line 34: else
line 35:   let s:base_dir = expand('<sfile>:h:h')
line 36: endif
line 37: if s:is_win
line 38:   let s:term_marker = '&::FZF'
line 39: 
line 40:   function! s:fzf_call(fn, ...)
line 49: 
line 50:   " Use utf-8 for fzf.vim commands
line 51:   " Return array of shell commands for cmd.exe
line 52:   function! s:wrap_cmds(cmds)
line 57: else
line 58:   let s:term_marker = ";#FZF"
line 59: 
line 60:   function! s:fzf_call(fn, ...)
line 63: 
line 64:   function! s:wrap_cmds(cmds)
line 67: endif
line 68: 
line 69: function! s:shellesc_cmd(arg)
line 76: 
line 77: function! fzf#shellescape(arg, ...)
line 84: 
line 85: function! s:fzf_getcwd()
line 88: 
line 89: function! s:fzf_fnamemodify(fname, mods)
line 92: 
line 93: function! s:fzf_expand(fmt)
line 96: 
line 97: function! s:fzf_tempname()
line 100: 
line 101: let s:default_layout = { 'down': '~40%' }
line 102: let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
line 103: let s:fzf_go = s:base_dir.'/bin/fzf'
line 104: let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
line 105: let s:install = s:base_dir.'/install'
line 106: let s:installed = 0
line 107: 
line 108: let s:cpo_save = &cpo
line 109: set cpo&vim
line 110: 
line 111: function! s:fzf_exec()
line 137: 
line 138: function! s:tmux_enabled()
line 154: 
line 155: function! s:escape(path)
line 159: 
line 160: " Upgrade legacy options
line 161: function! s:upgrade(dict)
line 174: 
line 175: function! s:error(msg)
line 180: 
line 181: function! s:warn(msg)
line 186: 
line 187: function! s:has_any(dict, keys)
line 195: 
line 196: function! s:open(cmd, target)
line 202: 
line 203: function! s:common_sink(action, lines) abort
line 240: 
line 241: function! s:get_color(attr, ...)
line 253: 
line 254: function! s:defaults()
line 259: 
line 260: function! s:validate_layout(layout)
line 269: 
line 270: function! s:evaluate_opts(options)
line 274: 
line 275: " [name string,] [opts dict,] [fullscreen boolean]
line 276: function! fzf#wrap(...)
line 335: 
line 336: function! s:use_sh()
line 346: 
line 347: function! fzf#run(...) abort
line 422: 
line 423: function! s:present(dict, ...)
line 431: 
line 432: function! s:fzf_tmux(dict)
line 449: 
line 450: function! s:splittable(dict)
line 454: 
line 455: function! s:pushd(dict)
line 470: 
line 471: augroup fzf_popd
line 472:   autocmd!
line 473:   autocmd WinEnter * call s:dopopd()
line 474: augroup END
line 475: 
line 476: function! s:dopopd()
line 501: 
line 502: function! s:xterm_launcher()
line 511: unlet! s:launcher
line 512: if s:is_win || has('win32unix')
line 513:   let s:launcher = '%s'
line 514: else
line 515:   let s:launcher = function('s:xterm_launcher')
line 516: endif
line 517: 
line 518: function! s:exit_handler(code, command, ...)
line 530: 
line 531: function! s:execute(dict, command, use_height, temps) abort
line 581: 
line 582: function! s:execute_tmux(dict, command, temps) abort
line 595: 
line 596: function! s:calc_size(max, val, dict)
line 614: 
line 615: function! s:getpos()
line 618: 
line 619: function! s:split(dict)
line 652: 
line 653: function! s:execute_term(dict, command, temps) abort
line 733: 
line 734: function! s:collect(temps) abort
line 743: 
line 744: function! s:callback(dict, lines) abort
line 775: 
line 779: let s:default_action = { 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }
line 780: 
line 781: function! s:shortpath()
line 789: 
line 790: function! s:cmd(bang, ...) abort
line 807: 
line 808: command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
line 809: 
line 810: let &cpo = s:cpo_save
line 811: unlet s:cpo_save
finished sourcing /usr/share/vim/vimfiles/plugin/fzf.vim
Searching for "/usr/share/vim/vim81/plugin/**/*.vim"
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim81/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 52: augroup END
finished sourcing /usr/share/vim/vim81/plugin/gzip.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/logiPat.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2018 Feb 04
line 4: 
line 5: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER
line 6: 
line 7: function! s:ManPager()
finished sourcing /usr/share/vim/vim81/plugin/manpager.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2018 Jul 3
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 197: 
line 198: " Define commands that will disable and enable the plugin.
line 199: command! DoMatchParen call s:DoMatchParen()
line 200: command! NoMatchParen call s:NoMatchParen()
line 201: 
line 202: func! s:NoMatchParen()
line 209: 
line 210: func! s:DoMatchParen()
line 216: 
line 217: let &cpo = s:cpo_save
line 218: unlet s:cpo_save
finished sourcing /usr/share/vim/vim81/plugin/matchparen.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v156"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try                                                       
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
line 86:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 152: "             them, which checks if they're directories and will create a directory
line 153: "             listing when appropriate.
line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 155: "             has already been called.
line 156: fun! s:VimEnter(dirname)
line 164: 
line 165: " ---------------------------------------------------------------------
line 166: " NetrwStatusLine: {{{1
line 167: fun! NetrwStatusLine()
line 178: 
line 179: " ------------------------------------------------------------------------
line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 184: fun! NetUserPass(...)
line 208: 
line 209: " ------------------------------------------------------------------------
line 210: " Modelines And Restoration: {{{1
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /usr/share/vim/vim81/plugin/rrhelper.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim81/plugin/spellfile.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47: augroup END
line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 49: 
line 50: " ---------------------------------------------------------------------
line 51: " Restoration And Modelines: {{{1
line 52: " vim: fdm=marker
line 53: let &cpo= s:keepcpo
line 54: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2018 Nov 11
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim8.1_v1'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   8.1_v1  (this version): Fix Bitbucket issue #6: Don't generate empty script
line 16: "                           tag.
line 17: "                           Fix Bitbucket issue #5: javascript should
line 18: "                           declare variables with "var".
line 19: "                           Fix Bitbucket issue #13: errors thrown sourcing
line 20: "                           2html.vim directly when plugins not loaded.
line 21: "                           Fix Bitbucket issue #16: support 'vartabstop'.
line 22: "
line 23: "   7.4 updates: {{{
line 24: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 25: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 26: "                           take a list so it is easier to specfiy fallback
line 27: "                           fonts in the generated CSS.
line 28: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 29: "^I^I^I    also for version-specific modelines like "vim>703:".
line 30: "}}}
line 31: "
line 32: "   7.3 updates: {{{
line 33: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 34: "^I^I^I    g:html_line_ids=0. Allow customizing
line 35: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 36: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 37: "^I^I^I    is started.
line 38: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 39: "^I^I^I    insert modeline to set it to manual.
line 40: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 41: "^I^I^I    duplicate of one buffer instead of including both.
line 42: "^I^I^I    Add anchors to each line so you can put '#L123'
line 43: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 44: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 45: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 46: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 47: "^I^I^I    Allow TOhtml to chain together with other commands
line 48: "^I^I^I    using |.
line 49: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 50: "^I^I^I    highlight groups make up the start-of-modeline text.
line 51: "^I^I^I    Improve render time of page with uncopyable regions
line 52: "^I^I^I    by not using one-input-per-char. Change name of
line 53: "^I^I^I    uncopyable option from html_unselectable to
line 54: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 55: "^I^I^I    default to inserting invalid markup for uncopyable
line 56: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 57: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 58: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 59: "^I^I^I    eliminate post-processing substitute commands in
line 60: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 61: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 62: "^I^I^I    speed improvements. Fix modeline mangling in
line 63: "^I^I^I    generated output so it works for text in the first
line 64: "^I^I^I    column. Fix missing line number and fold column in
line 65: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 66: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 67: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 68: "^I^I^I    the new default foldtext added in v11, as the patch
line 69: "^I^I^I    adding it has not yet been included in Vim.
line 70: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 71: "^I^I^I    Brabandt in
line 72: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 73: "^I^I^I    This patch has not yet been included in Vim, thus
line 74: "^I^I^I    these changes are removed in the next version.
line 75: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 76: "^I^I^I    multiple nested folds with dynamic folding on.
line 77: "^I^I^I    Also fix problem with foldtext in this situation.
line 78: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 79: "^I^I^I    and without html_no_pre, default value same as
line 80: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 81: "^I^I^I    'fileencoding' for converted document encoding if
line 82: "^I^I^I    'buftype' indicates a special buffer which isn't
line 83: "^I^I^I    written.
line 84: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 85: "^I^I^I    characters in generated output (Andy Spencer).
line 86: "^I^I^I    Escape text that looks like a modeline so Vim
line 87: "^I^I^I    doesn't use anything in the converted HTML as a
line 88: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 89: "^I^I^I    before the conversion range. Remove fold column when
line 90: "^I^I^I    there are no folds.
line 91: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 92: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 93: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 94: "^I^I^I    supported by all major browsers according to
line 95: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 96: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 97: "^I^I^I    HTML encoding to Vim encoding detection be
line 98: "^I^I^I    case-insensitive for built-in pairs.
line 99: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 100: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 101: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 102: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 103: "^I^I^I    file matches its indicated charset. Add charsets for
line 104: "^I^I^I    all of Vim's natively supported encodings.
line 105: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 106: "^I^I^I    user settings interfering with diff mode generation,
line 107: "^I^I^I    trailing whitespace (e.g. line number column) when
line 108: "^I^I^I    using html_no_pre, and bugs when using
line 109: "^I^I^I    html_hover_unfold.
line 110: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 111: "^I^I^I    folds in diff mode when first line was folded.
line 112: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 113: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 114: "^I^I^I    default to true when not set to anything. Use strict
line 115: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 116: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 117: "^I^I^I    when using this option. Add meta tag for settings.
line 118: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 119: "^I^I^I    diff colors and the normal syntax colors
line 120: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 121: "}}}
line 122: "}}}
line 123: 
line 124: " TODO: {{{
line 125: "   * Check the issue tracker:
line 126: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
line 127: "   * Options for generating the CSS in external style sheets. New :TOcss
line 128: "     command to convert the current color scheme into a (mostly) generic CSS
line 129: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 130: "     by Erik Falor
line 131: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 132: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 133: "     term) to use for the styling. Suggestion by "nacitar".
line 134: "   * Add way to override or specify which RGB colors map to the color numbers
line 135: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 136: "   * Disable filetype detection until after all processing is done.
line 137: "   * Add option for not generating the hyperlink on stuff that looks like a
line 138: "     URL? Or just color the link to fit with the colorscheme (and only special
line 139: "     when hovering)?
line 140: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 141: "     regions is turned on. Possible solution: Add normal text line numbers with
line 142: "     display:none, set to display:inline for print style sheets, and hide
line 143: "     <input> elements for print, to allow Opera printing multiple pages (and
line 144: "     other uncopyable areas?). May need to make the new text invisible to IE
line 145: "     with conditional comments to prevent copying it, IE for some reason likes
line 146: "     to copy hidden text. Other browsers too?
line 147: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 148: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 149: "     on Windows). Perhaps it is font related?
line 150: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 151: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 152: "     on diff lines though.
line 153: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 154: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 155: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 156: "     accepted to modify it.
line 157: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 158: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 159: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 160: "     does not show the whole diff filler as it is supposed to?
line 161: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 162: "     invalid content. Can/should anything be done about this? Maybe a separate
line 163: "     plugin to correct 'isprint' based on encoding?
line 164: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 165: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 166: "   * Font auto-detection similar to
line 167: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 168: "     platforms.
line 169: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 170: "^I- listchars support
line 171: "^I- full-line background highlight
line 172: "^I- other?
line 173: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 174: "     free with full-line background highlight above).
line 175: "   * Restore open/closed folds and cursor position after processing each file
line 176: "     with option not to restore for speed increase.
line 177: "   * Add extra meta info (generation time, etc.)?
line 178: "   * Tidy up so we can use strict doctype in even more situations
line 179: "   * Implementation detail: add threshold for writing the lines to the html
line 180: "     buffer before we're done (5000 or so lines should do it)
line 181: "   * TODO comments for code cleanup scattered throughout
line 182: "}}}
line 183: 
line 184: " Define the :TOhtml command when:
line 185: " - 'compatible' is not set
line 186: " - this plugin or user override was not already loaded
line 187: " - user commands are available. {{{
line 188: if !&cp && !exists(":TOhtml") && has("user_commands")
line 189:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 190: endif "}}}
line 191: 
line 192: " Make sure any patches will probably use consistent indent
line 193: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim81/plugin/tohtml.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37: augroup END
line 38: 
line 39: " =====================================================================
line 40: " Restoration And Modelines: {{{1
line 41: " vim: fdm=marker
line 42: let &cpo= s:keepcpo
line 43: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim81/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim81/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^ISep 13, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v28"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/share/vim/vim81/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/ringu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"
Searching for "/usr/share/vim/vim81/pack/*/start/*"
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"
Searching for "/home/ringu/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/plugin/**/*.vim"
chdir(/home/ringu/.vim/plugged/indentLine/after/plugin)
fchdir() to previous dir
sourcing "/home/ringu/.vim/plugged/indentLine/after/plugin/indentLine.vim"
line 1: " Script Name: indentLine.vim
line 2: " Author:      Yggdroot <archofortune@gmail.com>
line 3: "
line 4: " Description: To show the indention levels with thin vertical lines
line 5: 
line 6: scriptencoding utf-8
line 7: 
line 8: if !has("conceal") || exists("g:indentLine_loaded")
line 9:     finish
line 10: endif
line 11: let g:indentLine_loaded = 1
line 12: 
line 13: let g:indentLine_newVersion = get(g:,'indentLine_newVersion',v:version > 704 || v:version == 704 && has("patch792"))
line 14: 
line 15: let g:indentLine_char = get(g:, 'indentLine_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '|'))
line 16: let g:indentLine_first_char = get(g:, 'indentLine_first_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '|'))
line 17: let g:indentLine_indentLevel = get(g:, 'indentLine_indentLevel', 20)
line 18: let g:indentLine_enabled = get(g:, 'indentLine_enabled', 1)
line 19: let g:indentLine_fileType = get(g:, 'indentLine_fileType', [])
line 20: let g:indentLine_fileTypeExclude = get(g:, 'indentLine_fileTypeExclude', [])
line 21: let g:indentLine_bufNameExclude = get(g:, 'indentLine_bufNameExclude', [])
line 22: let g:indentLine_bufTypeExclude = get(g:, 'indentLine_bufTypeExclude', [])
line 23: let g:indentLine_showFirstIndentLevel = get(g:, 'indentLine_showFirstIndentLevel', 0)
line 24: let g:indentLine_maxLines = get(g:, 'indentLine_maxLines', 3000)
line 25: let g:indentLine_setColors = get(g:, 'indentLine_setColors', 1)
line 26: let g:indentLine_setConceal = get(g:, 'indentLine_setConceal', 1)
line 27: let g:indentLine_defaultGroup = get(g:, 'indentLine_defaultGroup', "")
line 28: let g:indentLine_faster = get(g:, 'indentLine_faster', 0)
line 29: let g:indentLine_leadingSpaceChar = get(g:, 'indentLine_leadingSpaceChar', (&encoding ==# "utf-8" && &term isnot# "linux" ? '' : '.'))
line 30: let g:indentLine_leadingSpaceEnabled = get(g:, 'indentLine_leadingSpaceEnabled', 0)
line 31: let g:indentLine_mysyntaxfile = fnamemodify(expand("<sfile>"), ":p:h:h")."/syntax/indentLine.vim"
line 32: 
line 33: "{{{1 function! s:InitColor()
line 34: function! s:InitColor()
line 93: 
line 94: "{{{1 function! s:SetConcealOption()
line 95: function! s:SetConcealOption()
line 107: 
line 108: function! s:ResetConcealOption()
line 119: 
line 120: "{{{1 function! s:IndentLinesEnable()
line 121: function! s:IndentLinesEnable()
line 176: 
line 177: "{{{1 function! s:IndentLinesDisable()
line 178: function! s:IndentLinesDisable()
line 201: 
line 202: "{{{1 function! s:IndentLinesToggle()
line 203: function! s:IndentLinesToggle()
line 222: 
line 223: "{{{1 function! s:ResetWidth(...)
line 224: function! s:ResetWidth(...)
line 233: 
line 234: "{{{1 function! s:Filter()
line 235: function! s:Filter()
line 256: 
line 257: "{{{1 function! s:Disable()
line 258: function! s:Disable()
line 268: 
line 269: "{{{1 function! s:Setup()
line 270: function! s:Setup()
line 283: 
line 284: "{{{1 function! s:LeadingSpaceEnable()
line 285: function! s:LeadingSpaceEnable()
line 319: 
line 320: "{{{1 function! s:LeadingSpaceDisable()
line 321: function! s:LeadingSpaceDisable()
line 342: 
line 343: "{{{1 function! s:LeadingSpaceToggle()
line 344: function! s:LeadingSpaceToggle()
line 363: 
line 364: "{{{1 augroup indentLine
line 365: augroup indentLine
line 366:     autocmd!
line 367:     if g:indentLine_newVersion
line 368:         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
line 369:         if exists("##WinNew")
line 370:             autocmd WinNew * call <SID>Setup()
line 371:         endif
line 372:         autocmd BufWinEnter * call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()
line 373:         autocmd FileType * call <SID>Disable()
line 374:     else
line 375:         autocmd BufWinEnter * call <SID>Setup()
line 377:         autocmd User * if exists("b:indentLine_enabled") || exists("b:indentLine_leadingSpaceEnabled") | call <SID>Setup() | endif
line 378:         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call <SID>InitColor()
line 379:         autocmd BufUnload * let b:indentLine_enabled = 0 | let b:indentLine_leadingSpaceEnabled = 0
line 380:         autocmd SourcePre $VIMRUNTIME/syntax/nosyntax.vim doautocmd indentLine BufUnload
line 381:         autocmd FileChangedShellPost * doautocmd indentLine BufUnload | call <SID>Setup()
line 382:     endif
line 383: augroup END
line 384: 
line 385: "{{{1 commands
line 386: command! -nargs=? IndentLinesReset call <SID>ResetWidth(<f-args>)
line 387: command! IndentLinesToggle call <SID>IndentLinesToggle()
line 388: if g:indentLine_newVersion
line 389:     command! IndentLinesEnable let b:indentLine_enabled = 1 | call <SID>IndentLinesEnable()
line 390:     command! IndentLinesDisable let b:indentLine_enabled = 0 | call <SID>IndentLinesDisable()
line 391:     command! LeadingSpaceEnable let b:indentLine_leadingSpaceEnabled = 1 | call <SID>LeadingSpaceEnable()
line 392:     command! LeadingSpaceDisable let b:indentLine_leadingSpaceEnabled = 0 | call <SID>LeadingSpaceDisable()
line 393: else
line 394:     command! IndentLinesEnable call <SID>IndentLinesEnable()
line 395:     command! IndentLinesDisable call <SID>IndentLinesDisable()
line 396:     command! LeadingSpaceEnable call <SID>LeadingSpaceEnable()
line 397:     command! LeadingSpaceDisable call <SID>LeadingSpaceDisable()
line 398: endif
line 399: command! LeadingSpaceToggle call <SID>LeadingSpaceToggle()
line 400: 
line 401: " vim:et:ts=4:sw=4:fdm=marker:fmr={{{,}}}
line 402: 
finished sourcing /home/ringu/.vim/plugged/indentLine/after/plugin/indentLine.vim
Searching for "/home/ringu/.vim/after/plugin/**/*.vim"
Opening the X display took 0 msec
Reading viminfo file "/home/ringu/.viminfo" info oldfiles
Opening the X display took 1 msec
Executing BufWinEnter Autocommands for "*"
autocommand call lightline#update()

line 0: call lightline#update()
Searching for "autoload/lightline.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/11/24 12:00:00.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: let s:_ = 1 " 1: uninitialized, 2: disabled
line 12: 
line 13: function! lightline#update() abort
line 29: 
line 30: function! lightline#update_once() abort
line 35: 
line 36: function! lightline#update_disable() abort
line 42: 
line 43: function! lightline#enable() abort
line 59: 
line 60: function! lightline#disable() abort
line 77: 
line 78: function! lightline#toggle() abort
line 85: 
line 145: let s:_lightline = {   'active': {     'left': [['mode', 'paste'], ['readonly', 'filename', 'modified']],     'right': [['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']]   },   'inactive': {     'left': [['filename']],     'right': [['lineinfo'], ['percent']]   },   'tabline': {     'left': [['tabs']],     'right': [['close']]   },   'tab': {     'active': ['tabnum', 'filename', 'modified'],     'inactive': ['tabnum', 'filename', 'modified']   },   'component': {     'mode': '%{lightline#mode()}',     'absolutepath': '%F', 'relativepath': '%f', 'filename': '%t', 'modified': '%M', 'bufnum': '%n',     'paste': '%{&paste?"PASTE":""}', 'readonly': '%R', 'charvalue': '%b', 'charvaluehex': '%B',     'spell': '%{&spell?&spelllang:""}', 'fileencoding': '%{&fenc!=#""?&fenc:&enc}', 'fileformat': '%{&ff}',     'filetype': '%{&ft!=#""?&ft:"no ft"}', 'percent': '%3p%%', 'percentwin': '%P',     'lineinfo': '%3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X ', 'winnr': '%{winnr()}'   
line 146: function! lightline#init() abort
line 187: 
line 188: function! lightline#colorscheme() abort
line 211: 
line 212: function! lightline#palette() abort
line 215: 
line 216: function! lightline#mode() abort
line 219: 
line 220: let s:mode = ''
line 221: function! lightline#link(...) abort
line 246: 
line 247: function! s:term(p) abort
line 250: 
line 251: if exists('*uniq')
line 252:   let s:uniq = function('uniq')
line 253: else
line 254:   function! s:uniq(xs) abort
line 264: endif
line 265: 
line 266: function! lightline#highlight(...) abort
line 297: 
line 298: function! s:subseparator(components, subseparator, expanded) abort
line 305: 
line 306: function! lightline#concatenate(xs, right) abort
line 310: 
line 311: function! lightline#statusline(inactive) abort
line 317: 
line 318: function! s:normalize(result) abort
line 327: 
line 328: function! s:evaluate_expand(component) abort
line 339: 
line 340: function! s:convert(name, index) abort
line 350: 
line 351: function! s:flatten_twice(xss) abort
line 360: 
line 361: if v:version > 702 || v:version == 702 && has('patch295')
line 362:   let s:map = function('map')
line 363: else
line 364:   function! s:map(xs, f) abort
line 371: endif
line 372: 
line 373: function! s:expand(components) abort
line 404: 
line 405: function! s:line(tabline, inactive) abort
line 445: 
line 446: let s:tabnr = -1
line 447: let s:tabcnt = -1
line 448: let s:tabline = ''
line 449: function! lightline#tabline() abort
line 460: 
line 461: function! lightline#tabs() abort
line 482: 
line 483: function! lightline#onetab(n, active) abort
line 494: 
line 495: function! lightline#error(msg) abort
line 500: 
line 501: let &cpo = s:save_cpo
line 502: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline.vim
continuing in BufWinEnter Autocommands for "*"
calling function lightline#update()

line 1:   if s:_
line 2:     if s:_ == 2 | return | endif
line 2:  return | endif
line 2:  endif
line 3:     call lightline#init()
calling function lightline#update[3]..lightline#init()

line 1:   let s:lightline = deepcopy(get(g:, 'lightline', {}))
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 2:   for [key, value] in items(s:_lightline)
line 3:     if type(value) == 4
line 4:       if !has_key(s:lightline, key)
line 5:         let s:lightline[key] = {}
line 6:       endif
line 7:       call extend(s:lightline[key], value, 'keep')
line 8:     elseif !has_key(s:lightline, key)
line 9:       let s:lightline[key] = value
line 10:     endif
line 11:     unlet value
line 12:   endfor
line 13:   call extend(s:lightline.tabline_separator, s:lightline.separator, 'keep')
line 14:   call extend(s:lightline.tabline_subseparator, s:lightline.subseparator, 'keep')
line 15:   let s:lightline.tabline_configured = has_key(get(get(g:, 'lightline', {}), 'component_expand', {}), 'tabs')
line 16:   for components in deepcopy(s:lightline.tabline.left + s:lightline.tabline.right)
line 17:     if len(filter(components, 'v:val !=# "tabs" && v:val !=# "close"')) > 0
line 18:       let s:lightline.tabline_configured = 1
line 19:       break
line 20:     endif
line 21:   endfor
line 22:   if !exists('s:_statusline')
line 23:     let s:_statusline = &statusline
line 24:   endif
line 25:   if !exists('s:_tabline')
line 26:     let s:_tabline = &tabline
line 27:   endif
line 28:   if s:lightline.enable.tabline
line 29:     set tabline=%!lightline#tabline()
line 30:   else
line 31:     let &tabline = get(s:, '_tabline', '')
line 32:   endif
line 33:   for f in values(s:lightline.component_function)
line 34:     silent! call call(f, [])
calling function lightline#update[3]..lightline#init[34]..fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
function lightline#update[3]..lightline#init[34]..fugitive#head returning ''

continuing in function lightline#update[3]..lightline#init

line 35:   endfor
line 33:   for f in values(s:lightline.component_function)
line 34:     silent! call call(f, [])
line 35:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
Searching for "autoload/lightline/tab.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/tab.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 37: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/tab.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2016/05/07 22:31:02.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 11: function! lightline#tab#filename(n) abort
line 17: 
line 18: function! lightline#tab#modified(n) abort
line 22: 
line 23: function! lightline#tab#readonly(n) abort
line 27: 
line 28: function! lightline#tab#tabnum(n) abort
line 31: 
line 32: let &cpo = s:save_cpo
line 33: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/tab.vim
continuing in function lightline#update[3]..lightline#init
calling function lightline#update[3]..lightline#init[37]..lightline#tab#tabnum(1)

line 1:   return a:n
function lightline#update[3]..lightline#init[37]..lightline#tab#tabnum returning #1

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#filename(1)

line 1:   let buflist = tabpagebuflist(a:n)
line 2:   let winnr = tabpagewinnr(a:n)
line 3:   let _ = expand('#'.buflist[winnr - 1].':t')
line 4:   return _ !=# '' ? _ : '[No Name]'
function lightline#update[3]..lightline#init[37]..lightline#tab#filename returning '[No Name]'

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#readonly(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&readonly') ? 'RO' : ''
function lightline#update[3]..lightline#init[37]..lightline#tab#readonly returning ''

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
calling function lightline#update[3]..lightline#init[37]..lightline#tab#modified(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
function lightline#update[3]..lightline#init[37]..lightline#tab#modified returning ''

continuing in function lightline#update[3]..lightline#init

line 38:   endfor
line 36:   for f in values(s:lightline.tab_component_function)
line 37:     silent! call call(f, [1])
line 38:   endfor
line 39:   let s:mode = ''
function lightline#update[3]..lightline#init returning #0

continuing in function lightline#update

line 4:     call lightline#colorscheme()
calling function lightline#update[4]..lightline#colorscheme()

line 1:   try
line 2:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
Searching for "autoload/lightline/colorscheme/one.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/colorscheme/one.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme/one.vim
line 3: " Author: Zoltan Dalmadi
line 4: " License: MIT License
line 5: " Last Change: 2017/11/28 21:53:01.
line 6: " =============================================================================
line 7: 
line 8: " Common colors
line 9: let s:fg     = [ '#abb2bf', 145 ]
line 10: let s:blue   = [ '#61afef', 75 ]
line 11: let s:green  = [ '#98c379', 76 ]
line 12: let s:purple = [ '#c678dd', 176 ]
line 13: let s:red1   = [ '#e06c75', 168 ]
line 14: let s:red2   = [ '#be5046', 168 ]
line 15: let s:yellow = [ '#e5c07b', 180 ]
line 16: 
line 17: let s:p = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
line 18: 
line 19: if lightline#colorscheme#background() ==# 'light'
Searching for "autoload/lightline/colorscheme.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lightline/colorscheme.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
chdir(/home/ringu/.vim/plugged/lightline.vim/autoload/lightline)
fchdir() to previous dir
line 19: sourcing "/home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim"
line 1: " =============================================================================
line 2: " Filename: autoload/lightline/colorscheme.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2018/09/01 22:48:24.
line 6: " =============================================================================
line 7: 
line 8: let s:save_cpo = &cpo
line 9: set cpo&vim
line 10: 
line 59: let s:cuicolor = { 'black'          : 16, 'white'          : 231, 'darkestgreen'   : 22, 'darkgreen'      : 28, 'mediumgreen'    : 70, 'brightgreen'    : 148, 'darkestcyan'    : 23, 'mediumcyan'     : 117, 'darkestblue'    : 24, 'darkblue'       : 31, 'darkestred'     : 52, 'darkred'        : 88, 'mediumred'      : 124, 'brightred'      : 160, 'brightestred'   : 196, 'darkestpurple'  : 55, 'mediumpurple'   : 98, 'brightpurple'   : 189, 'brightorange'   : 208, 'brightestorange': 214, 'gray0'          : 233, 'gray1'          : 235, 'gray2'          : 236, 'gray3'          : 239, 'gray4'          : 240, 'gray5'          : 241, 'gray6'          : 244, 'gray7'          : 245, 'gray8'          : 247, 'gray9'          : 250, 'gray10'         : 252, 'yellow'         : 136, 'orange'         : 166, 'red'            : 160, 'magenta'        : 125, 'violet'         : 61, 'blue'           : 33, 'cyan'           : 37, 'green'          : 64, }
line 60: 
line 109: let s:guicolor = { 'black'          : '#000000', 'white'          : '#ffffff', 'darkestgreen'   : '#005f00', 'darkgreen'      : '#008700', 'mediumgreen'    : '#5faf00', 'brightgreen'    : '#afdf00', 'darkestcyan'    : '#005f5f', 'mediumcyan'     : '#87dfff', 'darkestblue'    : '#005f87', 'darkblue'       : '#0087af', 'darkestred'     : '#5f0000', 'darkred'        : '#870000', 'mediumred'      : '#af0000', 'brightred'      : '#df0000', 'brightestred'   : '#ff0000', 'darkestpurple'  : '#5f00af', 'mediumpurple'   : '#875fdf', 'brightpurple'   : '#dfdfff', 'brightorange'   : '#ff8700', 'brightestorange': '#ffaf00', 'gray0'          : '#121212', 'gray1'          : '#262626', 'gray2'          : '#303030', 'gray3'          : '#4e4e4e', 'gray4'          : '#585858', 'gray5'          : '#606060', 'gray6'          : '#808080', 'gray7'          : '#8a8a8a', 'gray8'          : '#9e9e9e', 'gray9'          : '#bcbcbc', 'gray10'         : '#d0d0d0', 'yellow'         : '#b58900', 'orange'         : '#cb4b16', 'red'
line 110: 
line 111: function! s:convert(rgb) abort
line 128: 
line 129: function! s:black(x) abort
line 141: 
line 142: function! s:nr(x) abort
line 145: 
line 146: function! s:rgb(r, g, b) abort
line 149: 
line 150: function! s:upconvert(nr) abort
line 182: 
line 183: function! lightline#colorscheme#fill(p) abort
line 208: 
line 209: function! lightline#colorscheme#flatten(p) abort
line 226: 
line 227: if has('gui_running') || (has('termguicolors') && &termguicolors)
line 228:   function! lightline#colorscheme#background() abort
line 231: else
line 232:   " &background is set inappropriately when the colorscheme sets ctermbg of the Normal group
line 233:   function! lightline#colorscheme#background() abort
line 254: endif
line 255: 
line 256: let &cpo = s:save_cpo
line 257: unlet s:save_cpo
finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme.vim
continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim
calling function lightline#colorscheme#background()

line 1:     let bg_color = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
line 2:     if bg_color !=# ''
line 3:       if bg_color < 16
line 4:         return &background
line 5:       elseif 232 <= bg_color && bg_color < 244
line 6:         return 'dark'
function lightline#colorscheme#background returning 'dark'

continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim

line 20:   " Light variant
line 21:   let s:bg     = [ '#fafafa', 255 ]
line 22:   let s:gray1  = [ '#494b53', 238 ]
line 23:   let s:gray2  = [ '#f0f0f0', 255 ]
line 24:   let s:gray3  = [ '#d0d0d0', 250 ]
line 25:   let s:green  = [ '#98c379', 35 ]
line 26: 
line 27:   let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:gray1, s:gray3 ] ]
line 28:   let s:p.normal.middle   = [ [ s:gray1, s:gray2 ] ]
line 29:   let s:p.inactive.left   = [ [ s:bg,  s:gray3 ], [ s:bg, s:gray3 ] ]
line 30:   let s:p.inactive.middle = [ [ s:gray3, s:gray2 ] ]
line 31:   let s:p.inactive.right  = [ [ s:bg, s:gray3 ], [ s:bg, s:gray3 ] ]
line 32:   let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:gray1, s:gray3 ] ]
line 33:   let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:gray1, s:gray3 ] ]
line 34:   let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:gray1, s:gray3 ] ]
line 35: else
line 36:   " Dark variant
line 37:   let s:bg     = [ '#282c34', 235 ]
line 38:   let s:gray1  = [ '#5c6370', 241 ]
line 39:   let s:gray2  = [ '#2c323d', 235 ]
line 40:   let s:gray3  = [ '#3e4452', 240 ]
line 41: 
line 42:   let s:p.normal.left     = [ [ s:bg, s:green, 'bold' ], [ s:fg, s:gray3 ] ]
line 43:   let s:p.normal.middle   = [ [ s:fg, s:gray2 ] ]
line 44:   let s:p.inactive.left   = [ [ s:gray1,  s:bg ], [ s:gray1, s:bg ] ]
line 45:   let s:p.inactive.middle = [ [ s:gray1, s:gray2 ] ]
line 46:   let s:p.inactive.right  = [ [ s:gray1, s:bg ], [ s:gray1, s:bg ] ]
line 47:   let s:p.insert.left     = [ [ s:bg, s:blue, 'bold' ], [ s:fg, s:gray3 ] ]
line 48:   let s:p.replace.left    = [ [ s:bg, s:red1, 'bold' ], [ s:fg, s:gray3 ] ]
line 49:   let s:p.visual.left     = [ [ s:bg, s:purple, 'bold' ], [ s:fg, s:gray3 ] ]
line 50: endif
line 51: 
line 52: " Common
line 53: let s:p.normal.right   = [ [ s:bg, s:green, 'bold' ], [ s:bg, s:green, 'bold' ] ]
line 54: let s:p.normal.error   = [ [ s:red2,   s:bg ] ]
line 55: let s:p.normal.warning = [ [ s:yellow, s:bg ] ]
line 56: let s:p.insert.right   = [ [ s:bg, s:blue, 'bold' ], [ s:bg, s:blue, 'bold' ] ]
line 57: let s:p.replace.right  = [ [ s:bg, s:red1, 'bold' ], [ s:bg, s:red1, 'bold' ] ]
line 58: let s:p.visual.right   = [ [ s:bg, s:purple, 'bold' ], [ s:bg, s:purple, 'bold' ] ]
line 59: let s:p.tabline.left   = [ [ s:bg, s:gray3 ] ]
line 60: let s:p.tabline.tabsel = [ [ s:bg, s:purple, 'bold' ] ]
line 61: let s:p.tabline.middle = [ [ s:gray3, s:gray2 ] ]
line 62: let s:p.tabline.right  = copy(s:p.normal.right)
line 63: 
line 64: let g:lightline#colorscheme#one#palette = lightline#colorscheme#flatten(s:p)
calling function lightline#colorscheme#flatten({'inactive': {'right': [[['#5c6370', 2...[['#abb2bf', 145], ['#3e4452', 240]]]}})

line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 1:   for k in values(a:p)
line 2:     for l in values(k)
line 3:       for m in range(len(l))
line 4:         let attr = ''
line 5:         if len(l[m]) == 3 && type(l[m][2]) == 1
line 6:           let attr = l[m][2]
line 7:         endif
line 8:         let l[m] = [l[m][0][0], l[m][1][0], l[m][0][1], l[m][1][1]]
line 9:         if !empty(attr)
line 10:           call add(l[m], attr)
line 11:         endif
line 12:       endfor
line 13:     endfor
line 14:   endfor
line 15:   return a:p
function lightline#colorscheme#flatten returning {'inactive': {'right': [['#5c6370', '#...'], ['#abb2bf', '#3e4452', 145, 240]]}}

continuing in /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim

finished sourcing /home/ringu/.vim/plugged/lightline.vim/autoload/lightline/colorscheme/one.vim
continuing in function lightline#update[4]..lightline#colorscheme
line 3:   catch
line 4:     call lightline#error('Could not load colorscheme ' . s:lightline.colorscheme . '.')
line 5:     let s:lightline.colorscheme = 'default'
line 6:     let s:lightline.palette = g:lightline#colorscheme#{s:lightline.colorscheme}#palette
line 7:   finally
line 8:     if has('win32') && !has('gui_running') && &t_Co < 256
line 9:       for u in values(s:lightline.palette)
line 10:         for v in values(u)
line 11:           for _  in v
line 12:             let [_[2], _[3]] = [lightline#colortable#gui2cui(_[0], _[2]), lightline#colortable#gui2cui(_[1], _[3])]
line 13:           endfor
line 14:         endfor
line 15:       endfor
line 16:     endif
line 17:     let s:highlight = {}
line 18:     call lightline#highlight('normal')
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight('normal')

line 1:   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
line 2:   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
line 3:   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
line 4:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 5:   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_1 guifg=#98c379 guibg=#3e4452 ctermfg=76 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#abb2bf', '#3e4452', 145, 240])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_1 guifg=#abb2bf guibg=#3e4452 ctermfg=145 ctermbg=240 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_2 guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_1_tabsel guifg=#3e4452 guibg=#c678dd ctermfg=240 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineLeft_normal_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_1 guifg=#c678dd guibg=#3e4452 ctermfg=176 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_2 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_normal_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_1 guifg=#98c379 guibg=#98c379 ctermfg=76 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_1 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_2 guifg=#98c379 guibg=#2c323d ctermfg=76 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_1_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#abb2bf', '#2c323d', 145, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_2 guifg=#abb2bf guibg=#2c323d ctermfg=145 ctermbg=235 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_3 guifg=#2c323d guibg=#2c323d ctermfg=235 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_2_tabsel guifg=#2c323d guibg=#c678dd ctermfg=235 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 18: hi LightlineRight_normal_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_1 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_2 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_3 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_normal_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
calling function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[28]..<SNR>66_term(['#abb2bf', '#2c323d', 145, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight[28]..<SNR>66_term returning ''

continuing in function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight

line 28: hi LightlineMiddle_normal guifg=#abb2bf guibg=#2c323d ctermfg=145 ctermbg=235 
line 29:   endfor
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
line 29:   endfor
function lightline#update[4]..lightline#colorscheme[18]..lightline#highlight returning #0

continuing in function lightline#update[4]..lightline#colorscheme

line 19:     call lightline#link()
calling function lightline#update[4]..lightline#colorscheme[19]..lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
line 4:   endif
line 5:   let s:mode = mode
line 6:   if !has_key(s:highlight, mode)
line 7:     call lightline#highlight(mode)
line 8:   endif
line 9:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_0 LightlineLeft_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_1 LightlineLeft_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_0_tabsel LightlineLeft_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_1 LightlineLeft_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_2 LightlineLeft_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_1_tabsel LightlineLeft_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineLeft_active_tabsel LightlineLeft_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_0 LightlineLeft_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_1 LightlineLeft_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_2 LightlineLeft_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineLeft_active_tabsel_tabsel LightlineLeft_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_0 LightlineRight_normal_0
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_1 LightlineRight_normal_0_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_0_tabsel LightlineRight_normal_0_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_1 LightlineRight_normal_1
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_2 LightlineRight_normal_1_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_1_tabsel LightlineRight_normal_1_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_2 LightlineRight_normal_2
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_3 LightlineRight_normal_2_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_2_tabsel LightlineRight_normal_2_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 13: hi link LightlineRight_active_tabsel LightlineRight_normal_tabsel
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_0 LightlineRight_normal_tabsel_0
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_1 LightlineRight_normal_tabsel_1
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_2 LightlineRight_normal_tabsel_2
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_3 LightlineRight_normal_tabsel_3
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 17: hi link LightlineRight_active_tabsel_tabsel LightlineRight_normal_tabsel_tabsel
line 18:         endif
line 19:       endfor
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 10:   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
line 11:     for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 12:       if i != l
line 13:         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
line 14:       endif
line 15:       for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i + 1 == j || t || s && i != l
line 17:           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
line 18:         endif
line 19:       endfor
line 20:     endfor
line 21:   endfor
line 22:   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
line 22: hi link LightlineMiddle_active LightlineMiddle_normal
line 23:   return ''
function lightline#update[4]..lightline#colorscheme[19]..lightline#link returning ''

continuing in function lightline#update[4]..lightline#colorscheme

line 20:     let s:_ = 0
line 21:   endtry
function lightline#update[4]..lightline#colorscheme returning #0

continuing in function lightline#update

line 5:   endif
line 6:   if !s:lightline.enable.statusline
line 7:     return
line 8:   endif
line 9:   let w = winnr()
line 10:   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
calling function lightline#update[10]..lightline#statusline(0)

line 1:   if a:inactive && !has_key(s:highlight, 'inactive')
line 2:     call lightline#highlight('inactive')
line 3:   endif
line 4:   return s:line(0, a:inactive)
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line(0, 0)

line 1:   let _ = a:tabline ? '' : '%{lightline#link()}'
line 2:   if s:lightline.palette == {}
line 3:     call lightline#colorscheme()
line 4:   endif
line 5:   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
line 6:   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
line 7:   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
line 8:   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
line 9:   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
line 10:   let [lt, lc, ll] = s:expand(copy(l_))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand([['mode', 'paste'], ['gitbranch', 'readonly']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('mode', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['mode'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('paste', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['paste'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('gitbranch', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['gitbranch'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('readonly', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['readonly'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['mode'], 0, '0', '0']], [[['paste... '1']], [[['readonly'], 0, '1', '1']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['mode'], 0, '0', '0'], [['paste'], ...'1', '1'], [['readonly'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[10]..<SNR>66_expand returning [[['mode', 'paste'], ['gitbranch', 're...']], [[0, 0], [0, 0]], ['0', '1', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 11:   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
line 12:   let [rt, rc, rl] = s:expand(copy(r_))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand([['lineinfo'], ['percent'], ['fileformat', 'fileencoding', 'filetype']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('lineinfo', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['lineinfo'], 0, '0', '0']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('percent', '1')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['percent'], 0, '1', '1']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('fileformat', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['fileformat'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('fileencoding', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['fileencoding'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('filetype', '2')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['filetype'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['lineinfo'], 0, '0', '0']]], [[[[... '2']], [[['filetype'], 0, '2', '2']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['lineinfo'], 0, '0', '0'], [['perce...'2', '2'], [['filetype'], 0, '2', '2']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[12]..<SNR>66_expand returning [[['lineinfo'], ['percent'], ['filefor... [0], [0, 0, 0]], ['0', '1', '2', '3']]

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator(['mode', 'paste'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator returning '%{(&paste)?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator(['gitbranch', 'readonly'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[19]..<SNR>66_subseparator returning '%{fugitive#head()!=#""&&((&readonly))?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 25:   let _ .= '%#LightlineMiddle_' . mode . '#%='
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator(['fileformat', 'fileencoding', 'filetype'], '', [0, 0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator returning '%{1||1?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
calling function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator(['fileencoding', 'filetype'], '', [0, 0])

line 1:   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
line 2:   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
line 5:   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line[34]..<SNR>66_subseparator returning '%{1?"":""}'

continuing in function lightline#update[10]..lightline#statusline[4]..<SNR>66_line

line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 38:   return _
function lightline#update[10]..lightline#statusline[4]..<SNR>66_line returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2v %)'

continuing in function lightline#update[10]..lightline#statusline

function lightline#update[10]..lightline#statusline returning '%{lightline#link()}%#LightlineLeft_ac...LightlineRight_active_0#%( %3l:%-2v %)'

continuing in function lightline#update

line 11:   for n in range(1, winnr('$'))
line 12:     call setwinvar(n, '&statusline', s[n!=w])
line 13:     call setwinvar(n, 'lightline', n!=w)
line 14:   endfor
line 11:   for n in range(1, winnr('$'))
line 12:     call setwinvar(n, '&statusline', s[n!=w])
line 13:     call setwinvar(n, 'lightline', n!=w)
line 14:   endfor
function lightline#update returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand call ale#events#LintOnEnter(str2nr(expand('<abuf>')))

line 0: call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
calling function ale#events#LintOnEnter(1)

line 1:     " Unmark a file as being changed outside of Vim after we try to check it.
line 2:     call setbufvar(a:buffer, 'ale_file_changed', 0)
line 3: 
line 4:     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
Searching for "autoload/ale.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/ale.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/ale.vim"
chdir(/home/ringu/.vim/plugged/ale/autoload)
fchdir() to previous dir
line 4: sourcing "/home/ringu/.vim/plugged/ale/autoload/ale.vim"
line 1: " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
line 2: " Description: Primary code path for the plugin
line 3: "   Manages execution of linters when requested by autocommands
line 4: 
line 5: " Strings used for severity in the echoed message
line 6: let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
line 7: let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
line 8: let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
line 9: " Ignoring linters, for disabling some, or ignoring LSP diagnostics.
line 10: let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
line 11: 
line 12: let s:lint_timer = -1
line 13: let s:getcmdwintype_exists = exists('*getcmdwintype')
line 14: 
line 15: " Return 1 if a file is too large for ALE to handle.
line 16: function! ale#FileTooLarge(buffer) abort
line 21: 
line 22: " A function for checking various conditions whereby ALE just shouldn't
line 23: " attempt to do anything, say if particular buffer types are open in Vim.
line 24: function! ale#ShouldDoNothing(buffer) abort
line 85: 
line 86: function! s:Lint(buffer, should_lint_file, timer_id) abort
line 113: 
line 114: " (delay, [linting_flag, buffer_number])
line 115: function! ale#Queue(delay, ...) abort
line 151: 
line 152: let g:ale_has_override = get(g:, 'ale_has_override', {})
line 153: 
line 154: " Call has(), but check a global Dictionary so we can force flags on or off
line 155: " for testing purposes.
line 156: function! ale#Has(feature) abort
line 159: 
line 160: " Given a buffer number and a variable name, look for that variable in the
line 161: " buffer scope, then in global scope. If the name does not exist in the global
line 162: " scope, an exception will be thrown.
line 163: "
line 164: " Every variable name will be prefixed with 'ale_'.
line 165: function! ale#Var(buffer, variable_name) abort
line 171: 
line 172: " As above, but curry the arguments so only the buffer number is required.
line 173: function! ale#VarFunc(variable_name) abort
line 176: 
line 177: " Initialize a variable with a default value, if it isn't already set.
line 178: "
line 179: " Every variable name will be prefixed with 'ale_'.
line 180: function! ale#Set(variable_name, default) abort
line 187: 
line 188: " Given a string for adding to a command, return the string padded with a
line 189: " space on the left if it is not empty. Otherwise return an empty string.
line 190: "
line 191: " This can be used for making command strings cleaner and easier to test.
line 192: function! ale#Pad(string) abort
line 195: 
line 196: " Given a environment variable name and a value, produce part of a command for
line 197: " setting an environment variable before running a command. The syntax will be
line 198: " valid for cmd on Windows, or most shells on Unix.
line 199: function! ale#Env(variable_name, value) abort
line 206: 
line 207: " Escape a string suitably for each platform.
line 208: " shellescape does not work on Windows.
line 209: function! ale#Escape(str) abort
line 225: 
line 226: " Get the loclist item message according to a given format string.
line 227: "
line 228: " See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
line 229: function! ale#GetLocItemMessage(item, format_string) abort
finished sourcing /home/ringu/.vim/plugged/ale/autoload/ale.vim
continuing in function ale#events#LintOnEnter
calling function ale#events#LintOnEnter[4]..ale#Var(1, 'enabled')

line 1:     let l:full_name = 'ale_' . a:variable_name
line 2:     let l:vars = getbufvar(str2nr(a:buffer), '', {})
line 3: 
line 4:     return get(l:vars, l:full_name, g:[l:full_name])
function ale#events#LintOnEnter[4]..ale#Var returning #1

continuing in function ale#events#LintOnEnter

line 5:         call ale#Queue(0, 'lint_file', a:buffer)
calling function ale#events#LintOnEnter[5]..ale#Queue(0, 'lint_file', 1)

line 1:     if a:0 > 2
line 2:         throw 'too many arguments!'
line 3:     endif
line 4: 
line 5:     let l:buffer = get(a:000, 1, v:null)
line 6: 
line 7:     if l:buffer is v:null
line 8:         let l:buffer = bufnr('')
line 9:     endif
line 10: 
line 11:     if type(l:buffer) isnot v:t_number
line 12:         throw 'buffer_number must be a Number'
line 13:     endif
line 14: 
line 15:     if ale#ShouldDoNothing(l:buffer)
calling function ale#events#LintOnEnter[5]..ale#Queue[15]..ale#ShouldDoNothing(1)

line 1:     " The checks are split into separate if statements to make it possible to
line 2:     " profile each check individually with Vim's profiling tools.
line 3:     "
line 4:     " Do nothing if ALE is disabled.
line 5:     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
line 6:         return 1
line 7:     endif
line 8: 
line 9:     " Don't perform any checks when newer NeoVim versions are exiting.
line 10:     if get(v:, 'exiting', v:null) isnot v:null
line 11:         return 1
line 12:     endif
line 13: 
line 14:     let l:filetype = getbufvar(a:buffer, '&filetype')
line 15: 
line 16:     " Do nothing when there's no filetype.
line 17:     if l:filetype is# ''
line 18:         return 1
function ale#events#LintOnEnter[5]..ale#Queue[15]..ale#ShouldDoNothing returning #1

continuing in function ale#events#LintOnEnter[5]..ale#Queue

line 16:         return
function ale#events#LintOnEnter[5]..ale#Queue returning #0

continuing in function ale#events#LintOnEnter

line 6:     endif
function ale#events#LintOnEnter returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufWinEnter Autocommands for "*"
autocommand let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())

line 0: let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
Executing BufWinEnter Autocommands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |   call s:diffoff() | endif
calling function <SNR>45_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>45_can_diffoff returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:    call s:diffoff() | endif
line 0:  endif
Executing BufWinEnter Autocommands for "*"
autocommand call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()

line 0: call <SID>IndentLinesDisable() | call <SID>LeadingSpaceDisable() | call <SID>Setup()
calling function <SNR>65_IndentLinesDisable()

line 1:     if g:indentLine_newVersion
line 2:         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
line 3:             for id in w:indentLine_indentLineId
line 4:                 try
line 5:                     call matchdelete(id)
line 6:                 catch /^Vim\%((\a\+)\)\=:E80[23]/
line 7:                 endtry
line 8:             endfor
line 9:             let w:indentLine_indentLineId = []
line 10:         endif
line 11: 
line 12:         call s:ResetConcealOption()
calling function <SNR>65_IndentLinesDisable[12]..<SNR>65_ResetConcealOption()

line 1:     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
line 2:         if exists("b:indentLine_original_concealcursor")
line 3:             let &l:concealcursor = b:indentLine_original_concealcursor
line 4:         endif
line 5:         if exists("b:indentLine_original_conceallevel")
line 6:             let &l:conceallevel = b:indentLine_original_conceallevel
line 7:         endif
line 8:         let b:indentLine_ConcealOptionSet = 0
line 9:     endif
function <SNR>65_IndentLinesDisable[12]..<SNR>65_ResetConcealOption returning #0

continuing in function <SNR>65_IndentLinesDisable

line 13:         return
function <SNR>65_IndentLinesDisable returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:  call <SID>LeadingSpaceDisable() | call <SID>Setup()
calling function <SNR>65_LeadingSpaceDisable()

line 1:     if g:indentLine_newVersion
line 2:         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
line 3:             for id in w:indentLine_leadingSpaceId
line 4:                 try
line 5:                     call matchdelete(id)
line 6:                 catch /^Vim\%((\a\+)\)\=:E80[23]/
line 7:                 endtry
line 8:             endfor
line 9:             let w:indentLine_leadingSpaceId = []
line 10:         endif
line 11: 
line 12:         return
function <SNR>65_LeadingSpaceDisable returning #0

continuing in BufWinEnter Autocommands for "*"

line 0:  call <SID>Setup()
calling function <SNR>65_Setup()

line 1:     if &filetype ==# ""
line 2:         call s:InitColor()
calling function <SNR>65_Setup[2]..<SNR>65_InitColor()

line 1:     if !g:indentLine_setColors
line 2:         return
line 3:     endif
line 4: 
line 5:     let default_term_bg = "NONE"
line 6:     let default_gui_bg  = "NONE"
line 7:     if &background ==# "light"
line 8:         let default_term_fg = 249
line 9:         let default_gui_fg = "Grey70"
line 10:     else
line 11:         let default_term_fg = 239
line 12:         let default_gui_fg = "Grey30"
line 13:     endif
line 14: 
line 15:     if g:indentLine_defaultGroup != ""
line 16:         let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
line 17:         let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
line 18:         let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
line 19:         let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
line 20:         let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
line 21:     endif
line 22: 
line 23:     if !exists("g:indentLine_color_term")
line 24:         let term_color = default_term_fg
line 25:     else
line 26:         let term_color = g:indentLine_color_term
line 27:     endif
line 28: 
line 29:     if !exists("g:indentLine_bgcolor_term")
line 30:         let term_bgcolor = default_term_bg
line 31:     else
line 32:         let term_bgcolor = g:indentLine_bgcolor_term
line 33:     endif
line 34: 
line 35:     if !exists("g:indentLine_color_gui")
line 36:         let gui_color = default_gui_fg
line 37:     else
line 38:         let gui_color = g:indentLine_color_gui
line 39:     endif
line 40: 
line 41:     if !exists("g:indentLine_bgcolor_gui")
line 42:         let gui_bgcolor = default_gui_bg
line 43:     else
line 44:         let gui_bgcolor = g:indentLine_bgcolor_gui
line 45:     endif
line 46: 
line 47:     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
line 47: highlight Conceal cterm=NONE ctermfg=239 ctermbg=NONE
line 48:     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
line 48: highlight Conceal gui=NONE guifg=#504945 guibg=NONE
line 49: 
line 50:     if &term ==# "linux"
line 51:         if &background ==# "light"
line 52:             let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
line 53:         else
line 54:             let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
line 55:         endif
line 56:         execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
line 57:     endif
function <SNR>65_Setup[2]..<SNR>65_InitColor returning #0

continuing in function <SNR>65_Setup

line 3:     endif
line 4: 
line 5:     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
calling function <SNR>65_Setup[5]..<SNR>65_Filter()

line 1:     if index(g:indentLine_fileTypeExclude, &filetype) != -1
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if index(g:indentLine_bufTypeExclude, &buftype) != -1
line 6:         return 0
line 7:     endif
line 8: 
line 9:     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
line 10:         return 0
line 11:     endif
line 12: 
line 13:     for name in g:indentLine_bufNameExclude
line 14:         if matchstr(bufname(''), name) == bufname('')
line 15:             return 0
line 16:         endif
line 17:     endfor
line 18: 
line 19:     return 1
function <SNR>65_Setup[5]..<SNR>65_Filter returning #1

continuing in function <SNR>65_Setup

line 6:         call s:IndentLinesEnable()
calling function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable()

line 1:     if g:indentLine_newVersion
line 2:         if &diff
line 3:             return
line 4:         endif
line 5: 
line 6:         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
line 7:             return
line 8:         endif
line 9: 
line 10:         if !exists("w:indentLine_indentLineId")
line 11:             let w:indentLine_indentLineId = []
line 12:         endif
line 13: 
line 14:         call s:SetConcealOption()
calling function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable[14]..<SNR>65_SetConcealOption()

line 1:     if !g:indentLine_setConceal
line 2:         return
line 3:     endif
line 4:     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
line 5:         let b:indentLine_ConcealOptionSet = 1
line 6:         let b:indentLine_original_concealcursor = &l:concealcursor
line 7:         let b:indentLine_original_conceallevel = &l:conceallevel
line 8:         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
line 9:         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
line 10:     endif
function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable[14]..<SNR>65_SetConcealOption returning #0

continuing in function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable

line 15: 
line 16:         if g:indentLine_showFirstIndentLevel
line 17:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
line 18:         endif
line 19: 
line 20:         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 21:         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
line 22:             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
line 23:         endfor
line 24: 
line 25:         return
function <SNR>65_Setup[6]..<SNR>65_IndentLinesEnable returning #0

continuing in function <SNR>65_Setup

line 7:     endif
line 8: 
line 9:     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
calling function <SNR>65_Setup[9]..<SNR>65_Filter()

line 1:     if index(g:indentLine_fileTypeExclude, &filetype) != -1
line 2:         return 0
line 3:     endif
line 4: 
line 5:     if index(g:indentLine_bufTypeExclude, &buftype) != -1
line 6:         return 0
line 7:     endif
line 8: 
line 9:     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
line 10:         return 0
line 11:     endif
line 12: 
line 13:     for name in g:indentLine_bufNameExclude
line 14:         if matchstr(bufname(''), name) == bufname('')
line 15:             return 0
line 16:         endif
line 17:     endfor
line 18: 
line 19:     return 1
function <SNR>65_Setup[9]..<SNR>65_Filter returning #1

continuing in function <SNR>65_Setup

line 10:         call s:LeadingSpaceEnable()
line 11:     endif
function <SNR>65_Setup returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand :call AutoPairsTryInit()

line 0: :call AutoPairsTryInit()
calling function AutoPairsTryInit()

line 1:   if exists('b:autopairs_loaded')
line 2:     return
line 3:   end
line 4: 
line 5:   " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
line 6:   "
line 7:   " vim-endwise doesn't support <Plug>AutoPairsReturn
line 8:   " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
line 9:   "
line 10:   " supertab doesn't support <SID>AutoPairsReturn
line 11:   " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
line 12:   "
line 13:   " and when load after vim-endwise will cause unexpected endwise inserted.
line 14:   " so always load AutoPairs at last
line 15: 
line 16:   " Buffer level keys mapping
line 17:   " comptible with other plugin
line 18:   if g:AutoPairsMapCR
line 19:     if v:version == 703 && has('patch32') || v:version > 703
line 20:       " VIM 7.3 supports advancer maparg which could get <expr> info
line 21:       " then auto-pairs could remap <CR> in any case.
line 22:       let info = maparg('<CR>', 'i', 0, 1)
line 23:       if empty(info)
line 24:         let old_cr = '<CR>'
line 25:         let is_expr = 0
line 26:       else
line 27:         let old_cr = info['rhs']
line 28:         let old_cr = s:ExpandMap(old_cr)
line 29:         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
line 30:         let is_expr = info['expr']
line 31:         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
line 32:       endif
line 33:     else
line 34:       " VIM version less than 7.3
line 35:       " the mapping's <expr> info is lost, so guess it is expr or not, it's
line 36:       " not accurate.
line 37:       let old_cr = maparg('<CR>', 'i')
line 38:       if old_cr == ''
line 39:         let old_cr = '<CR>'
line 40:         let is_expr = 0
line 41:       else
line 42:         let old_cr = s:ExpandMap(old_cr)
line 43:         " old_cr contain (, I guess the old cr is in expr mode
line 44:         let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
line 45: 
line 46:         " The old_cr start with " it must be in expr mode
line 47:         let is_expr = is_expr || old_cr =~ '\v^"'
line 48:         let wrapper_name = '<SID>AutoPairsOldCRWrapper'
line 49:       end
line 50:     end
line 51: 
line 52:     if old_cr !~ 'AutoPairsReturn'
line 53:       if is_expr
line 54:         " remap <expr> to `name` to avoid mix expr and non-expr mode
line 55:         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
line 56:         let old_cr = wrapper_name
line 57:       end
line 58:       " Always silent mapping
line 59:       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
line 59: inoremap <script> <buffer> <silent> <CR> <CR><SID>AutoPairsReturn
line 60:     end
line 61:   endif
line 62:   call AutoPairsInit()
calling function AutoPairsTryInit[62]..AutoPairsInit()

line 1:   let b:autopairs_loaded  = 1
line 2:   if !exists('b:autopairs_enabled')
line 3:     let b:autopairs_enabled = 1
line 4:   end
line 5:   let b:AutoPairsClosedPairs = {}
line 6: 
line 7:   if !exists('b:AutoPairs')
line 8:     let b:AutoPairs = g:AutoPairs
line 9:   end
line 10: 
line 11:   if !exists('b:AutoPairsMoveCharacter')
line 12:     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
line 13:   end
line 14: 
line 15:   " buffer level map pairs keys
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('`')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ` <C-R>=AutoPairsInsert('`')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('"')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> " <C-R>=AutoPairsInsert('"')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('{')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> { <C-R>=AutoPairsInsert('{')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap('}')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> } <C-R>=AutoPairsInsert('}')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('''')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ' <C-R>=AutoPairsInsert('''')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('(')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ( <C-R>=AutoPairsInsert('(')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap(')')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ) <C-R>=AutoPairsInsert(')')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap('[')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> [ <C-R>=AutoPairsInsert('[')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[17]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 18:     if open != close
line 19:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap(']')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ] <C-R>=AutoPairsInsert(']')<CR>
line 9: 
function AutoPairsTryInit[62]..AutoPairsInit[19]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 16:   for [open, close] in items(b:AutoPairs)
line 17:     call AutoPairsMap(open)
line 18:     if open != close
line 19:       call AutoPairsMap(close)
line 20:     end
line 21:     let b:AutoPairsClosedPairs[close] = open
line 22:   endfor
line 23: 
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-(> <C-R>=AutoPairsMoveCharacter('(')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-)> <C-R>=AutoPairsMoveCharacter(')')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-[> <C-R>=AutoPairsMoveCharacter('[')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-]> <C-R>=AutoPairsMoveCharacter(']')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-{> <C-R>=AutoPairsMoveCharacter('{')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-}> <C-R>=AutoPairsMoveCharacter('}')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-"> <C-R>=AutoPairsMoveCharacter('"')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 26: inoremap <silent> <buffer> <M-'> <C-R>=AutoPairsMoveCharacter('''')<CR>
line 27:   endfor
line 24:   for key in split(b:AutoPairsMoveCharacter, '\s*')
line 25:     let escaped_key = substitute(key, "'", "''", 'g')
line 26:     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
line 27:   endfor
line 28: 
line 29:   " Still use <buffer> level mapping for <BS> <SPACE>
line 30:   if g:AutoPairsMapBS
line 31:     " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
line 32:     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
line 32: inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>
line 33:   end
line 34: 
line 35:   if g:AutoPairsMapCh
line 36:     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
line 36: inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>
line 37:   endif
line 38: 
line 39:   if g:AutoPairsMapSpace
line 40:     " Try to respect abbreviations on a <SPACE>
line 41:     let do_abbrev = ""
line 42:     if v:version == 703 && has("patch489") || v:version > 703
line 43:       let do_abbrev = "<C-]>"
line 44:     endif
line 45:     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
line 45: inoremap <buffer> <silent> <SPACE> <C-]><C-R>=AutoPairsSpace()<CR>
line 46:   end
line 47: 
line 48:   if g:AutoPairsShortcutFastWrap != ''
line 49:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
line 49: inoremap <buffer> <silent> <M-e> <C-R>=AutoPairsFastWrap()<CR>
line 50:   end
line 51: 
line 52:   if g:AutoPairsShortcutBackInsert != ''
line 53:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
line 53: inoremap <buffer> <silent> <M-b> <C-R>=AutoPairsBackInsert()<CR>
line 54:   end
line 55: 
line 56:   if g:AutoPairsShortcutToggle != ''
line 57:     " use <expr> to ensure showing the status when toggle
line 58:     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
line 58: inoremap <buffer> <silent> <expr> <M-p> AutoPairsToggle()
line 59:     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
line 59: noremap <buffer> <silent> <M-p> :call AutoPairsToggle()<CR>
line 60:   end
line 61: 
line 62:   if g:AutoPairsShortcutJump != ''
line 63:     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
line 63: inoremap <buffer> <silent> <M-n> <ESC>:call AutoPairsJump()<CR>a
line 64:     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
line 64: noremap <buffer> <silent> <M-n> :call AutoPairsJump()<CR>
line 65:   end
line 66: 
function AutoPairsTryInit[62]..AutoPairsInit returning #0

continuing in function AutoPairsTryInit

function AutoPairsTryInit returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))

line 0: call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
calling function ale#events#ReadOrEnterEvent(1)

line 1:     " Apply pattern options if the variable is set.
line 2:     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
line 4:         call ale#pattern_options#SetOptions(a:buffer)
line 5:     endif
line 6: 
line 7:     " When entering a buffer, we are no longer quitting it.
line 8:     call setbufvar(a:buffer, 'ale_quitting', 0)
line 9:     let l:filetype = getbufvar(a:buffer, '&filetype')
line 10:     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
line 11: 
line 12:     " If the file changed outside of Vim, check it on BufEnter,BufRead
line 13:     if getbufvar(a:buffer, 'ale_file_changed')
line 14:         call ale#events#LintOnEnter(a:buffer)
line 15:     endif
function ale#events#ReadOrEnterEvent returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand call s:on_bufenter()

line 0: call s:on_bufenter()
calling function <SNR>46_on_bufenter()

line 1:   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
line 2:     let t:gitgutter_didtabenter = 0
line 3:     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
line 4:   else
line 5:     call gitgutter#init_buffer(bufnr(''))
Searching for "autoload/gitgutter.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/gitgutter.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim"
chdir(/home/ringu/.vim/plugged/vim-gitgutter/autoload)
fchdir() to previous dir
line 5: sourcing "/home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim"
line 1: let s:t_string = type('')
line 2: 
line 3: " Primary functions {{{
line 4: 
line 5: function! gitgutter#all(force) abort
line 22: 
line 23: 
line 24: " Finds the file's path relative to the repo root.
line 25: function! gitgutter#init_buffer(bufnr)
line 34: 
line 35: 
line 36: function! gitgutter#process_buffer(bufnr, force) abort
line 59: 
line 60: 
line 61: function! gitgutter#disable() abort
line 74: 
line 75: function! gitgutter#enable() abort
line 79: 
line 80: function! gitgutter#toggle() abort
line 87: 
line 88: 
line 89: function! gitgutter#buffer_disable() abort
line 94: 
line 95: function! gitgutter#buffer_enable() abort
line 100: 
line 101: function! gitgutter#buffer_toggle() abort
line 108: 
line 109: " }}}
line 110: 
line 111: function! s:setup_maps()
line 146: 
line 147: function! s:has_fresh_changes(bufnr) abort
line 150: 
line 151: function! s:reset_tick(bufnr) abort
line 154: 
line 155: function! s:clear(bufnr)
finished sourcing /home/ringu/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim
continuing in function <SNR>46_on_bufenter
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer(1)

line 1:   if gitgutter#utility#is_active(a:bufnr)
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active(1)

line 1:   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar(1, 'enabled', 1)

line 1:   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
line 2:   if has_key(dict, a:varname)
line 3:     return dict[a:varname]
line 4:   else
line 5:     if a:0
line 6:       return a:1
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar returning #1

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer(1)

line 1:   return empty(getbufvar(a:bufnr, '&buftype'))
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer returning #1

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file(1)

line 1:   return filereadable(s:abs_path(a:bufnr, 0))
calling function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path(1, 0)

line 1:   let p = resolve(expand('#'.a:bufnr.':p'))
line 2:   return a:shellesc ? gitgutter#utility#shellescape(p) : p
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path returning ''

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file

function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active[1]..<SNR>47_exists_file returning #0

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active

function <SNR>46_on_bufenter[5]..gitgutter#init_buffer[1]..gitgutter#utility#is_active returning #0

continuing in function <SNR>46_on_bufenter[5]..gitgutter#init_buffer

line 2:     let p = gitgutter#utility#repo_path(a:bufnr, 0)
line 3:     if type(p) != s:t_string || empty(p)
line 4:       call gitgutter#utility#set_repo_path(a:bufnr)
line 5:       call s:setup_maps()
line 6:     endif
line 7:   endif
function <SNR>46_on_bufenter[5]..gitgutter#init_buffer returning #0

continuing in function <SNR>46_on_bufenter

line 6:     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer(1, 0)

line 1:   " NOTE a:bufnr is not necessarily the current buffer.
line 2: 
line 3:   if gitgutter#utility#is_active(a:bufnr)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active(1)

line 1:   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar(1, 'enabled', 1)

line 1:   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
line 2:   if has_key(dict, a:varname)
line 3:     return dict[a:varname]
line 4:   else
line 5:     if a:0
line 6:       return a:1
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..gitgutter#utility#getbufvar returning #1

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer(1)

line 1:   return empty(getbufvar(a:bufnr, '&buftype'))
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_is_file_buffer returning #1

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file(1)

line 1:   return filereadable(s:abs_path(a:bufnr, 0))
calling function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path(1, 0)

line 1:   let p = resolve(expand('#'.a:bufnr.':p'))
line 2:   return a:shellesc ? gitgutter#utility#shellescape(p) : p
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file[1]..<SNR>47_abs_path returning ''

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file

function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active[1]..<SNR>47_exists_file returning #0

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active

function <SNR>46_on_bufenter[6]..gitgutter#process_buffer[3]..gitgutter#utility#is_active returning #0

continuing in function <SNR>46_on_bufenter[6]..gitgutter#process_buffer

line 4:     if a:force || s:has_fresh_changes(a:bufnr)
line 5: 
line 6:       let diff = ''
line 7:       try
line 8:         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
line 9:       catch /gitgutter not tracked/
line 10:         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
line 11:       catch /gitgutter diff failed/
line 12:         call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
line 13:         call gitgutter#hunk#reset(a:bufnr)
line 14:       endtry
line 15: 
line 16:       if diff != 'async'
line 17:         call gitgutter#diff#handler(a:bufnr, diff)
line 18:       endif
line 19: 
line 20:     endif
line 21:   endif
function <SNR>46_on_bufenter[6]..gitgutter#process_buffer returning #0

continuing in function <SNR>46_on_bufenter

line 7:   endif
function <SNR>46_on_bufenter returning #0

continuing in BufEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif

line 0: if exists('b:asyncomplete_enable') == 0 | call asyncomplete#enable_for_buffer() | endif
line 0:  call asyncomplete#enable_for_buffer() | endif
Searching for "autoload/asyncomplete.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/asyncomplete.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim"
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim"
line 1: if !has('timers')
line 2:     echohl ErrorMsg
line 3:     echomsg 'Vim/Neovim compiled with timers required for asyncomplete.vim.'
line 4:     echohl NONE
line 5:     if has('nvim')
line 6:         call asyncomplete#log('neovim compiled with timers required.')
line 7:     else
line 8:         call asyncomplete#log('vim compiled with timers required.')
line 9:     endif
line 10:     finish
line 11: endif
line 12: 
line 13: let s:sources = {}
line 14: let s:change_timer = -1
line 15: let s:on_changed_p = 0
line 16: let s:last_tick = []
line 17: let s:has_popped_up = 0
line 18: let s:complete_timer_ctx = {}
line 19: let s:already_setup = 0
line 20: let s:next_tick_single_exec_metadata = {}
line 21: let s:has_lua = has('lua') || has('nvim-0.2.2')
line 22: let s:supports_getbufinfo = exists('*getbufinfo')
line 23: let s:supports_smart_completion = exists('##TextChangedP')
line 24: let s:asyncomplete_folder = fnamemodify(expand('<sfile>:p:h') . '/../', ':p:h:gs?\\?/?')
chdir(/home/ringu/.vim/plugged/asyncomplete.vim/autoload/..)
fchdir() to previous dir
line 25: 
line 26: function! s:init_lua() abort
line 30: 
line 31: function! asyncomplete#log(...) abort
line 36: 
line 37: " do nothing, place it here only to avoid the message
line 38: augroup asyncomplete_silence_messages
line 39:     au!
line 40:     autocmd User asyncomplete_setup silent
line 41: augroup END
line 42: 
line 43: function! asyncomplete#enable_for_buffer() abort
line 78: 
line 79: function! asyncomplete#register_source(info) abort
line 101: 
line 102: function! asyncomplete#unregister_source(name) abort
line 112: 
line 113: function! s:clear_active_sources() abort
line 123: 
line 124: function! asyncomplete#complete(name, ctx, startcol, matches, ...) abort
line 137: 
line 138: function! asyncomplete#force_refresh() abort
line 141: 
line 142: function! asyncomplete#_force_refresh() abort
line 148: 
line 149: function! asyncomplete#context() abort
line 158: 
line 159: function! asyncomplete#context_changed(ctx) abort
line 165: 
line 166: function! s:change_tick_start() abort
line 175: 
line 176: function! s:change_tick_stop() abort
line 184: 
line 185: function! s:check_changes(...) abort
line 192: 
line 193: function! s:change_tick() abort
line 196: 
line 197: function! s:on_changed_common() abort
line 211: 
line 212: function! s:on_changed() abort
line 216: 
line 217: function! s:on_changed_p() abort
line 226: 
line 227: function! s:should_skip() abort
line 230: 
line 231: function! s:remote_insert_enter() abort
line 235: 
line 236: function! s:remote_insert_leave() abort
line 240: 
line 241: function! s:file_type_changed() abort
line 244: 
line 245: function! s:get_refresh_pattern(source) abort
line 254: 
line 255: function! s:remote_refresh(ctx, force) abort
line 290: 
line 291: function! s:python_cm_complete(name, ctx, startcol, matches, refresh, outdated) abort
line 313: 
line 314: function! s:python_cm_complete_timeout(srcs, ctx) abort
line 320: 
line 321: function! s:get_active_sources_for_buffer() abort
line 357: 
line 358: if exists('*matchstrpos')
line 359:     function! s:matchstrpos(expr, pattern) abort
line 362: else
line 363:     function! s:matchstrpos(expr, pattern) abort
line 366: endif
line 367: 
line 368: function! s:notify_sources_to_refresh(sources, ctx) abort
line 387: 
line 388: function! s:sort_sources_by_priority(source1, source2) abort
line 393: 
line 394: function! s:python_refresh_completions(ctx) abort
line 451: 
line 452: function! s:filter_completion_items(prefix, matches) abort
line 461: 
line 462: function! s:python_cm_event(name, event, ctx) abort
line 469: 
line 470: function! s:core_complete(ctx, startcol, matches, allmatches) abort
line 497: 
line 498: function! s:supports_smart_completion() abort
line 501: 
line 502: function! s:custom_filter_completion_items(prefix, matches) abort
line 505: 
line 506: function! s:complete_timeout(timer) abort
line 514: 
line 515: " helper function to queue the function at the end of the event loop.
line 516: " last function wins
line 517: function! s:next_tick_single_exec(id, func) abort
line 525: 
line 526: function s:next_tick_single_exec_callback(func, ...) abort
line 529: 
line 530: function! asyncomplete#menu_selected() abort
finished sourcing /home/ringu/.vim/plugged/asyncomplete.vim/autoload/asyncomplete.vim
continuing in BufEnter Autocommands for "*"
calling function asyncomplete#enable_for_buffer()

line 1:     if !s:already_setup
line 2:         if s:has_lua
line 3:             call s:init_lua()
calling function asyncomplete#enable_for_buffer[3]..<SNR>72_init_lua()

line 1:     exec 'lua asyncomplete_folder="' . s:asyncomplete_folder . '"'
line 1: lua asyncomplete_folder="/home/ringu/.vim/plugged/asyncomplete.vim"
line 2:     exec 'luafile ' . s:asyncomplete_folder . '/lua/asyncomplete.lua'
line 2: luafile /home/ringu/.vim/plugged/asyncomplete.vim/lua/asyncomplete.lua
function asyncomplete#enable_for_buffer[3]..<SNR>72_init_lua returning #0

continuing in function asyncomplete#enable_for_buffer

line 4:         endif
line 5:         doautocmd User asyncomplete_setup
Executing User Autocommands for "asyncomplete_setup"
autocommand silent

line 0: silent
line 6:         let s:already_setup = 1
line 7:     endif
line 8: 
line 9:     let b:asyncomplete_enable = 1
line 10:     if exists('##TextChangedP')
line 11:         augroup asyncomplete
line 12:             autocmd! * <buffer>
line 13:             autocmd InsertEnter <buffer> call s:remote_insert_enter()
line 14:             autocmd InsertLeave <buffer> call s:remote_insert_leave()
line 15:             autocmd TextChangedI <buffer> call s:on_changed()
line 16:             autocmd TextChangedP <buffer> call s:on_changed_p()
line 17:             autocmd FileType <buffer> call s:file_type_changed()
line 18:         augroup END
line 19:     else
line 20:         augroup asyncomplete
line 21:             autocmd! * <buffer>
line 22:             autocmd InsertEnter <buffer> call s:remote_insert_enter()
line 23:             autocmd InsertLeave <buffer> call s:remote_insert_leave()
line 24:             autocmd InsertEnter <buffer> call s:change_tick_start()
line 25:             autocmd InsertLeave <buffer> call s:change_tick_stop()
line 26:             autocmd FileType <buffer> call s:file_type_changed()
line 27:             " working together with timer, the timer is for detecting changes
line 28:             " popup menu is visible. TextChangedI will not be triggered when popup
line 29:             " menu is visible, but TextChangedI is more efficient and faster than
line 30:             " timer when popup menu is not visible.
line 31:             autocmd TextChangedI <buffer> call s:check_changes()
line 32:         augroup END
line 33:     endif
function asyncomplete#enable_for_buffer returning #0

continuing in BufEnter Autocommands for "*"

line 0:  endif
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

line 0: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>58_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
function <SNR>58_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand silent! autocmd! FileExplorer

line 0: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in VimEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif

line 0: if expand('<amatch>')==''|call fugitive#detect(getcwd())|endif
line 0: call fugitive#detect(getcwd())|endif
Searching for "autoload/fugitive.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete-lsp.vim/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/autoload/fugitive.vim"
Searching for "/usr/share/vim/vim81/autoload/fugitive.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/after/autoload/fugitive.vim"
Searching for "/home/ringu/.vim/after/autoload/fugitive.vim"
not found in 'runtimepath': "autoload/fugitive.vim"
calling function fugitive#detect('/home/ringu/sites/travel-site/app')

line 1:   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
line 2:     unlet b:git_dir
line 3:   endif
line 4:   if !exists('b:git_dir')
line 5:     let dir = fugitive#extract_git_dir(a:path)
calling function fugitive#detect[5]..fugitive#extract_git_dir('/home/ringu/sites/travel-site/app')

line 1:   if s:shellslash(a:path) =~# '^fugitive://.*//'
calling function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash('/home/ringu/sites/travel-site/app')

line 1:   if s:winshell()
calling function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect[5]..fugitive#extract_git_dir[1]..<SNR>45_shellslash returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 2:     return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
line 3:   endif
line 4:   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
calling function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash('/home/ringu/sites/travel-site/app')

line 1:   if s:winshell()
calling function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function fugitive#detect[5]..fugitive#extract_git_dir[4]..<SNR>45_shellslash returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 5:   let previous = ""
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     if fugitive#is_git_dir($GIT_DIR)
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir('')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub('', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub returning ''

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 20:       " Ensure that we've cached the worktree
line 21:       call s:configured_tree($GIT_DIR)
line 22:       if has_key(s:dir_for_worktree, root)
line 23:         return s:dir_for_worktree[root]
line 24:       endif
line 25:     endif
line 26:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub('/home/ringu/sites/travel-site/app', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 27:     let type = getftype(dir)
line 28:     if type ==# 'dir' && fugitive#is_git_dir(dir)
line 29:       return dir
line 30:     elseif type ==# 'link' && fugitive#is_git_dir(dir)
line 31:       return resolve(dir)
line 32:     elseif type !=# '' && filereadable(dir)
line 33:       let line = get(readfile(dir, '', 1), 0, '')
line 34:       if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
line 35:         return simplify(root.'/'.line[8:-1])
line 36:       elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
line 37:         return line[8:-1]
line 38:       endif
line 39:     elseif fugitive#is_git_dir(root)
calling function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir('/home/ringu/sites/travel-site/app')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir[1]..<SNR>45_sub('/home/ringu/sites/travel-site/app', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir[1]..<SNR>45_sub returning '/home/ringu/sites/travel-site/app'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[39]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 40:       return root
line 41:     endif
line 42:     let previous = root
line 43:     let root = fnamemodify(root, ':h')
line 44:   endwhile
line 6:   while root !=# previous
line 7:     if root =~# '\v^//%([^/]+/?)?$'
line 8:       " This is for accessing network shares from Cygwin Vim. There won't be
line 9:       " any git directory called //.git or //serverName/.git so let's avoid
line 10:       " checking for them since such checks are extremely slow.
line 11:       break
line 12:     endif
line 13:     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
line 14:       break
line 15:     endif
line 16:     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
line 17:       return $GIT_DIR
line 18:     endif
line 19:     if fugitive#is_git_dir($GIT_DIR)
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir('')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub('', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir[1]..<SNR>45_sub returning ''

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[19]..fugitive#is_git_dir returning #0

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 20:       " Ensure that we've cached the worktree
line 21:       call s:configured_tree($GIT_DIR)
line 22:       if has_key(s:dir_for_worktree, root)
line 23:         return s:dir_for_worktree[root]
line 24:       endif
line 25:     endif
line 26:     let dir = s:sub(root, '[\/]$', '') . '/.git'
calling function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub('/home/ringu/sites/travel-site', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[26]..<SNR>45_sub returning '/home/ringu/sites/travel-site'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 27:     let type = getftype(dir)
line 28:     if type ==# 'dir' && fugitive#is_git_dir(dir)
calling function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir('/home/ringu/sites/travel-site/.git')

line 1:   let path = s:sub(a:path, '[\/]$', '') . '/'
calling function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir[1]..<SNR>45_sub('/home/ringu/sites/travel-site/.git', '[\/]$', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir[1]..<SNR>45_sub returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir

line 2:   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10
function fugitive#detect[5]..fugitive#extract_git_dir[28]..fugitive#is_git_dir returning #1

continuing in function fugitive#detect[5]..fugitive#extract_git_dir

line 29:       return dir
function fugitive#detect[5]..fugitive#extract_git_dir returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect

line 6:     if dir !=# ''
line 7:       let b:git_dir = dir
line 8:     endif
line 9:   endif
line 10:   if exists('b:git_dir')
line 11:     if exists('#User#FugitiveBoot')
line 12:       try
line 13:         let [save_mls, &modelines] = [&mls, 0]
line 14:         doautocmd User FugitiveBoot
line 15:       finally
line 16:         let &mls = save_mls
line 17:       endtry
line 18:     endif
line 19:     cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
line 20:     nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
line 21:     let buffer = fugitive#buffer()
calling function fugitive#detect[21]..fugitive#buffer()

line 1:   return s:buffer(a:0 ? a:1 : '%')
calling function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer('%')

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer

line 4:     return buffer
function fugitive#detect[21]..fugitive#buffer[1]..<SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in function fugitive#detect[21]..fugitive#buffer

function fugitive#detect[21]..fugitive#buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in function fugitive#detect

line 22:     if expand('%:p') =~# '//'
line 23:       call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
line 24:     endif
line 25:     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
calling function fugitive#detect[25]..<SNR>45_buffer_getvar('&tags')

line 1:   return getbufvar(self['#'],a:var)
function fugitive#detect[25]..<SNR>45_buffer_getvar returning './tags,./TAGS,tags,TAGS'

continuing in function fugitive#detect

line 26:       if filereadable(b:git_dir.'/tags')
line 27:         call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
line 28:       endif
line 29:       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
line 30:         call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
line 31:       endif
line 32:     endif
line 33:     try
line 34:       let [save_mls, &modelines] = [&mls, 0]
line 35:       doautocmd User Fugitive
Executing User Autocommands for "Fugitive"
autocommand call s:define_commands()

line 0: call s:define_commands()
calling function <SNR>45_define_commands()

line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:GitComplete Git :execute s:Git(<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Gcd  :cd<bang>  `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=? -complete=customlist,s:DirComplete Glcd :lcd<bang> `=s:repo().bare() ? s:repo().dir(<q-args>) : s:repo().tree(<q-args>)`
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar Gstatus :execute s:Status()
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -complete=customlist,s:CommitComplete Gcommit :execute s:Commit(<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RevisionComplete Gmerge execute s:Merge('merge', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpull execute s:Merge('pull --progress', <bang>0, <q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Ggrep :execute s:Grep('grep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -nargs=? -complete=customlist,s:EditComplete Glgrep :execute s:Grep('lgrep',<bang>0,<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Glog :call s:Log('grep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -range=0 -complete=customlist,s:EditComplete Gllog :call s:Log('lgrep<bang>',<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Ge       :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gedit    :execute s:Edit('edit<bang>',0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gpedit   :execute s:Edit('pedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gsplit   :execute s:Edit('split',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gvsplit  :execute s:Edit('vsplit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditRunComplete Gtabedit :execute s:Edit('tabedit',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -count -complete=customlist,s:EditRunComplete Gread :execute s:Edit((!<count> && <line1> ? '' : <count>).'read',<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwrite :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gw :execute s:Write(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -nargs=* -complete=customlist,s:EditComplete Gwq :execute s:Wq(<bang>0,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gpush  execute s:Dispatch('<bang>', 'push '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -nargs=? -bang -complete=custom,s:RemoteComplete Gfetch execute s:Dispatch('<bang>', 'fetch '.<q-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bang -bar -nargs=* -complete=customlist,s:EditComplete Gdiff :execute s:Diff('',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gvdiff :execute s:Diff('keepalt vert ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -nargs=* -complete=customlist,s:EditComplete Gsdiff :execute s:Diff('keepalt ',<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 2: command! -buffer -bar -bang -range -nargs=* -complete=customlist,s:EditComplete Gbrowse :execute s:Browse(<bang>0,<line1>,<count>,<f-args>)
line 3:   endfor
line 1:   for command in s:commands
line 2:     exe 'command! -buffer '.command
line 3:   endfor
function <SNR>45_define_commands returning #0

continuing in User Autocommands for "Fugitive"

Executing User Autocommands for "Fugitive"
autocommand if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif

line 0: if s:buffer().commit() =~# '^0\=$' | exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
calling function <SNR>45_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function <SNR>45_buffer

line 4:     return buffer
function <SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in User Autocommands for "Fugitive"

calling function <SNR>45_buffer_commit()

line 1:   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec

function <SNR>45_buffer_commit[1]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_commit

function <SNR>45_buffer_commit returning ''

continuing in User Autocommands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)" | exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang -nargs=1 -complete=customlist,s:MoveComplete Gmove :execute s:Move(<bang>0,<q-args>)
line 0:  exe "command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)" | endif
line 0: command! -buffer -bar -bang Gremove :execute s:Remove(<bang>0)
line 0:  endif
Executing User Autocommands for "Fugitive"
autocommand if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif

line 0: if s:buffer().type('file', 'blob') | exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
calling function <SNR>45_buffer()

line 1:   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
line 2:   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
line 3:   if buffer.getvar('git_dir') !=# ''
calling function <SNR>45_buffer[3]..<SNR>45_buffer_getvar('git_dir')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer[3]..<SNR>45_buffer_getvar returning '/home/ringu/sites/travel-site/.git'

continuing in function <SNR>45_buffer

line 4:     return buffer
function <SNR>45_buffer returning {'containing_commit': function('<SNR>4...name': function('<SNR>45_buffer_name')}

continuing in User Autocommands for "Fugitive"

calling function <SNR>45_buffer_type('file', 'blob')

line 1:   if self.getvar('fugitive_type') != ''
calling function <SNR>45_buffer_type[1]..<SNR>45_buffer_getvar('fugitive_type')

line 1:   return getbufvar(self['#'],a:var)
function <SNR>45_buffer_type[1]..<SNR>45_buffer_getvar returning ''

continuing in function <SNR>45_buffer_type

line 2:     let type = self.getvar('fugitive_type')
line 3:   elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[3]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 4:     let type = 'head'
line 5:   elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
calling function <SNR>45_buffer_type[5]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[5]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 6:     let type = 'tree'
line 7:   elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
calling function <SNR>45_buffer_type[7]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[7]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 8:     let type = 'tree'
line 9:   elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
calling function <SNR>45_buffer_type[9]..<SNR>45_buffer_getline(1)

line 1:   return get(getbufline(self['#'], a:lnum), 0, '')
function <SNR>45_buffer_type[9]..<SNR>45_buffer_getline returning ''

continuing in function <SNR>45_buffer_type

line 10:     let type = 'index'
line 11:   elseif isdirectory(self.spec())
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[11]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 12:     let type = 'directory'
line 13:   elseif self.spec() == ''
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec()

line 1:     let bufname = bufname(self['#'])
line 2:     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash('')

line 1:   if s:winshell()
calling function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell()

line 1:   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash[1]..<SNR>45_winshell returning #0

continuing in function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash

line 2:     return s:gsub(a:path,'\\','/')
line 3:   else
line 4:     return a:path
function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec[2]..<SNR>45_shellslash returning ''

continuing in function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec

function <SNR>45_buffer_type[13]..<SNR>45_buffer_spec returning ''

continuing in function <SNR>45_buffer_type

line 14:     let type = 'null'
line 15:   else
line 16:     let type = 'file'
line 17:   endif
line 18:   if a:0
line 19:     return !empty(filter(copy(a:000),'v:val ==# type'))
function <SNR>45_buffer_type returning #0

continuing in User Autocommands for "Fugitive"

line 0:  exe "command! -buffer -bar -bang -range=0 -nargs=* Gblame :execute s:Blame(<bang>0,<line1>,<line2>,<count>,[<f-args>])" | endif
line 0:  endif
Executing User Autocommands for "Fugitive"
autocommand if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif

line 0: if &filetype =~# '^git\%(commit\)\=$' && &foldtext ==# 'foldtext()' |    set foldtext=fugitive#foldtext() | endif
line 0:     set foldtext=fugitive#foldtext() | endif
line 0:  endif
line 36:     finally
line 37:       let &mls = save_mls
line 38:     endtry
line 39:   endif
function fugitive#detect returning #0

continuing in VimEnter Autocommands for "*"

line 0: endif
Executing VimEnter Autocommands for "*"
autocommand if winnr() != winnr('$') | call gitgutter#all(0) | endif

line 0: if winnr() != winnr('$') | call gitgutter#all(0) | endif
line 0:  call gitgutter#all(0) | endif
line 0:  endif
Executing VimEnter Autocommands for "*"
autocommand call lsp#enable()

line 0: call lsp#enable()
Searching for "autoload/lsp.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload)
fchdir() to previous dir
line 0: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim"
line 1: let s:enabled = 0
line 2: let s:already_setup = 0
line 3: let s:servers = {} " { lsp_id, server_info, init_callbacks, init_result, buffers: { path: { changed_tick } }
line 4: 
line 5: let s:notification_callbacks = [] " { name, callback }
line 6: 
line 7: " do nothing, place it here only to avoid the message
line 8: augroup _lsp_silent_
line 9:     autocmd!
line 10:     autocmd User lsp_setup silent
line 11:     autocmd User lsp_register_server silent
line 12:     autocmd User lsp_unregister_server silent
line 13:     autocmd User lsp_server_init silent
line 14:     autocmd User lsp_server_exit silent
line 15: augroup END
line 16: 
line 17: function! lsp#log_verbose(...) abort
line 22: 
line 23: function! lsp#log(...) abort
line 28: 
line 29: function! lsp#enable() abort
line 43: 
line 44: function! lsp#disable() abort
line 52: 
line 53: function! lsp#get_server_names() abort
line 56: 
line 57: function! lsp#get_server_info(server_name) abort
line 60: 
line 61: function! lsp#get_server_capabilities(server_name) abort
line 65: 
line 66: function! s:server_status(server_name) abort
line 85: 
line 86: " Returns the current status of all servers (if called with no arguments) or
line 87: " the given server (if given an argument). Can be one of "unknown server",
line 88: " "exited", "starting", "failed", "running", "not running"
line 89: function! lsp#get_server_status(...) abort
line 97: 
line 98: " @params {server_info} = {
line 99: "   'name': 'go-langserver',        " requried, must be unique
line 100: "   'whitelist': ['go'],            " optional, array of filetypes to whitelist, * for all filetypes
line 101: "   'blacklist': [],                " optional, array of filetypes to blacklist, * for all filetypes,
line 102: "   'cmd': {server_info->['go-langserver]} " function that takes server_info and returns array of cmd and args, return empty if you don't want to start the server
line 103: " }
line 104: function! lsp#register_server(server_info) abort
line 117: 
line 118: function! lsp#register_notifications(name, callback) abort
line 121: 
line 122: function! lsp#unregister_notifications(name) abort
line 125: 
line 126: function! lsp#stop_server(server_name) abort
line 131: 
line 132: function! s:register_events() abort
line 143: 
line 144: function! s:unregister_events() abort
line 150: 
line 151: function! s:on_text_document_did_open() abort
line 158: 
line 159: function! s:on_text_document_did_save() abort
line 166: 
line 167: function! s:on_text_document_did_change() abort
line 174: 
line 175: function! s:on_cursor_moved() abort
line 178: 
line 179: function! s:call_did_save(buf, server_name, result, cb) abort
line 215: 
line 216: function! s:on_text_document_did_close() abort
line 219: 
line 220: function! s:ensure_flush_all(buf, server_names) abort
line 225: 
line 226: function! s:Noop(...) abort
line 228: 
line 229: function! s:is_step_error(s) abort
line 232: 
line 233: function! s:throw_step_error(s) abort
line 236: 
line 237: function! s:new_rpc_success(message, data) abort
line 245: 
line 246: function! s:new_rpc_error(message, data) abort
line 257: 
line 258: function! s:ensure_flush(buf, server_name, cb) abort
line 268: 
line 269: function! s:ensure_start(buf, server_name, cb) abort
line 320: 
line 321: function! s:ensure_init(buf, server_name, cb) abort
line 384: 
line 385: function! s:ensure_conf(buf, server_name, cb) abort
line 401: 
line 402: function! s:ensure_changed(buf, server_name, cb) abort
line 437: 
line 438: function! s:ensure_open(buf, server_name, cb) abort
line 471: 
line 472: function! s:send_request(server_name, data) abort
line 481: 
line 482: function! s:send_notification(server_name, data) abort
line 491: 
line 492: function! s:on_stderr(server_name, id, data, event) abort
line 495: 
line 496: function! s:on_exit(server_name, id, data, event) abort
line 509: 
line 510: function! s:on_notification(server_name, id, data, event) abort
line 533: 
line 534: function! s:handle_initialize(server_name, data) abort
line 554: 
line 555: " call lsp#get_whitelisted_servers()
line 556: " call lsp#get_whitelisted_servers(bufnr('%))
line 557: " call lsp#get_whitelisted_servers('typescript')
line 558: function! lsp#get_whitelisted_servers(...) abort
line 601: 
line 602: function! s:requires_eol_at_eof(buf) abort
line 608: 
line 609: function! s:get_text_document_text(buf) abort
line 614: 
line 615: function! s:get_text_document(buf, buffer_info) abort
line 623: 
line 624: function! lsp#get_text_document_identifier(...) abort
line 628: 
line 629: function! lsp#get_position(...) abort
line 632: 
line 633: function! s:get_text_document_identifier(buf, buffer_info) abort
line 639: 
line 640: function! lsp#send_request(server_name, request) abort
line 649: 
line 650: " omnicompletion
line 651: function! lsp#complete(...) abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp.vim
continuing in VimEnter Autocommands for "*"
calling function lsp#enable()

line 1:     if s:enabled
line 2:         return
line 3:     endif
line 4:     if !s:already_setup
line 5:         doautocmd User lsp_setup
Executing User Autocommands for "lsp_setup"
autocommand call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })

line 0: call lsp#register_server({ 'name' : 'flow', 'cmd' : {server_info->['flow','lsp']}, 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))}, 'whitelist': ['javascript', 'javascript.jsx'], })
calling function lsp#register_server({'cmd': function('<lambda>1'), 'root_u...ist': ['javascript', 'javascript.jsx']})

line 1:     let l:server_name = a:server_info['name']
line 2:     if has_key(s:servers, l:server_name)
line 3:         call lsp#log('lsp#register_server', 'server already registered', l:server_name)
line 4:     endif
line 5:     let s:servers[l:server_name] = { 'server_info': a:server_info, 'lsp_id': 0, 'buffers': {}, }
line 10:     call lsp#log('lsp#register_server', 'server registered', l:server_name)
calling function lsp#register_server[10]..lsp#log('lsp#register_server', 'server registered', 'flow')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#register_server[10]..lsp#log returning #0

continuing in function lsp#register_server

line 11:     doautocmd User lsp_register_server
Executing User Autocommands for "lsp_register_server"
autocommand silent

line 0: silent
function lsp#register_server returning #0

continuing in User Autocommands for "lsp_setup"

autocommand call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })

line 0: call lsp#register_server({ 'name': 'css-languageserver', 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']}, 'whitelist': ['css', 'less', 'sass'], })
calling function lsp#register_server({'cmd': function('<lambda>3'), 'name':..., 'whitelist': ['css', 'less', 'sass']})

line 1:     let l:server_name = a:server_info['name']
line 2:     if has_key(s:servers, l:server_name)
line 3:         call lsp#log('lsp#register_server', 'server already registered', l:server_name)
line 4:     endif
line 5:     let s:servers[l:server_name] = { 'server_info': a:server_info, 'lsp_id': 0, 'buffers': {}, }
line 10:     call lsp#log('lsp#register_server', 'server registered', l:server_name)
calling function lsp#register_server[10]..lsp#log('lsp#register_server', 'server registered', 'css-languageserver')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#register_server[10]..lsp#log returning #0

continuing in function lsp#register_server

line 11:     doautocmd User lsp_register_server
Executing User Autocommands for "lsp_register_server"
autocommand silent

line 0: silent
function lsp#register_server returning #0

continuing in User Autocommands for "lsp_setup"

Executing User Autocommands for "lsp_setup"
autocommand silent

line 0: silent
line 6:         let s:already_setup = 1
line 7:     endif
line 8:     let s:enabled = 1
line 9:     if g:lsp_diagnostics_enabled && g:lsp_signs_enabled
line 10:         call lsp#ui#vim#signs#enable()
line 11:     endif
line 12:     call s:register_events()
calling function lsp#enable[12]..<SNR>73_register_events()

line 1:     augroup lsp
line 2:         autocmd!
line 3:         autocmd BufReadPost * call s:on_text_document_did_open()
line 4:         autocmd BufWritePost * call s:on_text_document_did_save()
line 5:         autocmd BufWinLeave * call s:on_text_document_did_close()
line 6:         autocmd InsertLeave * call s:on_text_document_did_change()
line 7:         autocmd CursorMoved * call s:on_cursor_moved()
line 8:     augroup END
line 9:     call s:on_text_document_did_open()
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open()

line 1:     let l:buf = bufnr('%')
line 2:     call lsp#log('s:on_text_document_did_open()', l:buf, &filetype, getcwd(), lsp#utils#get_buffer_uri(l:buf))
Searching for "autoload/lsp/utils.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp/utils.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload/lsp)
fchdir() to previous dir
line 2: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim"
line 1: function! lsp#utils#is_remote_uri(uri) abort
line 4: 
line 5: " Decode uri function is taken from vital framework: https://github.com/vim-jp/vital.vim
line 6: " For it's license (NYSL), see http://www.kmonos.net/nysl/index.en.html
line 7: function! s:decode_uri(uri) abort
line 11: 
line 12: function! s:urlencode_char(c) abort
line 15: 
line 16: function! s:get_prefix(path) abort
line 19: 
line 20: function! s:encode_uri(path, start_pos_encode, default_prefix) abort
line 40: 
line 41: if has('win32') || has('win64')
line 42:     function! lsp#utils#path_to_uri(path) abort
line 57: else
line 58:     function! lsp#utils#path_to_uri(path) abort
line 65: endif
line 66: 
line 67: if has('win32') || has('win64')
line 68:     function! lsp#utils#uri_to_path(uri) abort
line 71: else
line 72:     function! lsp#utils#uri_to_path(uri) abort
line 75: endif
line 76: 
line 77: function! lsp#utils#get_default_root_uri() abort
line 80: 
line 81: function! lsp#utils#get_buffer_path(...) abort
line 84: 
line 85: function! lsp#utils#get_buffer_uri(...) abort
line 88: 
line 89: " Find a nearest to a `path` parent directory `directoryname` by traversing the filesystem upwards
line 90: function! lsp#utils#find_nearest_parent_directory(path, directoryname) abort
line 99: 
line 100: " Find a nearest to a `path` parent filename `filename` by traversing the filesystem upwards
line 101: function! lsp#utils#find_nearest_parent_file(path, filename) abort
line 110: 
line 111: " Find a nearest to a `path` parent filename `filename` by traversing the filesystem upwards
line 112: function! lsp#utils#find_nearest_parent_file_directory(path, filename) abort
line 121: 
line 122: if exists('*matchstrpos')
line 123:     function! lsp#utils#matchstrpos(expr, pattern) abort
line 126: else
line 127:     function! lsp#utils#matchstrpos(expr, pattern) abort
line 130: endif
line 131: 
line 132: function! lsp#utils#empty_complete(...) abort
line 135: 
line 136: function! lsp#utils#error(msg) abort
line 141: 
line 142: function! lsp#utils#echo_with_truncation(msg) abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp/utils.vim
continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri(1)

line 1:     return lsp#utils#path_to_uri(expand((a:0 > 0 ? '#' . a:1 : '%') . ':p'))
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri[1]..lsp#utils#path_to_uri('')

line 1:         if empty(a:path)
line 2:             return a:path
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri[1]..lsp#utils#path_to_uri returning ''

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri

function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#utils#get_buffer_uri returning ''

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#log('s:on_text_document_did_open()', 1, '', '/home/ringu/sites/travel-site/app', '')

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[2]..lsp#log returning #0

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

line 3:     for l:server_name in lsp#get_whitelisted_servers()
calling function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[3]..lsp#get_whitelisted_servers()

line 1:     if a:0 == 0
line 2:         let l:buffer_filetype = &filetype
line 3:     else
line 4:         if type(a:1) == type('')
line 5:             let l:buffer_filetype = a:1
line 6:         else
line 7:             let l:buffer_filetype = getbufvar(a:1, '&filetype')
line 8:         endif
line 9:     endif
line 10: 
line 11:     " TODO: cache active servers per buffer
line 12:     let l:active_servers = []
line 13: 
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 14:     for l:server_name in keys(s:servers)
line 15:         let l:server_info = s:servers[l:server_name]['server_info']
line 16:         let l:blacklisted = 0
line 17: 
line 18:         if has_key(l:server_info, 'blacklist')
line 19:             for l:filetype in l:server_info['blacklist']
line 20:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 21:                     let l:blacklisted = 1
line 22:                     break
line 23:                 endif
line 24:             endfor
line 25:         endif
line 26: 
line 27:         if l:blacklisted
line 28:             continue
line 29:         endif
line 30: 
line 31:         if has_key(l:server_info, 'whitelist')
line 32:             for l:filetype in l:server_info['whitelist']
line 33:                 if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
line 34:                     let l:active_servers += [l:server_name]
line 35:                     break
line 36:                 endif
line 37:             endfor
line 38:         endif
line 39:     endfor
line 40: 
line 41:     return l:active_servers
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open[3]..lsp#get_whitelisted_servers returning []

continuing in function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open

line 4:         call s:ensure_flush(l:buf, l:server_name, function('s:Noop'))
line 5:     endfor
function lsp#enable[12]..<SNR>73_register_events[9]..<SNR>73_on_text_document_did_open returning #0

continuing in function lsp#enable[12]..<SNR>73_register_events

function lsp#enable[12]..<SNR>73_register_events returning #0

continuing in function lsp#enable

function lsp#enable returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call lightline#update_once()

line 0: call lightline#update_once()
calling function lightline#update_once()

line 1:   if !exists('w:lightline') || w:lightline
line 2:     call lightline#update()
line 3:   endif
function lightline#update_once returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif

line 0: if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
line 0:  call ale#cursor#EchoCursorWarningWithDelay() | endif
line 0:  endif
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

line 0: call s:Highlight_Matching_Pair()
calling function <SNR>57_Highlight_Matching_Pair()

line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
function <SNR>57_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:on_cursor_moved()

line 0: call s:on_cursor_moved()
calling function <SNR>73_on_cursor_moved()

line 1:     call lsp#ui#vim#diagnostics#echo#cursor_moved()
Searching for "autoload/lsp/ui/vim/diagnostics/echo.vim" in "/home/ringu/.vim,/home/ringu/.vim/plugged/lightline.vim/,/home/ringu/.vim/plugged/vim-surround/,/home/ringu/.vim/plugged/auto-pairs/,/home/ringu/.vim/plugged/ale/,/home/ringu/.vim/plugged/nerdtree/,/home/ringu/.vim/plugged/emmet-vim/,/home/ringu/.vim/plugged/vim-devicons/,/home/ringu/.vim/plugged/fzf.vim/,/home/ringu/.vim/plugged/fugitive.vim/,/home/ringu/.vim/plugged/vim-gitgutter/,/home/ringu/.vim/plugged/indentLine/,/home/ringu/.vim/plugged/asyncomplete.vim/,/home/ringu/.vim/plugged/async.vim/,/home/ringu/.vim/plugged/vim-lsp/,/home/ringu/.vim/plugged/asyncomplete-lsp.vim/,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/ringu/.vim/plugged/indentLine/after,/home/ringu/.vim/after"
Searching for "/home/ringu/.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/lightline.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-surround/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/auto-pairs/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/ale/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/nerdtree/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/emmet-vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-devicons/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/fzf.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/fugitive.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-gitgutter/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/indentLine/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/asyncomplete.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/async.vim/autoload/lsp/ui/vim/diagnostics/echo.vim"
Searching for "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim"
chdir(/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics)
fchdir() to previous dir
line 1: sourcing "/home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim"
line 1: function! lsp#ui#vim#diagnostics#echo#cursor_moved() abort
line 21: 
line 22: function! s:echo_diagnostics_under_cursor(...) abort
line 28: 
line 29: function! s:stop_cursor_moved_timer() abort
finished sourcing /home/ringu/.vim/plugged/vim-lsp/autoload/lsp/ui/vim/diagnostics/echo.vim
continuing in function <SNR>73_on_cursor_moved
calling function <SNR>73_on_cursor_moved[1]..lsp#ui#vim#diagnostics#echo#cursor_moved()

line 1:     if !g:lsp_diagnostics_echo_cursor
line 2:         return
function <SNR>73_on_cursor_moved[1]..lsp#ui#vim#diagnostics#echo#cursor_moved returning #0

continuing in function <SNR>73_on_cursor_moved

function <SNR>73_on_cursor_moved returning #0

continuing in CursorMoved Autocommands for "*"

calling function lightline#tabline()

line 1:   if !has_key(s:highlight, 'tabline')
line 2:     call lightline#highlight('tabline')
calling function lightline#tabline[2]..lightline#highlight('tabline')

line 1:   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
line 2:   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
line 3:   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
line 4:   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
line 5:   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#3e4452', 235, 240])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning ''

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineLeft_tabline_0 guifg=#282c34 guibg=#3e4452 ctermfg=235 ctermbg=240 
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_0_1 guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_0_tabsel guifg=#3e4452 guibg=#c678dd ctermfg=240 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineLeft_tabline_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_0 guifg=#c678dd guibg=#3e4452 ctermfg=176 ctermbg=240
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_1 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineLeft_tabline_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#98c379', 235, 76, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineRight_tabline_0 guifg=#282c34 guibg=#98c379 ctermfg=235 ctermbg=76 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_0_1 guifg=#98c379 guibg=#2c323d ctermfg=76 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_0_tabsel guifg=#98c379 guibg=#c678dd ctermfg=76 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
calling function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term(['#282c34', '#c678dd', 235, 176, 'bold'])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[18]..<SNR>66_term returning 'term=bold cterm=bold gui=bold'

continuing in function lightline#tabline[2]..lightline#highlight

line 18: hi LightlineRight_tabline_tabsel guifg=#282c34 guibg=#c678dd ctermfg=235 ctermbg=176 term=bold cterm=bold gui=bold
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_0 guifg=#c678dd guibg=#98c379 ctermfg=176 ctermbg=76
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_1 guifg=#c678dd guibg=#2c323d ctermfg=176 ctermbg=235
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 23: hi LightlineRight_tabline_tabsel_tabsel guifg=#c678dd guibg=#c678dd ctermfg=176 ctermbg=176
line 24:           endif
line 25:         endfor
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
calling function lightline#tabline[2]..lightline#highlight[28]..<SNR>66_term(['#3e4452', '#2c323d', 240, 235])

line 1:   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''
function lightline#tabline[2]..lightline#highlight[28]..<SNR>66_term returning ''

continuing in function lightline#tabline[2]..lightline#highlight

line 28: hi LightlineMiddle_tabline guifg=#3e4452 guibg=#2c323d ctermfg=240 ctermbg=235 
line 29:   endfor
line 6:   for mode in modes
line 7:     let s:highlight[mode] = 1
line 8:     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
line 9:     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
line 10:     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
line 11:     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
line 12:     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
line 13:     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
line 14:     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
line 15:       for [i, t] in map(range(0, l), '[v:val, 0]') + types
line 16:         if i < l || i < 1
line 17:           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
line 18:           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
line 19:         endif
line 20:         for [j, s] in map(range(0, l), '[v:val, 0]') + types
line 21:           if i + 1 == j || t || s && i != l
line 22:             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
line 23:             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
line 24:           endif
line 25:         endfor
line 26:       endfor
line 27:     endfor
line 28:     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
line 29:   endfor
function lightline#tabline[2]..lightline#highlight returning #0

continuing in function lightline#tabline

line 3:   endif
line 4:   if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
line 5:     let s:tabnr = tabpagenr()
line 6:     let s:tabcnt = tabpagenr('$')
line 7:     let s:tabline = s:line(1, 0)
calling function lightline#tabline[7]..<SNR>66_line(1, 0)

line 1:   let _ = a:tabline ? '' : '%{lightline#link()}'
line 2:   if s:lightline.palette == {}
line 3:     call lightline#colorscheme()
line 4:   endif
line 5:   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
line 6:   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
line 7:   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
line 8:   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
line 9:   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
line 10:   let [lt, lc, ll] = s:expand(copy(l_))
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand([['tabs', 'filename']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('tabs', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand('lightline#tabs')

line 1:   try
line 2:     let result = eval(a:component . '()')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[2]..lightline#tabs()

line 1:   let [x, y, z] = [[], [], []]
line 2:   let nr = tabpagenr()
line 3:   let cnt = tabpagenr('$')
line 4:   for i in range(1, cnt)
line 5:     call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
line 6:   endfor
line 4:   for i in range(1, cnt)
line 5:     call add(i < nr ? x : i == nr ? y : z, (i > nr + 3 ? '%<' : '') . '%'. i . 'T%{lightline#onetab(' . i . ',' . (i == nr) . ')}' . (i == cnt ? '%T' : ''))
line 6:   endfor
line 7:   let abbr = '...'
line 8:   let n = min([max([s:lightline.winwidth / 40, 2]), 8])
line 9:   if len(x) > n && len(z) > n
line 10:     let x = extend(add(x[:n/2-1], abbr), x[-(n+1)/2:])
line 11:     let z = extend(add(z[:(n+1)/2-1], abbr), z[-n/2:])
line 12:   elseif len(x) + len(z) > 2 * n
line 13:     if len(x) > n
line 14:       let x = extend(add(x[:(2*n-len(z))/2-1], abbr), x[-(2*n-len(z)+1)/2:])
line 15:     elseif len(z) > n
line 16:       let z = extend(add(z[:(2*n-len(x)+1)/2-1], abbr), z[-(2*n-len(x))/2:])
line 17:     endif
line 18:   endif
line 19:   return [x, y, z]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[2]..lightline#tabs returning [[], ['%1T%{lightline#onetab(1,1)}%T'], []]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

line 3:     if type(result) == 1 && result ==# ''
line 4:       return []
line 5:     endif
line 6:   catch
line 7:     return []
line 8:   endtry
line 9:   return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')
calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize([])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning []

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize(['%1T%{lightline#onetab(1,1)}%T'])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning ['%1T%{lightline#onetab(1,1)}%T']

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize([])

line 1:   if type(a:result) == 3
line 2:     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand[9]..<SNR>66_normalize returning []

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand

function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert[4]..<SNR>66_evaluate_expand returning [[], ['%1T%{lightline#onetab(1,1)}%T'], []]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert

function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['%1T%{lightline#onetab(1,1)}%T'], 1, 'tabsel', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert('filename', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_convert returning [[['filename'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['%1T%{lightline#onetab(1,1)}%T'],... '0']], [[['filename'], 0, '0', '0']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['%1T%{lightline#onetab(1,1)}%T'], 1...el', '0'], [['filename'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#tabline[7]..<SNR>66_line[10]..<SNR>66_expand returning [[['%1T%{lightline#onetab(1,1)}%T'], [...e']], [[1], [0]], ['tabsel', '0', '1']]

continuing in function lightline#tabline[7]..<SNR>66_line

line 11:   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
line 12:   let [rt, rc, rl] = s:expand(copy(r_))
calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand([['close']])

line 1:   let components = []
line 2:   let expanded = []
line 3:   let indices = []
line 4:   let prevtype = ''
line 5:   let previndex = -1
line 6:   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert('close', '0')

line 1:   if has_key(s:lightline.component_expand, a:name)
line 2:     let type = get(s:lightline.component_type, a:name, a:index)
line 3:     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
line 4:     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
line 6:   else
line 7:     return [[[a:name], 0, a:index, a:index]]
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_convert returning [[['close'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand

calling function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice([[[[['close'], 0, '0', '0']]]])

line 1:   let ys = []
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 2:   for xs in a:xss
line 3:     for x in xs
line 4:       let ys += x
line 5:     endfor
line 6:   endfor
line 7:   return ys
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand[6]..<SNR>66_flatten_twice returning [[['close'], 0, '0', '0']]

continuing in function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand

line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 7:   for [component, expand, type, index] in xs
line 8:     if prevtype !=# type
line 9:       for i in range(previndex + 1, max([previndex, index - 1]))
line 10:         call add(indices, string(i))
line 11:         call add(components, [])
line 12:         call add(expanded, [])
line 13:       endfor
line 14:       call add(indices, type)
line 15:       call add(components, [])
line 16:       call add(expanded, [])
line 17:     endif
line 18:     call extend(components[-1], component)
line 19:     call extend(expanded[-1], repeat([expand], len(component)))
line 20:     let prevtype = type
line 21:     let previndex = index
line 22:   endfor
line 23:   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
line 24:     call add(indices, string(i))
line 25:     call add(components, [])
line 26:     call add(expanded, [])
line 27:   endfor
line 28:   call add(indices, string(len(a:components)))
line 29:   return [components, expanded, indices]
function lightline#tabline[7]..<SNR>66_line[12]..<SNR>66_expand returning [[['close']], [[0]], ['0', '1']]

continuing in function lightline#tabline[7]..<SNR>66_line

line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 13:   for i in range(len(lt))
line 14:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
line 15:     for j in range(len(lt[i]))
line 16:       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
line 17:       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 18:       if j < len(lt[i]) - 1 && s.left !=# ''
line 19:         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
line 20:       endif
line 21:     endfor
line 22:     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
line 23:     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
line 24:   endfor
line 25:   let _ .= '%#LightlineMiddle_' . mode . '#%='
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 26:   for i in reverse(range(len(rt)))
line 27:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
line 28:     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
line 29:     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
line 30:     for j in range(len(rt[i]))
line 31:       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
line 32:       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
line 33:       if j < len(rt[i]) - 1 && s.right !=# ''
line 34:         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
line 35:       endif
line 36:     endfor
line 37:   endfor
line 38:   return _
function lightline#tabline[7]..<SNR>66_line returning '%#LightlineLeft_tabline_tabsel#%( %1T...1#%#LightlineRight_tabline_0#%999X X '

continuing in function lightline#tabline

line 8:   endif
line 9:   return s:tabline
function lightline#tabline returning '%#LightlineLeft_tabline_tabsel#%( %1T...1#%#LightlineRight_tabline_0#%999X X '

calling function lightline#onetab(1, 1)

line 1:   let _ = []
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#tabnum(1)

line 1:   return a:n
function lightline#onetab[4]..lightline#tab#tabnum returning #1

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#filename(1)

line 1:   let buflist = tabpagebuflist(a:n)
line 2:   let winnr = tabpagewinnr(a:n)
line 3:   let _ = expand('#'.buflist[winnr - 1].':t')
line 4:   return _ !=# '' ? _ : '[No Name]'
function lightline#onetab[4]..lightline#tab#filename returning '[No Name]'

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
calling function lightline#onetab[4]..lightline#tab#modified(1)

line 1:   let winnr = tabpagewinnr(a:n)
line 2:   return gettabwinvar(a:n, winnr, '&modified') ? '+' : gettabwinvar(a:n, winnr, '&modifiable') ? '' : '-'
function lightline#onetab[4]..lightline#tab#modified returning ''

continuing in function lightline#onetab

line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 2:   for name in a:active ? s:lightline.tab.active : s:lightline.tab.inactive
line 3:     if has_key(s:lightline.tab_component_function, name)
line 4:       call add(_, call(s:lightline.tab_component_function[name], [a:n]))
line 5:     else
line 6:       call add(_, get(s:lightline.tab_component, name, ''))
line 7:     endif
line 8:   endfor
line 9:   return join(filter(_, 'v:val !=# ""'), ' ')
function lightline#onetab returning '1 [No Name]'

calling function lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
function lightline#link returning ''

calling function lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
function lightline#mode returning 'NORMAL'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function lightline#link()

line 1:   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
line 2:   if s:mode == mode
line 3:     return ''
function lightline#link returning ''

calling function lightline#mode()

line 1:   return get(s:lightline.mode_map, mode(), '')
function lightline#mode returning 'NORMAL'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'

calling function fugitive#head()

line 1:   if !exists('b:git_dir')
line 2:     return ''
line 3:   endif
line 4: 
line 5:   return s:repo().head(a:0 ? a:1 : 0)
calling function fugitive#head[5]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head

calling function fugitive#head[5]..<SNR>45_repo_head(0)

line 1:     let head = s:repo().head_ref()
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo()

line 1:   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
line 2:   if dir !=# ''
line 3:     if has_key(s:repos, dir)
line 4:       let repo = get(s:repos, dir)
line 5:     else
line 6:       let repo = {'git_dir': dir}
line 7:       let s:repos[dir] = repo
line 8:     endif
line 9:     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo returning {'keywordprg': function('<SNR>45_repo_...p': function('<SNR>45_repo_git_chomp')}

continuing in function fugitive#head[5]..<SNR>45_repo_head

calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref()

line 1:   if !filereadable(self.dir('HEAD'))
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[1]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

line 2:     return ''
line 3:   endif
line 4:   return readfile(self.dir('HEAD'))[0]
calling function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir('HEAD')

line 1:   return join([self.git_dir]+a:000,'/')
function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref[4]..<SNR>45_repo_dir returning '/home/ringu/sites/travel-site/.git/HEAD'

continuing in function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref

function fugitive#head[5]..<SNR>45_repo_head[1]..<SNR>45_repo_head_ref returning 'ref: refs/heads/master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 2: 
line 3:     if head =~# '^ref: '
line 4:       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
calling function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub('ref: refs/heads/master', '^ref: %(refs/%(heads/|remotes/|tags/)=)=', '')

line 1:   return substitute(a:str,'\v\C'.a:pat,a:rep,'')
function fugitive#head[5]..<SNR>45_repo_head[4]..<SNR>45_sub returning 'master'

continuing in function fugitive#head[5]..<SNR>45_repo_head

line 5:     elseif head =~# '^\x\{40\}$'
line 6:       " truncate hash to a:1 characters if we're in detached head mode
line 7:       let len = a:0 ? a:1 : 0
line 8:       let branch = len ? head[0:len-1] : ''
line 9:     else
line 10:       return ''
line 11:     endif
line 12: 
line 13:     return branch
function fugitive#head[5]..<SNR>45_repo_head returning 'master'

continuing in function fugitive#head

function fugitive#head returning 'master'


Executing QuitPre Autocommands for "*"
autocommand call ale#events#QuitEvent(str2nr(expand('<abuf>')))

line 0: call ale#events#QuitEvent(str2nr(expand('<abuf>')))
calling function ale#events#QuitEvent(1)

line 1:     " Remember when ALE is quitting for BufWrite, etc.
line 2:     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())
calling function ale#events#QuitEvent[2]..ale#events#ClockMilliseconds()

line 1:     return float2nr(reltimefloat(reltime()) * 1000)
function ale#events#QuitEvent[2]..ale#events#ClockMilliseconds returning #1547284975143

continuing in function ale#events#QuitEvent

function ale#events#QuitEvent returning #0

continuing in QuitPre Autocommands for "*"

Executing BufWinLeave Autocommands for "*"
autocommand execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')

line 0: execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
line 0: 
Executing BufWinLeave Autocommands for "*"
autocommand if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif

line 0: if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |   call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
calling function <SNR>45_can_diffoff(1)

line 1:   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
function <SNR>45_can_diffoff returning #0

continuing in BufWinLeave Autocommands for "*"

line 0:    call s:diffoff_all(getbufvar(+expand('<abuf>'), 'git_dir')) | endif
line 0:  endif
Executing BufWinLeave Autocommands for "*"
autocommand call s:on_text_document_did_close()

line 0: call s:on_text_document_did_close()
calling function <SNR>73_on_text_document_did_close()

line 1:     call lsp#log('s:on_text_document_did_close()', bufnr('%'))
calling function <SNR>73_on_text_document_did_close[1]..lsp#log('s:on_text_document_did_close()', 1)

line 1:     if !empty(g:lsp_log_file)
line 2:         call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
line 3:     endif
function <SNR>73_on_text_document_did_close[1]..lsp#log returning #0

continuing in function <SNR>73_on_text_document_did_close

function <SNR>73_on_text_document_did_close returning #0

continuing in BufWinLeave Autocommands for "*"

Executing BufUnload Autocommands for "*"
autocommand call lightline#update_once()

line 0: call lightline#update_once()
calling function lightline#update_once()

line 1:   if !exists('w:lightline') || w:lightline
line 2:     call lightline#update()
line 3:   endif
function lightline#update_once returning #0

continuing in BufUnload Autocommands for "*"

Writing viminfo file "/home/ringu/.viminfo"